<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: white;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
  counter-reset: line;
  display: flex;
  flex-direction: column;
}

.code-line::before {
    content: counter(line);
    margin-right: 10px;
}
.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
  counter-increment: line;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["D:","\\","GitHub","context-builder","src","cache.rs"],"content":"//! Cache management for context-builder.\r\n//!\r\n//! This module handles caching of project states to enable the auto-diff feature.\r\n//! It uses a hash of the project path and configuration to avoid cache collisions\r\n//! between different projects or configurations.\r\n\r\nuse fs2::FileExt;\r\n\r\nuse std::collections::hash_map::DefaultHasher;\r\nuse std::fs;\r\nuse std::fs::File;\r\nuse std::hash::{Hash, Hasher};\r\nuse std::io::{Read, Write};\r\nuse std::path::{Path, PathBuf};\r\n\r\nuse crate::config::Config;\r\nuse crate::state::ProjectState;\r\n\r\n/// Manages cache operations with file locking to prevent corruption\r\npub struct CacheManager {\r\n    cache_dir: PathBuf,\r\n    project_hash: String,\r\n    config_hash: String,\r\n}\r\n\r\nimpl CacheManager {\r\n    /// Create a new cache manager for the given project path and configuration\r\n    pub fn new(project_path: \u0026Path, config: \u0026Config) -\u003e Self {\r\n        // Normalize the project path first for consistency\r\n        let normalized_project_path = Self::normalize_project_path(project_path);\r\n\r\n        let project_hash = Self::hash_path(\u0026normalized_project_path);\r\n        let config_hash = Self::hash_config(config);\r\n\r\n        // Ensure cache directory exists relative to normalized project root\r\n        let cache_dir = normalized_project_path\r\n            .join(\".context-builder\")\r\n            .join(\"cache\");\r\n        if !cache_dir.exists() {\r\n            let _ = fs::create_dir_all(\u0026cache_dir);\r\n        }\r\n\r\n        let cache_manager = Self {\r\n            cache_dir,\r\n            project_hash,\r\n            config_hash,\r\n        };\r\n\r\n        // Migrate old cache format if present\r\n        cache_manager.migrate_old_cache();\r\n\r\n        cache_manager\r\n    }\r\n\r\n    /// Normalize project path for consistent hashing and cache directory creation\r\n    fn normalize_project_path(path: \u0026Path) -\u003e PathBuf {\r\n        // Always resolve to absolute path first\r\n        let absolute_path = if path.is_absolute() {\r\n            path.to_path_buf()\r\n        } else {\r\n            match std::env::current_dir() {\r\n                Ok(cwd) =\u003e cwd.join(path),\r\n                Err(_) =\u003e path.to_path_buf(),\r\n            }\r\n        };\r\n\r\n        // Try to canonicalize for consistency, but normalize the result\r\n        if let Ok(canonical) = absolute_path.canonicalize() {\r\n            Self::normalize_path_format(\u0026canonical)\r\n        } else {\r\n            absolute_path\r\n        }\r\n    }\r\n\r\n    /// Generate a hash from the normalized project path\r\n    fn hash_path(path: \u0026Path) -\u003e String {\r\n        let mut hasher = DefaultHasher::new();\r\n        path.hash(\u0026mut hasher);\r\n        format!(\"{:x}\", hasher.finish())\r\n    }\r\n\r\n    /// Normalize path format to handle Windows UNC prefixes\r\n    fn normalize_path_format(path: \u0026Path) -\u003e PathBuf {\r\n        let path_str = path.to_string_lossy();\r\n\r\n        // Remove Windows UNC prefix if present\r\n        if cfg!(windows) \u0026\u0026 path_str.starts_with(\"\\\\\\\\?\\\\\") {\r\n            PathBuf::from(\u0026path_str[4..])\r\n        } else {\r\n            path.to_path_buf()\r\n        }\r\n    }\r\n\r\n    /// Generate a hash from the configuration\r\n    fn hash_config(config: \u0026Config) -\u003e String {\r\n        let mut hasher = DefaultHasher::new();\r\n        // Hash the relevant configuration parameters that affect output\r\n        config.filter.hash(\u0026mut hasher);\r\n        config.ignore.hash(\u0026mut hasher);\r\n        config.line_numbers.hash(\u0026mut hasher);\r\n        format!(\"{:x}\", hasher.finish())\r\n    }\r\n\r\n    /// Get the cache file path for this specific project and configuration\r\n    fn get_cache_path(\u0026self) -\u003e PathBuf {\r\n        self.cache_dir.join(format!(\r\n            \"state_{}_{}.json\",\r\n            self.project_hash, self.config_hash\r\n        ))\r\n    }\r\n\r\n    /// Public helper primarily for debugging/tests to inspect the resolved cache path\r\n    pub fn debug_cache_file_path(\u0026self) -\u003e PathBuf {\r\n        self.get_cache_path()\r\n    }\r\n\r\n    /// Migrate old markdown-based cache files to new JSON format\r\n    fn migrate_old_cache(\u0026self) {\r\n        let old_cache_patterns = [\"last_canonical.md\", \"last_output.md\", \"current_output.md\"];\r\n\r\n        for pattern in \u0026old_cache_patterns {\r\n            let old_cache_path = self.cache_dir.join(pattern);\r\n            if old_cache_path.exists() {\r\n                eprintln!(\"Migrating old cache format: removing {}\", pattern);\r\n                let _ = fs::remove_file(\u0026old_cache_path);\r\n            }\r\n        }\r\n\r\n        // Also remove any files that look like timestamped outputs from old versions\r\n        if let Ok(entries) = fs::read_dir(\u0026self.cache_dir) {\r\n            for entry in entries.flatten() {\r\n                let file_name = entry.file_name();\r\n                let name = file_name.to_string_lossy();\r\n                if name.ends_with(\".md\") \u0026\u0026 (name.contains(\"_20\") || name.starts_with(\"output_\")) {\r\n                    eprintln!(\"Migrating old cache format: removing {}\", name);\r\n                    let _ = fs::remove_file(entry.path());\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /// Read the cached project state with file locking\r\n    pub fn read_cache(\u0026self) -\u003e Result\u003cOption\u003cProjectState\u003e, Box\u003cdyn std::error::Error\u003e\u003e {\r\n        let cache_path = self.get_cache_path();\r\n\r\n        if !cache_path.exists() {\r\n            return Ok(None);\r\n        }\r\n\r\n        let file = File::open(\u0026cache_path)?;\r\n        // Acquire shared lock to prevent reading while writing\r\n        file.lock_shared()?;\r\n\r\n        let mut contents = String::new();\r\n        let mut file = std::io::BufReader::new(file);\r\n        file.read_to_string(\u0026mut contents)?;\r\n\r\n        // Release lock\r\n        file.get_ref().unlock()?;\r\n\r\n        let state: ProjectState = serde_json::from_str(\u0026contents)?;\r\n        Ok(Some(state))\r\n    }\r\n\r\n    /// Write the project state to cache with file locking\r\n    pub fn write_cache(\u0026self, state: \u0026ProjectState) -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\r\n        let cache_path = self.get_cache_path();\r\n\r\n        let file = File::create(\u0026cache_path)?;\r\n        // Acquire exclusive lock to prevent concurrent writes\r\n        file.lock_exclusive()?;\r\n\r\n        let json = serde_json::to_string_pretty(state)?;\r\n        let mut file = std::io::BufWriter::new(file);\r\n        file.write_all(json.as_bytes())?;\r\n        file.flush()?;\r\n\r\n        // Release lock\r\n        file.get_ref().unlock()?;\r\n\r\n        Ok(())\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n    use std::path::Path;\r\n    use tempfile::tempdir;\r\n\r\n    #[test]\r\n    fn test_hash_path() {\r\n        let path1 = Path::new(\"/project1\");\r\n        let path2 = Path::new(\"/project2\");\r\n\r\n        let hash1 = CacheManager::hash_path(path1);\r\n        let hash2 = CacheManager::hash_path(path2);\r\n\r\n        assert_ne!(\r\n            hash1, hash2,\r\n            \"Different paths should produce different hashes\"\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    fn test_hash_config() {\r\n        let config1 = Config {\r\n            filter: Some(vec![\"rs\".to_string()]),\r\n            ignore: Some(vec![\"target\".to_string()]),\r\n            line_numbers: Some(true),\r\n            ..Default::default()\r\n        };\r\n\r\n        let config2 = Config {\r\n            filter: Some(vec![\"md\".to_string()]),\r\n            ignore: Some(vec![\"target\".to_string()]),\r\n            line_numbers: Some(true),\r\n            ..Default::default()\r\n        };\r\n\r\n        let hash1 = CacheManager::hash_config(\u0026config1);\r\n        let hash2 = CacheManager::hash_config(\u0026config2);\r\n\r\n        assert_ne!(\r\n            hash1, hash2,\r\n            \"Different configs should produce different hashes\"\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    fn test_cache_operations() {\r\n        let dir = tempdir().unwrap();\r\n        let project_path = dir.path().join(\"test_project\");\r\n        let _ = fs::create_dir(\u0026project_path);\r\n\r\n        let config = Config::default();\r\n        let cache_manager = CacheManager::new(\u0026project_path, \u0026config);\r\n\r\n        use crate::state::ProjectMetadata;\r\n\r\n        let state = ProjectState {\r\n            timestamp: \"2023-01-01T00:00:00Z\".to_string(),\r\n            config_hash: \"test_config_hash\".to_string(),\r\n            files: std::collections::BTreeMap::new(),\r\n            metadata: ProjectMetadata {\r\n                project_name: \"test\".to_string(),\r\n                file_count: 0,\r\n                filters: vec![],\r\n                ignores: vec![],\r\n                line_numbers: false,\r\n            },\r\n        };\r\n\r\n        // Write cache\r\n        assert!(cache_manager.write_cache(\u0026state).is_ok());\r\n\r\n        // Read cache\r\n        let cached_state = cache_manager.read_cache().unwrap();\r\n        assert!(cached_state.is_some());\r\n        assert_eq!(cached_state.unwrap().timestamp, state.timestamp);\r\n    }\r\n\r\n    #[test]\r\n    fn test_old_cache_migration() {\r\n        let dir = tempdir().unwrap();\r\n        let project_path = dir.path().join(\"test_project\");\r\n        let _ = fs::create_dir(\u0026project_path);\r\n\r\n        // Create cache directory with old cache files\r\n        let cache_dir = project_path.join(\".context-builder\").join(\"cache\");\r\n        let _ = fs::create_dir_all(\u0026cache_dir);\r\n\r\n        let old_files = [\r\n            \"last_canonical.md\",\r\n            \"last_output.md\",\r\n            \"current_output.md\",\r\n            \"output_20230101120000.md\",\r\n        ];\r\n\r\n        // Create old cache files\r\n        for file in \u0026old_files {\r\n            let old_path = cache_dir.join(file);\r\n            let _ = fs::write(\u0026old_path, \"old cache content\");\r\n            assert!(\r\n                old_path.exists(),\r\n                \"Old cache file should exist before migration\"\r\n            );\r\n        }\r\n\r\n        // Create cache manager (this should trigger migration)\r\n        let config = Config::default();\r\n        let _cache_manager = CacheManager::new(\u0026project_path, \u0026config);\r\n\r\n        // Verify old files are removed\r\n        for file in \u0026old_files {\r\n            let old_path = cache_dir.join(file);\r\n            assert!(\r\n                !old_path.exists(),\r\n                \"Old cache file {} should be removed after migration\",\r\n                file\r\n            );\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    fn test_cache_consistency_across_path_representations() {\r\n        let dir = tempdir().unwrap();\r\n        let project_path = dir.path().join(\"test_project\");\r\n        let _ = fs::create_dir(\u0026project_path);\r\n\r\n        let config = Config::default();\r\n\r\n        // Test different path representations that should resolve to the same cache\r\n        let mut paths_to_test = vec![\r\n            project_path.clone(),\r\n            project_path.canonicalize().unwrap_or(project_path.clone()),\r\n        ];\r\n\r\n        // If we can create a relative path, test that too\r\n        if let Ok(current_dir) = std::env::current_dir()\r\n            \u0026\u0026 let Ok(relative) = project_path.strip_prefix(\u0026current_dir)\r\n        {\r\n            paths_to_test.push(relative.to_path_buf());\r\n        }\r\n\r\n        let mut cache_paths = Vec::new();\r\n        for path in \u0026paths_to_test {\r\n            let cache_manager = CacheManager::new(path, \u0026config);\r\n            cache_paths.push(cache_manager.get_cache_path());\r\n        }\r\n\r\n        // All cache paths should be identical\r\n        for (i, path1) in cache_paths.iter().enumerate() {\r\n            for (j, path2) in cache_paths.iter().enumerate() {\r\n                if i != j {\r\n                    assert_eq!(\r\n                        path1, path2,\r\n                        \"Cache paths should be identical for different representations of the same project path\"\r\n                    );\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    fn test_normalize_path_format() {\r\n        // Test Windows UNC path normalization\r\n        if cfg!(windows) {\r\n            let unc_path = Path::new(\"\\\\\\\\?\\\\C:\\\\test\\\\path\");\r\n            let normalized = CacheManager::normalize_path_format(unc_path);\r\n            assert_eq!(normalized, PathBuf::from(\"C:\\\\test\\\\path\"));\r\n        }\r\n\r\n        // Test normal path (should remain unchanged)\r\n        let normal_path = Path::new(\"/normal/path\");\r\n        let normalized = CacheManager::normalize_path_format(normal_path);\r\n        assert_eq!(normalized, normal_path);\r\n    }\r\n\r\n    #[test]\r\n    fn test_cache_read_nonexistent_file() {\r\n        let dir = tempdir().unwrap();\r\n        let project_path = dir.path().join(\"nonexistent_project\");\r\n\r\n        let config = Config::default();\r\n        let cache_manager = CacheManager::new(\u0026project_path, \u0026config);\r\n\r\n        let result = cache_manager.read_cache().unwrap();\r\n        assert!(result.is_none());\r\n    }\r\n\r\n    #[test]\r\n    fn test_cache_read_corrupted_file() {\r\n        let dir = tempdir().unwrap();\r\n        let project_path = dir.path().join(\"test_project\");\r\n        let _ = fs::create_dir(\u0026project_path);\r\n\r\n        let config = Config::default();\r\n        let cache_manager = CacheManager::new(\u0026project_path, \u0026config);\r\n        let cache_path = cache_manager.get_cache_path();\r\n\r\n        // Create a corrupted cache file\r\n        let _ = fs::create_dir_all(cache_path.parent().unwrap());\r\n        let _ = fs::write(\u0026cache_path, \"invalid json content {{{\");\r\n\r\n        let result = cache_manager.read_cache();\r\n        assert!(result.is_err());\r\n    }\r\n\r\n    #[test]\r\n    fn test_cache_write_read_roundtrip() {\r\n        let dir = tempdir().unwrap();\r\n        let project_path = dir.path().join(\"test_project\");\r\n        let _ = fs::create_dir(\u0026project_path);\r\n\r\n        let config = Config {\r\n            filter: Some(vec![\"rs\".to_string(), \"toml\".to_string()]),\r\n            ignore: Some(vec![\"target\".to_string(), \".git\".to_string()]),\r\n            line_numbers: Some(true),\r\n            ..Default::default()\r\n        };\r\n\r\n        let cache_manager = CacheManager::new(\u0026project_path, \u0026config);\r\n\r\n        use crate::state::ProjectMetadata;\r\n        use std::collections::BTreeMap;\r\n\r\n        let mut files = BTreeMap::new();\r\n        files.insert(\r\n            PathBuf::from(\"test.rs\"),\r\n            crate::state::FileState {\r\n                content: \"fn main() {}\".to_string(),\r\n                size: 12,\r\n                modified: std::time::SystemTime::UNIX_EPOCH,\r\n                content_hash: \"test_hash\".to_string(),\r\n            },\r\n        );\r\n\r\n        let original_state = ProjectState {\r\n            timestamp: \"2023-01-01T12:00:00Z\".to_string(),\r\n            config_hash: \"test_config_hash\".to_string(),\r\n            files,\r\n            metadata: ProjectMetadata {\r\n                project_name: \"test_project\".to_string(),\r\n                file_count: 1,\r\n                filters: vec![\"rs\".to_string(), \"toml\".to_string()],\r\n                ignores: vec![\"target\".to_string(), \".git\".to_string()],\r\n                line_numbers: true,\r\n            },\r\n        };\r\n\r\n        // Write and read back\r\n        cache_manager.write_cache(\u0026original_state).unwrap();\r\n        let cached_state = cache_manager.read_cache().unwrap().unwrap();\r\n\r\n        assert_eq!(cached_state.timestamp, original_state.timestamp);\r\n        assert_eq!(cached_state.config_hash, original_state.config_hash);\r\n        assert_eq!(cached_state.files.len(), original_state.files.len());\r\n        assert_eq!(\r\n            cached_state.metadata.project_name,\r\n            original_state.metadata.project_name\r\n        );\r\n        assert_eq!(\r\n            cached_state.metadata.file_count,\r\n            original_state.metadata.file_count\r\n        );\r\n        assert_eq!(\r\n            cached_state.metadata.filters,\r\n            original_state.metadata.filters\r\n        );\r\n        assert_eq!(\r\n            cached_state.metadata.ignores,\r\n            original_state.metadata.ignores\r\n        );\r\n        assert_eq!(\r\n            cached_state.metadata.line_numbers,\r\n            original_state.metadata.line_numbers\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    fn test_different_configs_different_cache_files() {\r\n        let dir = tempdir().unwrap();\r\n        let project_path = dir.path().join(\"test_project\");\r\n        let _ = fs::create_dir(\u0026project_path);\r\n\r\n        let config1 = Config {\r\n            filter: Some(vec![\"rs\".to_string()]),\r\n            ..Default::default()\r\n        };\r\n\r\n        let config2 = Config {\r\n            filter: Some(vec![\"py\".to_string()]),\r\n            ..Default::default()\r\n        };\r\n\r\n        let cache_manager1 = CacheManager::new(\u0026project_path, \u0026config1);\r\n        let cache_manager2 = CacheManager::new(\u0026project_path, \u0026config2);\r\n\r\n        let cache_path1 = cache_manager1.get_cache_path();\r\n        let cache_path2 = cache_manager2.get_cache_path();\r\n\r\n        assert_ne!(\r\n            cache_path1, cache_path2,\r\n            \"Different configs should have different cache files\"\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    fn test_normalize_project_path_absolute() {\r\n        let temp_dir = tempdir().unwrap();\r\n        let project_path = temp_dir.path().join(\"test_project\");\r\n        let _ = fs::create_dir(\u0026project_path);\r\n\r\n        let normalized = CacheManager::normalize_project_path(\u0026project_path);\r\n        assert!(normalized.is_absolute());\r\n    }\r\n\r\n    #[test]\r\n    fn test_normalize_project_path_relative() {\r\n        let temp_dir = tempdir().unwrap();\r\n        let original_dir = std::env::current_dir().unwrap();\r\n\r\n        // Change to temp directory\r\n        std::env::set_current_dir(\u0026temp_dir).unwrap();\r\n\r\n        // Create a project directory\r\n        let project_name = \"relative_project\";\r\n        let _ = fs::create_dir(project_name);\r\n\r\n        let relative_path = Path::new(project_name);\r\n        let normalized = CacheManager::normalize_project_path(relative_path);\r\n\r\n        // Restore original directory\r\n        std::env::set_current_dir(original_dir).unwrap();\r\n\r\n        assert!(normalized.is_absolute());\r\n        assert!(normalized.to_string_lossy().contains(project_name));\r\n    }\r\n\r\n    #[test]\r\n    fn test_hash_config_same_values() {\r\n        let config1 = Config {\r\n            filter: Some(vec![\"rs\".to_string(), \"toml\".to_string()]),\r\n            ignore: Some(vec![\"target\".to_string()]),\r\n            line_numbers: Some(false),\r\n            ..Default::default()\r\n        };\r\n\r\n        let config2 = Config {\r\n            filter: Some(vec![\"rs\".to_string(), \"toml\".to_string()]),\r\n            ignore: Some(vec![\"target\".to_string()]),\r\n            line_numbers: Some(false),\r\n            ..Default::default()\r\n        };\r\n\r\n        let hash1 = CacheManager::hash_config(\u0026config1);\r\n        let hash2 = CacheManager::hash_config(\u0026config2);\r\n\r\n        assert_eq!(\r\n            hash1, hash2,\r\n            \"Identical configs should produce identical hashes\"\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    fn test_migrate_old_cache_preserves_new_files() {\r\n        let dir = tempdir().unwrap();\r\n        let project_path = dir.path().join(\"test_project\");\r\n        let _ = fs::create_dir(\u0026project_path);\r\n\r\n        let cache_dir = project_path.join(\".context-builder\").join(\"cache\");\r\n        let _ = fs::create_dir_all(\u0026cache_dir);\r\n\r\n        // Create both old and new cache files\r\n        let _ = fs::write(cache_dir.join(\"last_canonical.md\"), \"old content\");\r\n        let _ = fs::write(cache_dir.join(\"state_abc123_def456.json\"), \"new content\");\r\n\r\n        let config = Config::default();\r\n        let _cache_manager = CacheManager::new(\u0026project_path, \u0026config);\r\n\r\n        // Old file should be removed\r\n        assert!(!cache_dir.join(\"last_canonical.md\").exists());\r\n\r\n        // New file should be preserved\r\n        assert!(cache_dir.join(\"state_abc123_def456.json\").exists());\r\n    }\r\n}\r\n","traces":[{"line":28,"address":[],"length":0,"stats":{"Line":4971973988617027584}},{"line":30,"address":[],"length":0,"stats":{"Line":14915921965851082752}},{"line":32,"address":[],"length":0,"stats":{"Line":14915921965851082752}},{"line":33,"address":[],"length":0,"stats":{"Line":14915921965851082752}},{"line":36,"address":[],"length":0,"stats":{"Line":9943947977234055168}},{"line":39,"address":[],"length":0,"stats":{"Line":7638104968020361216}},{"line":40,"address":[],"length":0,"stats":{"Line":2666130979403333632}},{"line":50,"address":[],"length":0,"stats":{"Line":9943947977234055168}},{"line":52,"address":[],"length":0,"stats":{"Line":4971973988617027584}},{"line":56,"address":[],"length":0,"stats":{"Line":5116089176692883456}},{"line":58,"address":[],"length":0,"stats":{"Line":15348267530078650368}},{"line":59,"address":[],"length":0,"stats":{"Line":5476377146882523136}},{"line":61,"address":[],"length":0,"stats":{"Line":2377900603251621888}},{"line":62,"address":[],"length":0,"stats":{"Line":2377900603251621888}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":10160120759347838976}},{"line":71,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":76,"address":[],"length":0,"stats":{"Line":5116089176692883456}},{"line":77,"address":[],"length":0,"stats":{"Line":10232178353385766912}},{"line":78,"address":[],"length":0,"stats":{"Line":15348267530078650368}},{"line":79,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":83,"address":[],"length":0,"stats":{"Line":5188146770730811392}},{"line":84,"address":[],"length":0,"stats":{"Line":15564440312192434176}},{"line":87,"address":[],"length":0,"stats":{"Line":10376293541461622784}},{"line":88,"address":[],"length":0,"stats":{"Line":10232178353385766912}},{"line":90,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":95,"address":[],"length":0,"stats":{"Line":5260204364768739328}},{"line":96,"address":[],"length":0,"stats":{"Line":10520408729537478656}},{"line":98,"address":[],"length":0,"stats":{"Line":15780613094306217984}},{"line":99,"address":[],"length":0,"stats":{"Line":15780613094306217984}},{"line":100,"address":[],"length":0,"stats":{"Line":15780613094306217984}},{"line":101,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":105,"address":[],"length":0,"stats":{"Line":9295429630892703744}},{"line":106,"address":[],"length":0,"stats":{"Line":9439544818968559616}},{"line":107,"address":[],"length":0,"stats":{"Line":9295429630892703744}},{"line":108,"address":[],"length":0,"stats":{"Line":9295429630892703744}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":4971973988617027584}},{"line":119,"address":[],"length":0,"stats":{"Line":9943947977234055168}},{"line":121,"address":[],"length":0,"stats":{"Line":16357073846609641472}},{"line":123,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":124,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":125,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":130,"address":[],"length":0,"stats":{"Line":9943947977234055168}},{"line":131,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":134,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":135,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":136,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":143,"address":[],"length":0,"stats":{"Line":4539628424389459968}},{"line":144,"address":[],"length":0,"stats":{"Line":13618885273168379904}},{"line":146,"address":[],"length":0,"stats":{"Line":4539628424389459968}},{"line":147,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":150,"address":[],"length":0,"stats":{"Line":6269010681299730432}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":2089670227099910144}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":2089670227099910144}},{"line":161,"address":[],"length":0,"stats":{"Line":4179340454199820288}},{"line":166,"address":[],"length":0,"stats":{"Line":4395513236313604096}},{"line":167,"address":[],"length":0,"stats":{"Line":13186539708940812288}},{"line":169,"address":[],"length":0,"stats":{"Line":13186539708940812288}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":8791026472627208192}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":4395513236313604096}},{"line":179,"address":[],"length":0,"stats":{"Line":4395513236313604096}},{"line":181,"address":[],"length":0,"stats":{"Line":4395513236313604096}}],"covered":61,"coverable":68},{"path":["D:","\\","GitHub","context-builder","src","cli.rs"],"content":"use clap::Parser;\n\n/// CLI tool to aggregate directory contents into a single Markdown file optimized for LLM consumption\n#[derive(Parser, Debug, Clone)]\n#[clap(author, version, about)]\npub struct Args {\n    /// Directory path to process\n    #[clap(short = 'd', long, default_value = \".\")]\n    pub input: String,\n\n    /// Output file path\n    #[clap(short, long, default_value = \"output.md\")]\n    pub output: String,\n\n    /// File extensions to include (e.g., --filter rs,toml)\n    #[clap(short = 'f', long, value_delimiter = ',')]\n    pub filter: Vec\u003cString\u003e,\n\n    /// Folder or file names to ignore (e.g., --ignore target --ignore lock)\n    #[clap(short = 'i', long)]\n    pub ignore: Vec\u003cString\u003e,\n\n    /// Preview mode: only print the file tree to the console, don't generate the documentation file\n    #[clap(long)]\n    pub preview: bool,\n\n    /// Token count mode: estimate the total token count of the final document\n    #[clap(long)]\n    pub token_count: bool,\n\n    /// Add line numbers to code blocks in the output\n    #[clap(long)]\n    pub line_numbers: bool,\n\n    /// Automatically answer yes to all prompts\n    #[clap(short = 'y', long)]\n    pub yes: bool,\n\n    /// Output only diffs (omit full file contents; requires auto-diff \u0026 timestamped output)\n    #[clap(long, default_value_t = false)]\n    pub diff_only: bool,\n\n    /// Clear the cached project state and exit\n    #[clap(long)]\n    pub clear_cache: bool,\n}\n\n#[cfg(test)]\nmod tests {\n    use super::Args;\n    use clap::Parser;\n\n    #[test]\n    fn parses_with_no_args() {\n        let res = Args::try_parse_from([\"context-builder\"]);\n        assert!(res.is_ok(), \"Expected success when no args are provided\");\n    }\n\n    #[test]\n    fn parses_all_flags_and_options() {\n        let args = Args::try_parse_from([\n            \"context-builder\",\n            \"--input\",\n            \"some/dir\",\n            \"--output\",\n            \"ctx.md\",\n            \"--filter\",\n            \"rs\",\n            \"--filter\",\n            \"toml\",\n            \"--ignore\",\n            \"target\",\n            \"--ignore\",\n            \"node_modules\",\n            \"--preview\",\n            \"--token-count\",\n            \"--line-numbers\",\n            \"--diff-only\",\n            \"--clear-cache\",\n        ])\n        .expect(\"should parse\");\n\n        assert_eq!(args.input, \"some/dir\");\n        assert_eq!(args.output, \"ctx.md\");\n        assert_eq!(args.filter, vec![\"rs\".to_string(), \"toml\".to_string()]);\n        assert_eq!(\n            args.ignore,\n            vec![\"target\".to_string(), \"node_modules\".to_string()]\n        );\n        assert!(args.preview);\n        assert!(args.token_count);\n        assert!(args.line_numbers);\n        assert!(args.diff_only);\n        assert!(args.clear_cache);\n    }\n\n    #[test]\n    fn short_flags_parse_correctly() {\n        let args = Args::try_parse_from([\n            \"context-builder\",\n            \"-d\",\n            \".\",\n            \"-o\",\n            \"out.md\",\n            \"-f\",\n            \"md\",\n            \"-f\",\n            \"rs\",\n            \"-i\",\n            \"target\",\n            \"-i\",\n            \".git\",\n        ])\n        .expect(\"should parse\");\n\n        assert_eq!(args.input, \".\");\n        assert_eq!(args.output, \"out.md\");\n        assert_eq!(args.filter, vec![\"md\".to_string(), \"rs\".to_string()]);\n        assert_eq!(args.ignore, vec![\"target\".to_string(), \".git\".to_string()]);\n        assert!(!args.preview);\n        assert!(!args.line_numbers);\n        assert!(!args.clear_cache);\n    }\n\n    #[test]\n    fn defaults_for_options_when_not_provided() {\n        let args = Args::try_parse_from([\"context-builder\", \"-d\", \"proj\"]).expect(\"should parse\");\n\n        assert_eq!(args.input, \"proj\");\n        assert_eq!(args.output, \"output.md\");\n        assert!(args.filter.is_empty());\n        assert!(args.ignore.is_empty());\n        assert!(!args.preview);\n        assert!(!args.line_numbers);\n        assert!(!args.diff_only);\n        assert!(!args.clear_cache);\n    }\n\n    #[test]\n    fn parses_diff_only_flag() {\n        let args = Args::try_parse_from([\"context-builder\", \"--diff-only\"])\n            .expect(\"should parse diff-only flag\");\n        assert!(args.diff_only);\n        assert!(!args.clear_cache);\n    }\n\n    #[test]\n    fn parses_clear_cache_flag() {\n        let args = Args::try_parse_from([\"context-builder\", \"--clear-cache\"])\n            .expect(\"should parse clear-cache flag\");\n        assert!(args.clear_cache);\n        assert!(!args.diff_only);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","GitHub","context-builder","src","config.rs"],"content":"use serde::Deserialize;\nuse std::fs;\nuse std::path::Path;\n\n/// Global configuration loaded from `context-builder.toml`.\n///\n/// Any field left as `None` means \"use the CLI default / do not override\".\n/// Command-line arguments always take precedence over values provided here.\n///\n/// Example `context-builder.toml`:\n/// ```toml\n/// output = \"context.md\"\n/// output_folder = \"docs\"\n/// timestamped_output = true\n/// auto_diff = true\n/// diff_only = true         # Emit only change summary + modified file diffs (no full file bodies)\n/// filter = [\"rs\", \"toml\"]\n/// ignore = [\"target\", \".git\"]\n/// line_numbers = false\n/// diff_context_lines = 5\n/// ```\n///\n#[derive(Deserialize, Debug, Default, Clone)]\npub struct Config {\n    /// Output file name (or base name when `timestamped_output = true`)\n    pub output: Option\u003cString\u003e,\n\n    /// File extensions to include (no leading dot, e.g. `rs`, `toml`)\n    pub filter: Option\u003cVec\u003cString\u003e\u003e,\n\n    /// File / directory names to ignore (exact name matches)\n    pub ignore: Option\u003cVec\u003cString\u003e\u003e,\n\n    /// Add line numbers to code blocks\n    pub line_numbers: Option\u003cbool\u003e,\n\n    /// Preview only the file tree (no file output)\n    pub preview: Option\u003cbool\u003e,\n\n    /// Token counting mode\n    pub token_count: Option\u003cbool\u003e,\n\n    /// Optional folder to place the generated output file(s) in\n    pub output_folder: Option\u003cString\u003e,\n\n    /// If true, append a UTC timestamp to the output file name (before extension)\n    pub timestamped_output: Option\u003cbool\u003e,\n\n    /// Assume \"yes\" for overwrite / processing confirmations\n    pub yes: Option\u003cbool\u003e,\n\n    /// Enable automatic diff generation (requires `timestamped_output = true`)\n    pub auto_diff: Option\u003cbool\u003e,\n\n    /// Override number of unified diff context lines (falls back to env or default = 3)\n    pub diff_context_lines: Option\u003cusize\u003e,\n\n    /// When true, emit ONLY:\n    /// - Header + file tree\n    /// - Change Summary\n    /// - Per-file diffs for modified files\n    ///\n    /// Excludes full file contents section entirely. Added files appear only in the\n    /// change summary (and are marked Added) but their full content is omitted.\n    pub diff_only: Option\u003cbool\u003e,\n\n    /// Encoding handling strategy for non-UTF-8 files.\n    /// - \"detect\": Attempt to detect and transcode to UTF-8 (default)\n    /// - \"strict\": Only include valid UTF-8 files, skip others\n    /// - \"skip\": Skip all non-UTF-8 files without transcoding attempts\n    pub encoding_strategy: Option\u003cString\u003e,\n}\n\n/// Load configuration from `context-builder.toml` in the current working directory.\n/// Returns `None` if the file does not exist or cannot be parsed.\npub fn load_config() -\u003e Option\u003cConfig\u003e {\n    let config_path = Path::new(\"context-builder.toml\");\n    if config_path.exists() {\n        let content = fs::read_to_string(config_path).ok()?;\n        toml::from_str(\u0026content).ok()\n    } else {\n        None\n    }\n}\n\n/// Load configuration from `context-builder.toml` in the specified project root directory.\n/// Returns `None` if the file does not exist or cannot be parsed.\npub fn load_config_from_path(project_root: \u0026Path) -\u003e Option\u003cConfig\u003e {\n    let config_path = project_root.join(\"context-builder.toml\");\n    if config_path.exists() {\n        let content = fs::read_to_string(config_path).ok()?;\n        toml::from_str(\u0026content).ok()\n    } else {\n        None\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::fs;\n    use tempfile::tempdir;\n\n    #[test]\n    fn load_config_nonexistent_file() {\n        // Test loading config when file doesn't exist by temporarily changing directory\n        let temp_dir = tempdir().unwrap();\n        let original_dir = std::env::current_dir().unwrap();\n\n        // Change to temp directory where no config file exists\n        std::env::set_current_dir(\u0026temp_dir).unwrap();\n\n        let result = load_config();\n\n        // Restore original directory\n        std::env::set_current_dir(original_dir).unwrap();\n\n        assert!(result.is_none());\n    }\n\n    #[test]\n    fn load_config_from_path_nonexistent_file() {\n        let dir = tempdir().unwrap();\n        let result = load_config_from_path(dir.path());\n        assert!(result.is_none());\n    }\n\n    #[test]\n    fn load_config_from_path_valid_config() {\n        let dir = tempdir().unwrap();\n        let config_path = dir.path().join(\"context-builder.toml\");\n\n        let config_content = r#\"\noutput = \"test-output.md\"\nfilter = [\"rs\", \"toml\"]\nignore = [\"target\", \".git\"]\nline_numbers = true\npreview = false\ntoken_count = true\ntimestamped_output = true\nyes = false\nauto_diff = true\ndiff_context_lines = 5\ndiff_only = false\nencoding_strategy = \"detect\"\n\"#;\n\n        fs::write(\u0026config_path, config_content).unwrap();\n\n        let config = load_config_from_path(dir.path()).unwrap();\n        assert_eq!(config.output.unwrap(), \"test-output.md\");\n        assert_eq!(config.filter.unwrap(), vec![\"rs\", \"toml\"]);\n        assert_eq!(config.ignore.unwrap(), vec![\"target\", \".git\"]);\n        assert!(config.line_numbers.unwrap());\n        assert!(!config.preview.unwrap());\n        assert!(config.token_count.unwrap());\n        assert!(config.timestamped_output.unwrap());\n        assert!(!config.yes.unwrap());\n        assert!(config.auto_diff.unwrap());\n        assert_eq!(config.diff_context_lines.unwrap(), 5);\n        assert!(!config.diff_only.unwrap());\n        assert_eq!(config.encoding_strategy.unwrap(), \"detect\");\n    }\n\n    #[test]\n    fn load_config_from_path_partial_config() {\n        let dir = tempdir().unwrap();\n        let config_path = dir.path().join(\"context-builder.toml\");\n\n        let config_content = r#\"\noutput = \"minimal.md\"\nfilter = [\"py\"]\n\"#;\n\n        fs::write(\u0026config_path, config_content).unwrap();\n\n        let config = load_config_from_path(dir.path()).unwrap();\n        assert_eq!(config.output.unwrap(), \"minimal.md\");\n        assert_eq!(config.filter.unwrap(), vec![\"py\"]);\n        assert!(config.ignore.is_none());\n        assert!(config.line_numbers.is_none());\n        assert!(config.auto_diff.is_none());\n    }\n\n    #[test]\n    fn load_config_from_path_invalid_toml() {\n        let dir = tempdir().unwrap();\n        let config_path = dir.path().join(\"context-builder.toml\");\n\n        // Invalid TOML content\n        let config_content = r#\"\noutput = \"test.md\"\ninvalid_toml [\n\"#;\n\n        fs::write(\u0026config_path, config_content).unwrap();\n\n        let config = load_config_from_path(dir.path());\n        assert!(config.is_none());\n    }\n\n    #[test]\n    fn load_config_from_path_empty_config() {\n        let dir = tempdir().unwrap();\n        let config_path = dir.path().join(\"context-builder.toml\");\n\n        fs::write(\u0026config_path, \"\").unwrap();\n\n        let config = load_config_from_path(dir.path()).unwrap();\n        assert!(config.output.is_none());\n        assert!(config.filter.is_none());\n        assert!(config.ignore.is_none());\n    }\n\n    #[test]\n    fn config_default_implementation() {\n        let config = Config::default();\n        assert!(config.output.is_none());\n        assert!(config.filter.is_none());\n        assert!(config.ignore.is_none());\n        assert!(config.line_numbers.is_none());\n        assert!(config.preview.is_none());\n        assert!(config.token_count.is_none());\n        assert!(config.output_folder.is_none());\n        assert!(config.timestamped_output.is_none());\n        assert!(config.yes.is_none());\n        assert!(config.auto_diff.is_none());\n        assert!(config.diff_context_lines.is_none());\n        assert!(config.diff_only.is_none());\n        assert!(config.encoding_strategy.is_none());\n    }\n}\n","traces":[{"line":76,"address":[],"length":0,"stats":{"Line":1945555039024054272}},{"line":77,"address":[],"length":0,"stats":{"Line":5836665117072162816}},{"line":78,"address":[],"length":0,"stats":{"Line":3891110078048108544}},{"line":79,"address":[],"length":0,"stats":{"Line":7493989779944505344}},{"line":82,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":88,"address":[],"length":0,"stats":{"Line":2233785415175766016}},{"line":89,"address":[],"length":0,"stats":{"Line":6701356245527298048}},{"line":90,"address":[],"length":0,"stats":{"Line":2233785415175766016}},{"line":91,"address":[],"length":0,"stats":{"Line":8646911284551352320}},{"line":94,"address":[],"length":0,"stats":{"Line":72057594037927936}}],"covered":10,"coverable":10},{"path":["D:","\\","GitHub","context-builder","src","config_resolver.rs"],"content":"//! Configuration resolution module for context-builder.\r\n//!\r\n//! This module provides centralized logic for merging CLI arguments with configuration\r\n//! file values, implementing proper precedence rules and handling complex scenarios\r\n//! like timestamping and output folder resolution.\r\n\r\nuse chrono::Utc;\r\nuse std::path::{Path, PathBuf};\r\n\r\nuse crate::cli::Args;\r\nuse crate::config::Config;\r\n\r\n/// Resolved configuration combining CLI arguments and config file values\r\n#[derive(Debug, Clone)]\r\npub struct ResolvedConfig {\r\n    pub input: String,\r\n    pub output: String,\r\n    pub filter: Vec\u003cString\u003e,\r\n    pub ignore: Vec\u003cString\u003e,\r\n    pub line_numbers: bool,\r\n    pub preview: bool,\r\n    pub token_count: bool,\r\n    pub yes: bool,\r\n    pub diff_only: bool,\r\n    pub clear_cache: bool,\r\n    pub auto_diff: bool,\r\n    pub diff_context_lines: usize,\r\n}\r\n\r\n/// Result of configuration resolution including the final config and any warnings\r\n#[derive(Debug)]\r\npub struct ConfigResolution {\r\n    pub config: ResolvedConfig,\r\n    pub warnings: Vec\u003cString\u003e,\r\n}\r\n\r\n/// Resolves final configuration by merging CLI arguments with config file values.\r\n///\r\n/// Precedence rules (highest to lowest):\r\n/// 1. Explicit CLI arguments (non-default values)\r\n/// 2. Configuration file values\r\n/// 3. CLI default values\r\n///\r\n/// Special handling:\r\n/// - `output` field supports timestamping and output folder resolution\r\n/// - Boolean flags respect explicit CLI usage vs defaults\r\n/// - Arrays (filter, ignore) use CLI if non-empty, otherwise config file\r\npub fn resolve_final_config(mut args: Args, config: Option\u003cConfig\u003e) -\u003e ConfigResolution {\r\n    let mut warnings = Vec::new();\r\n\r\n    // Start with CLI defaults, then apply config file, then explicit CLI overrides\r\n    let final_config = if let Some(config) = config {\r\n        apply_config_to_args(\u0026mut args, \u0026config, \u0026mut warnings);\r\n        resolve_output_path(\u0026mut args, \u0026config, \u0026mut warnings);\r\n        config\r\n    } else {\r\n        Config::default()\r\n    };\r\n\r\n    let resolved = ResolvedConfig {\r\n        input: args.input,\r\n        output: args.output,\r\n        filter: args.filter,\r\n        ignore: args.ignore,\r\n        line_numbers: args.line_numbers,\r\n        preview: args.preview,\r\n        token_count: args.token_count,\r\n        yes: args.yes,\r\n        diff_only: args.diff_only,\r\n        clear_cache: args.clear_cache,\r\n        auto_diff: final_config.auto_diff.unwrap_or(false),\r\n        diff_context_lines: final_config.diff_context_lines.unwrap_or(3),\r\n    };\r\n\r\n    ConfigResolution {\r\n        config: resolved,\r\n        warnings,\r\n    }\r\n}\r\n\r\n/// Apply configuration file values to CLI arguments based on precedence rules\r\nfn apply_config_to_args(args: \u0026mut Args, config: \u0026Config, warnings: \u0026mut Vec\u003cString\u003e) {\r\n    // Output: only apply config if CLI is using default value\r\n    if args.output == \"output.md\"\r\n        \u0026\u0026 let Some(ref output) = config.output\r\n    {\r\n        args.output = output.clone();\r\n    }\r\n\r\n    // Filter: CLI takes precedence if non-empty\r\n    if args.filter.is_empty()\r\n        \u0026\u0026 let Some(ref filter) = config.filter\r\n    {\r\n        args.filter = filter.clone();\r\n    }\r\n\r\n    // Ignore: CLI takes precedence if non-empty\r\n    if args.ignore.is_empty()\r\n        \u0026\u0026 let Some(ref ignore) = config.ignore\r\n    {\r\n        args.ignore = ignore.clone();\r\n    }\r\n\r\n    // Boolean flags: config applies only if CLI is using default (false)\r\n    // Note: We can't distinguish between explicit --no-flag and default false,\r\n    // so config file can only enable features, not disable them\r\n    if !args.line_numbers\r\n        \u0026\u0026 let Some(line_numbers) = config.line_numbers\r\n    {\r\n        args.line_numbers = line_numbers;\r\n    }\r\n\r\n    if !args.preview\r\n        \u0026\u0026 let Some(preview) = config.preview\r\n    {\r\n        args.preview = preview;\r\n    }\r\n\r\n    if !args.token_count\r\n        \u0026\u0026 let Some(token_count) = config.token_count\r\n    {\r\n        args.token_count = token_count;\r\n    }\r\n\r\n    if !args.yes\r\n        \u0026\u0026 let Some(yes) = config.yes\r\n    {\r\n        args.yes = yes;\r\n    }\r\n\r\n    // diff_only: config can enable it, but CLI flag always takes precedence\r\n    if !args.diff_only\r\n        \u0026\u0026 let Some(true) = config.diff_only\r\n    {\r\n        args.diff_only = true;\r\n    }\r\n\r\n    // Validate auto_diff configuration\r\n    if let Some(true) = config.auto_diff\r\n        \u0026\u0026 config.timestamped_output != Some(true)\r\n    {\r\n        warnings.push(\r\n            \"auto_diff is enabled but timestamped_output is not enabled. \\\r\n            Auto-diff requires timestamped_output = true to function properly.\"\r\n                .to_string(),\r\n        );\r\n    }\r\n}\r\n\r\n/// Resolve output path including timestamping and output folder logic\r\nfn resolve_output_path(args: \u0026mut Args, config: \u0026Config, warnings: \u0026mut Vec\u003cString\u003e) {\r\n    let mut output_folder_path: Option\u003cPathBuf\u003e = None;\r\n\r\n    // Apply output folder first\r\n    if let Some(ref output_folder) = config.output_folder {\r\n        let mut path = PathBuf::from(output_folder);\r\n        path.push(\u0026args.output);\r\n        args.output = path.to_string_lossy().to_string();\r\n        output_folder_path = Some(PathBuf::from(output_folder));\r\n    }\r\n\r\n    // Apply timestamping if enabled\r\n    if let Some(true) = config.timestamped_output {\r\n        let timestamp = Utc::now().format(\"%Y%m%d%H%M%S\").to_string();\r\n        let path = Path::new(\u0026args.output);\r\n\r\n        let stem = path\r\n            .file_stem()\r\n            .and_then(|s| s.to_str())\r\n            .unwrap_or(\"output\");\r\n\r\n        let extension = path.extension().and_then(|s| s.to_str()).unwrap_or(\"md\");\r\n\r\n        let new_filename = format!(\"{}_{}.{}\", stem, timestamp, extension);\r\n\r\n        if let Some(output_folder) = output_folder_path {\r\n            args.output = output_folder\r\n                .join(new_filename)\r\n                .to_string_lossy()\r\n                .to_string();\r\n        } else {\r\n            let new_path = path.with_file_name(new_filename);\r\n            args.output = new_path.to_string_lossy().to_string();\r\n        }\r\n    }\r\n\r\n    // Validate output folder exists if specified\r\n    if let Some(ref output_folder) = config.output_folder {\r\n        let folder_path = Path::new(output_folder);\r\n        if !folder_path.exists() {\r\n            warnings.push(format!(\r\n                \"Output folder '{}' does not exist. It will be created if possible.\",\r\n                output_folder\r\n            ));\r\n        }\r\n    }\r\n}\r\n\r\n/// Check if CLI arguments have been explicitly set vs using defaults.\r\n/// This is a best-effort detection since clap doesn't provide this information directly.\r\n#[allow(dead_code)]\r\nfn detect_explicit_args() -\u003e ExplicitArgs {\r\n    let args: Vec\u003cString\u003e = std::env::args().collect();\r\n\r\n    ExplicitArgs {\r\n        output: args.iter().any(|arg| arg == \"-o\" || arg == \"--output\"),\r\n        filter: args.iter().any(|arg| arg == \"-f\" || arg == \"--filter\"),\r\n        ignore: args.iter().any(|arg| arg == \"-i\" || arg == \"--ignore\"),\r\n        line_numbers: args.iter().any(|arg| arg == \"--line-numbers\"),\r\n        preview: args.iter().any(|arg| arg == \"--preview\"),\r\n        token_count: args.iter().any(|arg| arg == \"--token-count\"),\r\n        yes: args.iter().any(|arg| arg == \"-y\" || arg == \"--yes\"),\r\n        diff_only: args.iter().any(|arg| arg == \"--diff-only\"),\r\n    }\r\n}\r\n\r\n/// Tracks which CLI arguments were explicitly provided vs using defaults\r\n#[allow(dead_code)]\r\nstruct ExplicitArgs {\r\n    output: bool,\r\n    filter: bool,\r\n    ignore: bool,\r\n    line_numbers: bool,\r\n    preview: bool,\r\n    token_count: bool,\r\n    yes: bool,\r\n    diff_only: bool,\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn test_config_precedence_cli_over_config() {\r\n        let args = Args {\r\n            input: \"src\".to_string(),\r\n            output: \"custom.md\".to_string(), // Explicit CLI value\r\n            filter: vec![\"rs\".to_string()],  // Explicit CLI value\r\n            ignore: vec![],\r\n            line_numbers: true, // Explicit CLI value\r\n            preview: false,\r\n            token_count: false,\r\n            yes: false,\r\n            diff_only: false,\r\n            clear_cache: false,\r\n        };\r\n\r\n        let config = Config {\r\n            output: Some(\"config.md\".to_string()),  // Should be ignored\r\n            filter: Some(vec![\"toml\".to_string()]), // Should be ignored\r\n            line_numbers: Some(false),              // Should be ignored\r\n            preview: Some(true),                    // Should apply\r\n            ..Default::default()\r\n        };\r\n\r\n        let resolution = resolve_final_config(args.clone(), Some(config));\r\n\r\n        assert_eq!(resolution.config.output, \"custom.md\"); // CLI wins\r\n        assert_eq!(resolution.config.filter, vec![\"rs\"]); // CLI wins\r\n        assert!(resolution.config.line_numbers); // CLI wins\r\n        assert!(resolution.config.preview); // Config applies\r\n    }\r\n\r\n    #[test]\r\n    fn test_config_applies_when_cli_uses_defaults() {\r\n        let args = Args {\r\n            input: \"src\".to_string(),\r\n            output: \"output.md\".to_string(), // Default value\r\n            filter: vec![],                  // Default value\r\n            ignore: vec![],                  // Default value\r\n            line_numbers: false,             // Default value\r\n            preview: false,                  // Default value\r\n            token_count: false,              // Default value\r\n            yes: false,                      // Default value\r\n            diff_only: false,                // Default value\r\n            clear_cache: false,\r\n        };\r\n\r\n        let config = Config {\r\n            output: Some(\"from_config.md\".to_string()),\r\n            filter: Some(vec![\"rs\".to_string(), \"toml\".to_string()]),\r\n            ignore: Some(vec![\"target\".to_string()]),\r\n            line_numbers: Some(true),\r\n            preview: Some(true),\r\n            token_count: Some(true),\r\n            yes: Some(true),\r\n            diff_only: Some(true),\r\n            ..Default::default()\r\n        };\r\n\r\n        let resolution = resolve_final_config(args, Some(config));\r\n\r\n        assert_eq!(resolution.config.output, \"from_config.md\");\r\n        assert_eq!(\r\n            resolution.config.filter,\r\n            vec![\"rs\".to_string(), \"toml\".to_string()]\r\n        );\r\n        assert_eq!(resolution.config.ignore, vec![\"target\".to_string()]);\r\n        assert!(resolution.config.line_numbers);\r\n        assert!(resolution.config.preview);\r\n        assert!(resolution.config.token_count);\r\n        assert!(resolution.config.yes);\r\n        assert!(resolution.config.diff_only);\r\n    }\r\n\r\n    #[test]\r\n    fn test_timestamped_output_resolution() {\r\n        let args = Args {\r\n            input: \"src\".to_string(),\r\n            output: \"test.md\".to_string(),\r\n            filter: vec![],\r\n            ignore: vec![],\r\n            line_numbers: false,\r\n            preview: false,\r\n            token_count: false,\r\n            yes: false,\r\n            diff_only: false,\r\n            clear_cache: false,\r\n        };\r\n\r\n        let config = Config {\r\n            timestamped_output: Some(true),\r\n            ..Default::default()\r\n        };\r\n\r\n        let resolution = resolve_final_config(args, Some(config));\r\n\r\n        // Output should have timestamp format: test_YYYYMMDDHHMMSS.md\r\n        assert!(resolution.config.output.starts_with(\"test_\"));\r\n        assert!(resolution.config.output.ends_with(\".md\"));\r\n        assert!(resolution.config.output.len() \u003e \"test_.md\".len());\r\n    }\r\n\r\n    #[test]\r\n    fn test_output_folder_resolution() {\r\n        let args = Args {\r\n            input: \"src\".to_string(),\r\n            output: \"test.md\".to_string(),\r\n            filter: vec![],\r\n            ignore: vec![],\r\n            line_numbers: false,\r\n            preview: false,\r\n            token_count: false,\r\n            yes: false,\r\n            diff_only: false,\r\n            clear_cache: false,\r\n        };\r\n\r\n        let config = Config {\r\n            output_folder: Some(\"docs\".to_string()),\r\n            ..Default::default()\r\n        };\r\n\r\n        let resolution = resolve_final_config(args, Some(config));\r\n\r\n        assert!(resolution.config.output.contains(\"docs\"));\r\n        assert!(resolution.config.output.ends_with(\"test.md\"));\r\n    }\r\n\r\n    #[test]\r\n    fn test_output_folder_with_timestamping() {\r\n        let args = Args {\r\n            input: \"src\".to_string(),\r\n            output: \"test.md\".to_string(),\r\n            filter: vec![],\r\n            ignore: vec![],\r\n            line_numbers: false,\r\n            preview: false,\r\n            token_count: false,\r\n            yes: false,\r\n            diff_only: false,\r\n            clear_cache: false,\r\n        };\r\n\r\n        let config = Config {\r\n            output_folder: Some(\"docs\".to_string()),\r\n            timestamped_output: Some(true),\r\n            ..Default::default()\r\n        };\r\n\r\n        let resolution = resolve_final_config(args, Some(config));\r\n\r\n        assert!(resolution.config.output.contains(\"docs\"));\r\n        assert!(resolution.config.output.contains(\"test_\"));\r\n        assert!(resolution.config.output.ends_with(\".md\"));\r\n    }\r\n\r\n    #[test]\r\n    fn test_auto_diff_without_timestamping_warning() {\r\n        let args = Args {\r\n            input: \"src\".to_string(),\r\n            output: \"test.md\".to_string(),\r\n            filter: vec![],\r\n            ignore: vec![],\r\n            line_numbers: false,\r\n            preview: false,\r\n            token_count: false,\r\n            yes: false,\r\n            diff_only: false,\r\n            clear_cache: false,\r\n        };\r\n\r\n        let config = Config {\r\n            auto_diff: Some(true),\r\n            timestamped_output: Some(false), // This should generate a warning\r\n            ..Default::default()\r\n        };\r\n\r\n        let resolution = resolve_final_config(args, Some(config));\r\n\r\n        assert!(!resolution.warnings.is_empty());\r\n        assert!(resolution.warnings[0].contains(\"auto_diff\"));\r\n        assert!(resolution.warnings[0].contains(\"timestamped_output\"));\r\n    }\r\n\r\n    #[test]\r\n    fn test_no_config_uses_cli_defaults() {\r\n        let args = Args {\r\n            input: \"src\".to_string(),\r\n            output: \"output.md\".to_string(),\r\n            filter: vec![],\r\n            ignore: vec![],\r\n            line_numbers: false,\r\n            preview: false,\r\n            token_count: false,\r\n            yes: false,\r\n            diff_only: false,\r\n            clear_cache: false,\r\n        };\r\n\r\n        let resolution = resolve_final_config(args.clone(), None);\r\n\r\n        assert_eq!(resolution.config.input, args.input);\r\n        assert_eq!(resolution.config.output, args.output);\r\n        assert_eq!(resolution.config.filter, args.filter);\r\n        assert_eq!(resolution.config.ignore, args.ignore);\r\n        assert_eq!(resolution.config.line_numbers, args.line_numbers);\r\n        assert_eq!(resolution.config.preview, args.preview);\r\n        assert_eq!(resolution.config.token_count, args.token_count);\r\n        assert_eq!(resolution.config.yes, args.yes);\r\n        assert_eq!(resolution.config.diff_only, args.diff_only);\r\n        assert!(!resolution.config.auto_diff);\r\n        assert_eq!(resolution.config.diff_context_lines, 3);\r\n        assert!(resolution.warnings.is_empty());\r\n    }\r\n}\r\n","traces":[{"line":48,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":49,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":52,"address":[],"length":0,"stats":{"Line":3602879701896396800}},{"line":57,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":61,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":62,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":63,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":64,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":65,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":66,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":67,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":68,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":69,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":70,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":71,"address":[],"length":0,"stats":{"Line":3674937295934324736}},{"line":72,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":82,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":84,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":85,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":87,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":91,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":92,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":94,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":98,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":99,"address":[],"length":0,"stats":{"Line":1369094286720630784}},{"line":101,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":107,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":108,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":113,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":114,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":119,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":120,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":125,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":126,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":132,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":133,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":135,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":139,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":140,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":142,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":143,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":144,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":145,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":151,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":152,"address":[],"length":0,"stats":{"Line":3458764513820540928}},{"line":155,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":163,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":164,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":165,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":167,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":169,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":172,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":174,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":176,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":182,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":183,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":188,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}}],"covered":57,"coverable":71},{"path":["D:","\\","GitHub","context-builder","src","diff.rs"],"content":"use similar::{ChangeTag, TextDiff};\nuse std::collections::HashMap;\n\n/// Line based diff utilities.\n///\n/// This module previously exposed `generate_diff` which produced a single\n/// \"## File Differences\" section for an entire markdown document. That\n/// approach made it easy for volatile sections (timestamps, file tree\n/// structure, etc.) to create noisy diffs. To address this the new\n/// per‑file API lets the caller diff only the normalized *file content*\n/// blocks that appear under each `### File: `path`` heading in the\n/// canonical output, completely ignoring the global header or the file\n/// tree portion. Each file receives an isolated unified style diff.\n///\n/// High level additions:\n/// * `PerFileStatus` – classification of the change.\n/// * `PerFileDiff` – structured diff result for a single file.\n/// * `diff_file_contents` – core engine producing diffs per file without any\n///   global \"## File Differences\" header.\n/// * `render_per_file_diffs` – helper to render the per file diffs into\n///   markdown (still omits a global header so the caller can choose).\n///\n/// Backwards compatibility: the existing `generate_diff` function (full\n/// document diff) is retained for now. New code should prefer the\n/// per‑file functions.\n/// Determine number of context lines either from explicit argument or env.\nfn resolve_context_lines(explicit: Option\u003cusize\u003e) -\u003e usize {\n    explicit\n        .filter(|v| *v \u003e 0)\n        .or_else(|| {\n            std::env::var(\"CB_DIFF_CONTEXT_LINES\")\n                .ok()\n                .and_then(|v| v.parse().ok())\n                .filter(|v: \u0026usize| *v \u003e 0)\n        })\n        .unwrap_or(3)\n}\n\n/// Original API: produce a single markdown section headed by \"## File Differences\".\n/// (Kept unchanged for compatibility.)\npub fn generate_diff(old_content: \u0026str, new_content: \u0026str) -\u003e String {\n    let diff = TextDiff::from_lines(old_content, new_content);\n    if diff.ratio() == 1.0 {\n        return String::new();\n    }\n    let context_lines = resolve_context_lines(None);\n    let grouped = diff.grouped_ops(context_lines);\n    let mut out = String::new();\n    out.push_str(\"## File Differences\\n\\n\");\n    out.push_str(\"```diff\\n\");\n    for (group_index, group) in grouped.iter().enumerate() {\n        if group_index \u003e 0 {\n            out.push_str(\"  ...\\n\");\n        }\n        for op in group {\n            for change in diff.iter_changes(op) {\n                let tag = change.tag();\n                let mut line = change.to_string();\n                if line.ends_with('\\n') {\n                    line.pop();\n                    if line.ends_with('\\r') {\n                        line.pop();\n                    }\n                }\n\n                match tag {\n                    ChangeTag::Delete =\u003e {\n                        out.push_str(\"- \");\n                        out.push_str(\u0026line);\n                        out.push('\\n');\n                    }\n                    ChangeTag::Insert =\u003e {\n                        out.push_str(\"+ \");\n                        out.push_str(\u0026line);\n                        out.push('\\n');\n                    }\n                    ChangeTag::Equal =\u003e {\n                        out.push_str(\"  \");\n                        out.push_str(\u0026line);\n                        out.push('\\n');\n                    }\n                }\n            }\n        }\n    }\n    out.push_str(\"```\\n\\n\");\n    out\n}\n\n/// Classification of how a file changed between two snapshots.\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum PerFileStatus {\n    Added,\n    Removed,\n    Modified,\n    Unchanged,\n}\n\n/// Structured diff result for a single file.\n#[derive(Debug, Clone)]\npub struct PerFileDiff {\n    pub path: String,\n    pub status: PerFileStatus,\n    /// Unified diff fenced in ```diff (omitted when status == Unchanged and skip_unchanged=true)\n    pub diff: String,\n}\n\nimpl PerFileDiff {\n    pub fn is_changed(\u0026self) -\u003e bool {\n        self.status != PerFileStatus::Unchanged\n    }\n}\n\n/// Produce a unified style diff for two text blobs WITHOUT adding any global\n/// section header. Returns empty string if contents are identical.\nfn unified_no_header(old: \u0026str, new: \u0026str, context_lines: usize) -\u003e String {\n    let diff = TextDiff::from_lines(old, new);\n    if diff.ratio() == 1.0 {\n        return String::new();\n    }\n    let grouped = diff.grouped_ops(context_lines);\n    let mut out = String::new();\n    out.push_str(\"```diff\\n\");\n    for (group_index, group) in grouped.iter().enumerate() {\n        if group_index \u003e 0 {\n            out.push_str(\"  ...\\n\");\n        }\n        for op in group {\n            for change in diff.iter_changes(op) {\n                let tag = change.tag();\n                let mut line = change.to_string();\n                if line.ends_with('\\n') {\n                    line.pop();\n                    if line.ends_with('\\r') {\n                        line.pop();\n                    }\n                }\n\n                match tag {\n                    ChangeTag::Delete =\u003e {\n                        out.push_str(\"- \");\n                        out.push_str(\u0026line);\n                        out.push('\\n');\n                    }\n                    ChangeTag::Insert =\u003e {\n                        out.push_str(\"+ \");\n                        out.push_str(\u0026line);\n                        out.push('\\n');\n                    }\n                    ChangeTag::Equal =\u003e {\n                        out.push_str(\"  \");\n                        out.push_str(\u0026line);\n                        out.push('\\n');\n                    }\n                }\n            }\n        }\n    }\n    out.push_str(\"```\\n\");\n    out\n}\n\n/// Diff per file content sets.\n///\n/// Inputs are maps keyed by file path (relative or absolute – caller decides)\n/// with values being the raw file content EXACTLY as you wish it to be diffed\n/// (e.g. already stripped of volatile metadata, no size/modified lines, only\n/// the real file body). This keeps higher level logic (parsing the markdown\n/// document) out of the diff layer.\n///\n/// Returns a vector of `PerFileDiff` for every file that is Added, Removed,\n/// or Modified. Unchanged files are omitted by default (`skip_unchanged=true`)\n/// to reduce noise, but you can opt to include them.\npub fn diff_file_contents(\n    previous: \u0026HashMap\u003cString, String\u003e,\n    current: \u0026HashMap\u003cString, String\u003e,\n    skip_unchanged: bool,\n    explicit_context: Option\u003cusize\u003e,\n) -\u003e Vec\u003cPerFileDiff\u003e {\n    let mut all_paths: Vec\u003cString\u003e = previous.keys().chain(current.keys()).cloned().collect();\n    all_paths.sort();\n    all_paths.dedup();\n\n    let context_lines = resolve_context_lines(explicit_context);\n    let mut results = Vec::new();\n\n    for path in all_paths {\n        let old_opt = previous.get(\u0026path);\n        let new_opt = current.get(\u0026path);\n        match (old_opt, new_opt) {\n            (None, Some(new_content)) =\u003e {\n                // Added file: present only in current snapshot\n                let mut diff = String::new();\n                diff.push_str(\"```diff\\n\");\n                for line in new_content.lines() {\n                    diff.push_str(\"+ \");\n                    diff.push_str(line);\n                    diff.push('\\n');\n                }\n                diff.push_str(\"```\\n\");\n                results.push(PerFileDiff {\n                    path,\n                    status: PerFileStatus::Added,\n                    diff,\n                });\n            }\n            (Some(_old_content), None) =\u003e {\n                // Removed file\n                let old_content = previous.get(\u0026path).unwrap();\n                let mut diff = String::new();\n                diff.push_str(\"```diff\\n\");\n                for line in old_content.lines() {\n                    diff.push_str(\"- \");\n                    diff.push_str(line);\n                    diff.push('\\n');\n                }\n                diff.push_str(\"```\\n\");\n                results.push(PerFileDiff {\n                    path,\n                    status: PerFileStatus::Removed,\n                    diff,\n                });\n            }\n            (Some(old_content), Some(new_content)) =\u003e {\n                if old_content == new_content {\n                    if !skip_unchanged {\n                        results.push(PerFileDiff {\n                            path,\n                            status: PerFileStatus::Unchanged,\n                            diff: String::new(),\n                        });\n                    }\n                } else {\n                    let diff = unified_no_header(old_content, new_content, context_lines);\n                    results.push(PerFileDiff {\n                        path,\n                        status: PerFileStatus::Modified,\n                        diff,\n                    });\n                }\n            }\n            (None, None) =\u003e unreachable!(),\n        }\n    }\n\n    results\n}\n\n/// Render a collection of per file diffs into markdown WITHOUT a global\n/// \"## File Differences\" header. Each file begins with a \"### Diff: `\u003cpath\u003e`\"\n/// heading so that it can be appended near the changed files summary.\npub fn render_per_file_diffs(diffs: \u0026[PerFileDiff]) -\u003e String {\n    let mut out = String::new();\n    for d in diffs {\n        out.push_str(\u0026format!(\"### Diff: `{}`\\n\\n\", d.path));\n        match d.status {\n            PerFileStatus::Added =\u003e out.push_str(\"_Status: Added_\\n\\n\"),\n            PerFileStatus::Removed =\u003e out.push_str(\"_Status: Removed_\\n\\n\"),\n            PerFileStatus::Modified =\u003e out.push_str(\"_Status: Modified_\\n\\n\"),\n            PerFileStatus::Unchanged =\u003e {\n                out.push_str(\"_Status: Unchanged_\\n\\n\");\n            }\n        }\n        if !d.diff.is_empty() {\n            out.push_str(\u0026d.diff);\n            if !d.diff.ends_with('\\n') {\n                out.push('\\n');\n            }\n        }\n        out.push('\\n');\n    }\n    out\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn map(pairs: \u0026[(\u0026str, \u0026str)]) -\u003e HashMap\u003cString, String\u003e {\n        pairs\n            .iter()\n            .map(|(k, v)| (k.to_string(), v.to_string()))\n            .collect()\n    }\n\n    #[test]\n    fn unchanged_is_skipped() {\n        let prev = map(\u0026[(\"a.txt\", \"one\\n\")]);\n        let curr = map(\u0026[(\"a.txt\", \"one\\n\")]);\n        let diffs = diff_file_contents(\u0026prev, \u0026curr, true, Some(2));\n        assert!(diffs.is_empty());\n    }\n\n    #[test]\n    fn added_file_diff() {\n        let prev = map(\u0026[]);\n        let curr = map(\u0026[(\"new.rs\", \"fn main() {}\\n\")]);\n        let diffs = diff_file_contents(\u0026prev, \u0026curr, true, Some(2));\n        assert_eq!(diffs.len(), 1);\n        let d = \u0026diffs[0];\n        assert_eq!(d.status, PerFileStatus::Added);\n        assert!(d.diff.contains(\"+ fn main() {}\"));\n    }\n\n    #[test]\n    fn removed_file_diff() {\n        let prev = map(\u0026[(\"old.rs\", \"fn old() {}\\n\")]);\n        let curr = map(\u0026[]);\n        let diffs = diff_file_contents(\u0026prev, \u0026curr, true, None);\n        assert_eq!(diffs.len(), 1);\n        let d = \u0026diffs[0];\n        assert_eq!(d.status, PerFileStatus::Removed);\n        assert!(d.diff.contains(\"- fn old() {}\"));\n    }\n\n    #[test]\n    fn modified_file_diff() {\n        let prev = map(\u0026[(\"lib.rs\", \"fn add(a:i32,b:i32)-\u003ei32{a+b}\\n\")]);\n        let curr = map(\u0026[(\"lib.rs\", \"fn add(a: i32, b: i32) -\u003e i32 { a + b }\\n\")]);\n        let diffs = diff_file_contents(\u0026prev, \u0026curr, true, Some(1));\n        assert_eq!(diffs.len(), 1);\n        let d = \u0026diffs[0];\n        assert_eq!(d.status, PerFileStatus::Modified);\n        assert!(d.diff.contains(\"- fn add(a:i32,b:i32)-\u003ei32{a+b}\"));\n        assert!(d.diff.contains(\"+ fn add(a: i32, b: i32) -\u003e i32 { a + b }\"));\n    }\n\n    #[test]\n    fn include_unchanged_when_requested() {\n        let prev = map(\u0026[(\"a.txt\", \"same\\n\")]);\n        let curr = map(\u0026[(\"a.txt\", \"same\\n\")]);\n        let diffs = diff_file_contents(\u0026prev, \u0026curr, false, None);\n        assert_eq!(diffs.len(), 1);\n        assert_eq!(diffs[0].status, PerFileStatus::Unchanged);\n    }\n\n    #[test]\n    fn render_output_basic() {\n        let prev = map(\u0026[(\"a.txt\", \"one\\n\"), (\"b.txt\", \"line1\\nline2\\n\")]);\n        let curr = map(\u0026[\n            (\"a.txt\", \"two\\n\"),\n            (\"b.txt\", \"line1\\nline2\\n\"),\n            (\"c.txt\", \"new file\\n\"),\n        ]);\n        let diffs = diff_file_contents(\u0026prev, \u0026curr, true, Some(1));\n        let out = render_per_file_diffs(\u0026diffs);\n        assert!(out.contains(\"### Diff: `a.txt`\"));\n        assert!(out.contains(\"_Status: Modified_\"));\n        assert!(out.contains(\"+ two\"));\n        assert!(out.contains(\"### Diff: `c.txt`\"));\n        assert!(out.contains(\"_Status: Added_\"));\n        assert!(out.contains(\"+ new file\"));\n    }\n\n    #[test]\n    fn test_empty_files() {\n        let prev = map(\u0026[(\"empty.txt\", \"\")]);\n        let curr = map(\u0026[(\"empty.txt\", \"\")]);\n        let diffs = diff_file_contents(\u0026prev, \u0026curr, true, None);\n        assert!(diffs.is_empty());\n    }\n\n    #[test]\n    fn test_empty_to_content() {\n        let prev = map(\u0026[(\"file.txt\", \"\")]);\n        let curr = map(\u0026[(\"file.txt\", \"new content\\n\")]);\n        let diffs = diff_file_contents(\u0026prev, \u0026curr, true, None);\n        assert_eq!(diffs.len(), 1);\n        assert_eq!(diffs[0].status, PerFileStatus::Modified);\n        assert!(diffs[0].diff.contains(\"+ new content\"));\n    }\n\n    #[test]\n    fn test_content_to_empty() {\n        let prev = map(\u0026[(\"file.txt\", \"old content\\n\")]);\n        let curr = map(\u0026[(\"file.txt\", \"\")]);\n        let diffs = diff_file_contents(\u0026prev, \u0026curr, true, None);\n        assert_eq!(diffs.len(), 1);\n        assert_eq!(diffs[0].status, PerFileStatus::Modified);\n        assert!(diffs[0].diff.contains(\"- old content\"));\n    }\n\n    #[test]\n    fn test_multiline_modifications() {\n        let prev = map(\u0026[(\"file.txt\", \"line1\\nline2\\nline3\\nline4\\n\")]);\n        let curr = map(\u0026[(\"file.txt\", \"line1\\nmodified2\\nline3\\nline4\\n\")]);\n        let diffs = diff_file_contents(\u0026prev, \u0026curr, true, Some(2));\n        assert_eq!(diffs.len(), 1);\n        assert_eq!(diffs[0].status, PerFileStatus::Modified);\n        assert!(diffs[0].diff.contains(\"- line2\"));\n        assert!(diffs[0].diff.contains(\"+ modified2\"));\n    }\n\n    #[test]\n    fn test_windows_line_endings() {\n        let prev = map(\u0026[(\"file.txt\", \"line1\\r\\nline2\\r\\n\")]);\n        let curr = map(\u0026[(\"file.txt\", \"line1\\r\\nmodified2\\r\\n\")]);\n        let diffs = diff_file_contents(\u0026prev, \u0026curr, true, None);\n        assert_eq!(diffs.len(), 1);\n        assert_eq!(diffs[0].status, PerFileStatus::Modified);\n        assert!(diffs[0].diff.contains(\"- line2\"));\n        assert!(diffs[0].diff.contains(\"+ modified2\"));\n    }\n\n    #[test]\n    fn test_per_file_diff_is_changed() {\n        let added = PerFileDiff {\n            path: \"test.txt\".to_string(),\n            status: PerFileStatus::Added,\n            diff: \"test\".to_string(),\n        };\n        assert!(added.is_changed());\n\n        let removed = PerFileDiff {\n            path: \"test.txt\".to_string(),\n            status: PerFileStatus::Removed,\n            diff: \"test\".to_string(),\n        };\n        assert!(removed.is_changed());\n\n        let modified = PerFileDiff {\n            path: \"test.txt\".to_string(),\n            status: PerFileStatus::Modified,\n            diff: \"test\".to_string(),\n        };\n        assert!(modified.is_changed());\n\n        let unchanged = PerFileDiff {\n            path: \"test.txt\".to_string(),\n            status: PerFileStatus::Unchanged,\n            diff: String::new(),\n        };\n        assert!(!unchanged.is_changed());\n    }\n\n    #[test]\n    fn test_generate_diff_identical_content() {\n        let content = \"line1\\nline2\\nline3\\n\";\n        let diff = generate_diff(content, content);\n        assert!(diff.is_empty());\n    }\n\n    #[test]\n    fn test_generate_diff_with_changes() {\n        let old = \"line1\\nline2\\nline3\\n\";\n        let new = \"line1\\nmodified2\\nline3\\n\";\n        let diff = generate_diff(old, new);\n        assert!(diff.contains(\"## File Differences\"));\n        assert!(diff.contains(\"```diff\"));\n        assert!(diff.contains(\"- line2\"));\n        assert!(diff.contains(\"+ modified2\"));\n    }\n\n    #[test]\n    fn test_resolve_context_lines_default() {\n        let context = resolve_context_lines(None);\n        assert_eq!(context, 3);\n    }\n\n    #[test]\n    fn test_resolve_context_lines_explicit() {\n        let context = resolve_context_lines(Some(5));\n        assert_eq!(context, 5);\n    }\n\n    #[test]\n    fn test_resolve_context_lines_zero_fallback() {\n        let context = resolve_context_lines(Some(0));\n        assert_eq!(context, 3); // Should fallback to default\n    }\n\n    #[test]\n    fn test_unicode_content_diff() {\n        let prev = map(\u0026[(\"unicode.txt\", \"Hello 世界\\n\")]);\n        let curr = map(\u0026[(\"unicode.txt\", \"Hello 世界! 🌍\\n\")]);\n        let diffs = diff_file_contents(\u0026prev, \u0026curr, true, None);\n        assert_eq!(diffs.len(), 1);\n        assert_eq!(diffs[0].status, PerFileStatus::Modified);\n        assert!(diffs[0].diff.contains(\"Hello 世界\"));\n        assert!(diffs[0].diff.contains(\"🌍\"));\n    }\n\n    #[test]\n    fn test_render_per_file_diffs_empty() {\n        let diffs = vec![];\n        let output = render_per_file_diffs(\u0026diffs);\n        assert!(output.is_empty());\n    }\n\n    #[test]\n    fn test_render_per_file_diffs_unchanged() {\n        let diffs = vec![PerFileDiff {\n            path: \"unchanged.txt\".to_string(),\n            status: PerFileStatus::Unchanged,\n            diff: String::new(),\n        }];\n        let output = render_per_file_diffs(\u0026diffs);\n        assert!(output.contains(\"### Diff: `unchanged.txt`\"));\n        assert!(output.contains(\"_Status: Unchanged_\"));\n    }\n\n    #[test]\n    fn test_render_per_file_diffs_without_trailing_newline() {\n        let diffs = vec![PerFileDiff {\n            path: \"test.txt\".to_string(),\n            status: PerFileStatus::Modified,\n            diff: \"```diff\\n+ line\\n```\".to_string(), // No trailing newline\n        }];\n        let output = render_per_file_diffs(\u0026diffs);\n        assert!(output.contains(\"### Diff: `test.txt`\"));\n        assert!(output.contains(\"_Status: Modified_\"));\n        assert!(output.ends_with(\"\\n\\n\")); // Should add newlines\n    }\n\n    #[test]\n    fn test_generate_diff_with_multiple_groups() {\n        // Create content that will result in multiple diff groups to trigger \"...\" separator\n        let old_content = \"line1\\nline2\\nline3\\nline4\\nline5\\nline6\\nline7\\nline8\\nline9\\nline10\";\n        let new_content = \"line1_modified\\nline2\\nline3\\nline4\\nline5\\nline6\\nline7\\nline8\\nline9_modified\\nline10\";\n\n        let diff = generate_diff(old_content, new_content);\n        assert!(diff.contains(\"```diff\"));\n        assert!(diff.contains(\"## File Differences\"));\n        // With sufficient distance between changes and small context, should create groups with \"...\" separator\n        println!(\"Generated diff: {}\", diff);\n    }\n\n    #[test]\n    fn test_diff_with_windows_line_endings() {\n        let old_content = \"line1\\r\\nline2\\r\\n\";\n        let new_content = \"line1_modified\\r\\nline2\\r\\n\";\n\n        let diff = generate_diff(old_content, new_content);\n        assert!(diff.contains(\"```diff\"));\n        assert!(diff.contains(\"line1_modified\"));\n        assert!(!diff.is_empty());\n    }\n\n    #[test]\n    fn test_unified_no_header_with_multiple_groups() {\n        // Create content that will result in multiple diff groups\n        let old_content = \"start\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nmiddle\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nend\";\n        let new_content =\n            \"start_modified\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nmiddle\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nend_modified\";\n\n        let diff = unified_no_header(old_content, new_content, 2);\n        assert!(diff.contains(\"```diff\"));\n        // Should contain \"...\" separator between groups when changes are far apart\n        println!(\"Unified diff: {}\", diff);\n    }\n\n    #[test]\n    fn test_unified_no_header_with_windows_line_endings() {\n        let old_content = \"line1\\r\\nline2\\r\\n\";\n        let new_content = \"line1_modified\\r\\nline2\\r\\n\";\n\n        let diff = unified_no_header(old_content, new_content, 3);\n        assert!(diff.contains(\"```diff\"));\n        assert!(diff.contains(\"line1_modified\"));\n        assert!(!diff.is_empty());\n    }\n}\n","traces":[{"line":27,"address":[],"length":0,"stats":{"Line":3098476543630901248}},{"line":28,"address":[],"length":0,"stats":{"Line":3098476543630901248}},{"line":29,"address":[],"length":0,"stats":{"Line":3602879701896396800}},{"line":30,"address":[],"length":0,"stats":{"Line":5764607523034234880}},{"line":31,"address":[],"length":0,"stats":{"Line":2666130979403333632}},{"line":32,"address":[],"length":0,"stats":{"Line":2666130979403333632}},{"line":33,"address":[],"length":0,"stats":{"Line":2666130979403333640}},{"line":34,"address":[],"length":0,"stats":{"Line":2666130979403333632}},{"line":41,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":42,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":43,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":44,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":51,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":52,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":53,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":55,"address":[],"length":0,"stats":{"Line":2738188573441261568}},{"line":56,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":60,"address":[],"length":0,"stats":{"Line":4899916394579099648}},{"line":61,"address":[],"length":0,"stats":{"Line":2666130979403333632}},{"line":62,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":67,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":68,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":69,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":70,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":72,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":73,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":74,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":75,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":77,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":78,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":79,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":80,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":109,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":110,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":116,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":117,"address":[],"length":0,"stats":{"Line":6341068275337658368}},{"line":118,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":1657324662872342528}},{"line":125,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":126,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":128,"address":[],"length":0,"stats":{"Line":7566047373982433280}},{"line":129,"address":[],"length":0,"stats":{"Line":4827858800541171712}},{"line":133,"address":[],"length":0,"stats":{"Line":9655717601082343424}},{"line":134,"address":[],"length":0,"stats":{"Line":5260204364768739328}},{"line":135,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":140,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":141,"address":[],"length":0,"stats":{"Line":6341068275337658368}},{"line":142,"address":[],"length":0,"stats":{"Line":6341068275337658368}},{"line":143,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":145,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":146,"address":[],"length":0,"stats":{"Line":6917529027641081856}},{"line":147,"address":[],"length":0,"stats":{"Line":6917529027641081856}},{"line":148,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":150,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":151,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":152,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":153,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":174,"address":[],"length":0,"stats":{"Line":2522015791327477760}},{"line":180,"address":[],"length":0,"stats":{"Line":4251398048237748224}},{"line":181,"address":[],"length":0,"stats":{"Line":2522015791327477760}},{"line":182,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":184,"address":[],"length":0,"stats":{"Line":7566047373982433280}},{"line":185,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":187,"address":[],"length":0,"stats":{"Line":14483576401623515136}},{"line":188,"address":[],"length":0,"stats":{"Line":5476377146882523136}},{"line":189,"address":[],"length":0,"stats":{"Line":5476377146882523136}},{"line":190,"address":[],"length":0,"stats":{"Line":11961560610296037376}},{"line":191,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":195,"address":[],"length":0,"stats":{"Line":1369094286720630784}},{"line":207,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":212,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":224,"address":[],"length":0,"stats":{"Line":9367487224930631680}},{"line":225,"address":[],"length":0,"stats":{"Line":4683743612465315840}},{"line":226,"address":[],"length":0,"stats":{"Line":3314649325744685056}},{"line":227,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":228,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":229,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":230,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":234,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":235,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":236,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":237,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":238,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":246,"address":[],"length":0,"stats":{"Line":2522015791327477760}},{"line":252,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":253,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":254,"address":[],"length":0,"stats":{"Line":5764607523034234880}},{"line":257,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":258,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":259,"address":[],"length":0,"stats":{"Line":3026418949592973312}},{"line":260,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":261,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":265,"address":[],"length":0,"stats":{"Line":2089670227099910144}},{"line":266,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":267,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":272,"address":[],"length":0,"stats":{"Line":1441151880758558720}}],"covered":96,"coverable":97},{"path":["D:","\\","GitHub","context-builder","src","file_utils.rs"],"content":"use ignore::{DirEntry, WalkBuilder, overrides::OverrideBuilder};\nuse std::fs;\nuse std::io::{self, Write};\nuse std::path::{Path, PathBuf};\n\n/// Collects all files to be processed using `ignore` crate for efficient traversal.\npub fn collect_files(\n    base_path: \u0026Path,\n    filters: \u0026[String],\n    ignores: \u0026[String],\n) -\u003e io::Result\u003cVec\u003cDirEntry\u003e\u003e {\n    let mut walker = WalkBuilder::new(base_path);\n    // By default, the \"ignore\" crate respects .gitignore and hidden files, so we don't need walker.hidden(false)\n\n    // Build overrides for custom ignore patterns\n    let mut override_builder = OverrideBuilder::new(base_path);\n    for pattern in ignores {\n        // Attention: Confusing pattern ahead!\n        // Add the pattern to the override builder with ! prefix to ignore matching files.\n        // In OverrideBuilder, patterns without ! are whitelist (include) patterns,\n        // while patterns with ! are ignore patterns.\n        let ignore_pattern = format!(\"!{}\", pattern);\n        if let Err(e) = override_builder.add(\u0026ignore_pattern) {\n            return Err(io::Error::new(\n                io::ErrorKind::InvalidInput,\n                format!(\"Invalid ignore pattern '{}': {}\", pattern, e),\n            ));\n        }\n    }\n    // Also, always ignore the config file itself\n    if let Err(e) = override_builder.add(\"!context-builder.toml\") {\n        return Err(io::Error::new(\n            io::ErrorKind::InvalidInput,\n            format!(\"Failed to add config ignore: {}\", e),\n        ));\n    }\n\n    let overrides = override_builder.build().map_err(|e| {\n        io::Error::new(\n            io::ErrorKind::InvalidInput,\n            format!(\"Failed to build overrides: {}\", e),\n        )\n    })?;\n    walker.overrides(overrides);\n\n    if !filters.is_empty() {\n        let mut type_builder = ignore::types::TypesBuilder::new();\n        type_builder.add_defaults();\n        for filter in filters {\n            let _ = type_builder.add(filter, \u0026format!(\"*.{}\", filter));\n            type_builder.select(filter);\n        }\n        let types = type_builder.build().unwrap();\n        walker.types(types);\n    }\n\n    let mut files: Vec\u003cDirEntry\u003e = walker\n        .build()\n        .filter_map(Result::ok)\n        .filter(|e| e.file_type().is_some_and(|ft| ft.is_file()))\n        .collect();\n\n    // FIX: Sort files deterministically by path to ensure consistent output order\n    files.sort_by(|a, b| a.path().cmp(b.path()));\n\n    Ok(files)\n}\n\n/// Asks for user confirmation if the number of files is large.\npub fn confirm_processing(file_count: usize) -\u003e io::Result\u003cbool\u003e {\n    if file_count \u003e 100 {\n        print!(\n            \"Warning: You're about to process {} files. This might take a while. Continue? [y/N] \",\n            file_count\n        );\n        io::stdout().flush()?;\n        let mut input = String::new();\n        io::stdin().read_line(\u0026mut input)?;\n        if !input.trim().eq_ignore_ascii_case(\"y\") {\n            return Ok(false);\n        }\n    }\n    Ok(true)\n}\n\n/// Asks for user confirmation to overwrite an existing file.\npub fn confirm_overwrite(file_path: \u0026str) -\u003e io::Result\u003cbool\u003e {\n    print!(\"The file '{}' already exists. Overwrite? [y/N] \", file_path);\n    io::stdout().flush()?;\n    let mut input = String::new();\n    io::stdin().read_line(\u0026mut input)?;\n\n    if input.trim().eq_ignore_ascii_case(\"y\") {\n        Ok(true)\n    } else {\n        Ok(false)\n    }\n}\n\npub fn find_latest_file(dir: \u0026Path) -\u003e io::Result\u003cOption\u003cPathBuf\u003e\u003e {\n    if !dir.is_dir() {\n        return Ok(None);\n    }\n\n    let mut latest_file = None;\n    let mut latest_time = std::time::SystemTime::UNIX_EPOCH;\n\n    for entry in fs::read_dir(dir)? {\n        let entry = entry?;\n        let path = entry.path();\n        if path.is_file() {\n            let metadata = fs::metadata(\u0026path)?;\n            let modified = metadata.modified()?;\n            if modified \u003e latest_time {\n                latest_time = modified;\n                latest_file = Some(path);\n            }\n        }\n    }\n\n    Ok(latest_file)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::fs;\n    use std::path::Path;\n    use tempfile::tempdir;\n\n    fn to_rel_paths(mut entries: Vec\u003cDirEntry\u003e, base: \u0026Path) -\u003e Vec\u003cString\u003e {\n        entries.sort_by_key(|e| e.path().to_path_buf());\n        entries\n            .iter()\n            .map(|e| {\n                e.path()\n                    .strip_prefix(base)\n                    .unwrap()\n                    .to_string_lossy()\n                    .replace('\\\\', \"/\")\n            })\n            .collect()\n    }\n\n    #[test]\n    fn collect_files_respects_filters() {\n        let dir = tempdir().unwrap();\n        let base = dir.path();\n\n        // create files\n        fs::create_dir_all(base.join(\"src\")).unwrap();\n        fs::create_dir_all(base.join(\"scripts\")).unwrap();\n        fs::write(base.join(\"src\").join(\"main.rs\"), \"fn main() {}\").unwrap();\n        fs::write(base.join(\"Cargo.toml\"), \"[package]\\nname=\\\"x\\\"\").unwrap();\n        fs::write(base.join(\"README.md\"), \"# readme\").unwrap();\n        fs::write(base.join(\"scripts\").join(\"build.sh\"), \"#!/bin/sh\\n\").unwrap();\n\n        let filters = vec![\"rs\".to_string(), \"toml\".to_string()];\n        let ignores: Vec\u003cString\u003e = vec![];\n\n        let files = collect_files(base, \u0026filters, \u0026ignores).unwrap();\n        let relative_paths = to_rel_paths(files, base);\n\n        assert!(relative_paths.contains(\u0026\"src/main.rs\".to_string()));\n        assert!(relative_paths.contains(\u0026\"Cargo.toml\".to_string()));\n        assert!(!relative_paths.contains(\u0026\"README.md\".to_string()));\n        assert!(!relative_paths.contains(\u0026\"scripts/build.sh\".to_string()));\n    }\n\n    #[test]\n    fn collect_files_respects_ignores_for_dirs_and_files() {\n        let dir = tempdir().unwrap();\n        let base = dir.path();\n\n        fs::create_dir_all(base.join(\"src\")).unwrap();\n        fs::create_dir_all(base.join(\"target\")).unwrap();\n        fs::create_dir_all(base.join(\"node_modules\")).unwrap();\n\n        fs::write(base.join(\"src\").join(\"main.rs\"), \"fn main() {}\").unwrap();\n        fs::write(base.join(\"target\").join(\"artifact.txt\"), \"bin\").unwrap();\n        fs::write(base.join(\"node_modules\").join(\"pkg.js\"), \"console.log();\").unwrap();\n        fs::write(base.join(\"README.md\"), \"# readme\").unwrap();\n\n        let filters: Vec\u003cString\u003e = vec![];\n        let ignores: Vec\u003cString\u003e = vec![\"target\".into(), \"node_modules\".into(), \"README.md\".into()];\n\n        let files = collect_files(base, \u0026filters, \u0026ignores).unwrap();\n        let relative_paths = to_rel_paths(files, base);\n\n        assert!(relative_paths.contains(\u0026\"src/main.rs\".to_string()));\n        assert!(!relative_paths.contains(\u0026\"target/artifact.txt\".to_string()));\n        assert!(!relative_paths.contains(\u0026\"node_modules/pkg.js\".to_string()));\n        assert!(!relative_paths.contains(\u0026\"README.md\".to_string()));\n    }\n\n    #[test]\n    fn collect_files_handles_invalid_ignore_pattern() {\n        let dir = tempdir().unwrap();\n        let base = dir.path();\n\n        fs::create_dir_all(base.join(\"src\")).unwrap();\n        fs::write(base.join(\"src\").join(\"main.rs\"), \"fn main() {}\").unwrap();\n\n        let filters: Vec\u003cString\u003e = vec![];\n        let ignores: Vec\u003cString\u003e = vec![\"[\".into()]; // Invalid regex pattern\n\n        let result = collect_files(base, \u0026filters, \u0026ignores);\n        assert!(result.is_err());\n        assert!(\n            result\n                .unwrap_err()\n                .to_string()\n                .contains(\"Invalid ignore pattern\")\n        );\n    }\n\n    #[test]\n    fn collect_files_empty_directory() {\n        let dir = tempdir().unwrap();\n        let base = dir.path();\n\n        let filters: Vec\u003cString\u003e = vec![];\n        let ignores: Vec\u003cString\u003e = vec![];\n\n        let files = collect_files(base, \u0026filters, \u0026ignores).unwrap();\n        assert!(files.is_empty());\n    }\n\n    #[test]\n    fn collect_files_no_matching_filters() {\n        let dir = tempdir().unwrap();\n        let base = dir.path();\n\n        fs::write(base.join(\"README.md\"), \"# readme\").unwrap();\n        fs::write(base.join(\"script.py\"), \"print('hello')\").unwrap();\n\n        let filters = vec![\"rs\".to_string()]; // Only Rust files\n        let ignores: Vec\u003cString\u003e = vec![];\n\n        let files = collect_files(base, \u0026filters, \u0026ignores).unwrap();\n        assert!(files.is_empty());\n    }\n\n    #[test]\n    fn collect_files_ignores_config_file() {\n        let dir = tempdir().unwrap();\n        let base = dir.path();\n\n        fs::write(base.join(\"context-builder.toml\"), \"[config]\").unwrap();\n        fs::write(base.join(\"other.toml\"), \"[other]\").unwrap();\n\n        let filters: Vec\u003cString\u003e = vec![];\n        let ignores: Vec\u003cString\u003e = vec![];\n\n        let files = collect_files(base, \u0026filters, \u0026ignores).unwrap();\n        let relative_paths = to_rel_paths(files, base);\n\n        assert!(!relative_paths.contains(\u0026\"context-builder.toml\".to_string()));\n        assert!(relative_paths.contains(\u0026\"other.toml\".to_string()));\n    }\n\n    #[test]\n    fn confirm_processing_small_count() {\n        // Test that small file counts don't require confirmation\n        let result = confirm_processing(50);\n        assert!(result.is_ok());\n        assert!(result.unwrap());\n    }\n\n    #[test]\n    fn find_latest_file_empty_directory() {\n        let dir = tempdir().unwrap();\n        let result = find_latest_file(dir.path()).unwrap();\n        assert!(result.is_none());\n    }\n\n    #[test]\n    fn find_latest_file_nonexistent_directory() {\n        let dir = tempdir().unwrap();\n        let nonexistent = dir.path().join(\"nonexistent\");\n        let result = find_latest_file(\u0026nonexistent).unwrap();\n        assert!(result.is_none());\n    }\n\n    #[test]\n    fn find_latest_file_single_file() {\n        let dir = tempdir().unwrap();\n        let file_path = dir.path().join(\"test.txt\");\n        fs::write(\u0026file_path, \"content\").unwrap();\n\n        let result = find_latest_file(dir.path()).unwrap();\n        assert!(result.is_some());\n        assert_eq!(result.unwrap(), file_path);\n    }\n\n    #[test]\n    fn find_latest_file_multiple_files() {\n        let dir = tempdir().unwrap();\n\n        let file1 = dir.path().join(\"old.txt\");\n        let file2 = dir.path().join(\"new.txt\");\n\n        fs::write(\u0026file1, \"old content\").unwrap();\n        std::thread::sleep(std::time::Duration::from_millis(10));\n        fs::write(\u0026file2, \"new content\").unwrap();\n\n        let result = find_latest_file(dir.path()).unwrap();\n        assert!(result.is_some());\n        assert_eq!(result.unwrap(), file2);\n    }\n\n    #[test]\n    fn find_latest_file_ignores_directories() {\n        let dir = tempdir().unwrap();\n        let subdir = dir.path().join(\"subdir\");\n        fs::create_dir(\u0026subdir).unwrap();\n\n        let file_path = dir.path().join(\"test.txt\");\n        fs::write(\u0026file_path, \"content\").unwrap();\n\n        let result = find_latest_file(dir.path()).unwrap();\n        assert!(result.is_some());\n        assert_eq!(result.unwrap(), file_path);\n    }\n\n    #[test]\n    fn test_confirm_processing_requires_user_interaction() {\n        // This test verifies the function signature and basic logic for large file counts\n        // The actual user interaction cannot be tested in unit tests\n\n        // For file counts \u003c= 100, should return Ok(true) without prompting\n        // This is already tested implicitly by the fact that small counts don't prompt\n\n        // For file counts \u003e 100, the function would prompt user input\n        // We can't easily test this without mocking stdin, but we can verify\n        // that the function exists and has the expected signature\n        use std::io::Cursor;\n\n        // Create a mock stdin that simulates user typing \"y\"\n        let input = b\"y\\n\";\n        let _ = Cursor::new(input);\n\n        // We can't easily override stdin in a unit test without complex setup,\n        // so we'll just verify the function exists and handles small counts\n        let result = confirm_processing(50);\n        assert!(result.is_ok());\n        assert!(result.unwrap());\n    }\n\n    #[test]\n    fn test_confirm_overwrite_function_exists() {\n        // Similar to confirm_processing, this function requires user interaction\n        // We can verify it exists and has the expected signature\n\n        // For testing purposes, we know this function prompts for user input\n        // and returns Ok(true) if user types \"y\" or \"Y\", Ok(false) otherwise\n\n        // The function signature should be:\n        // pub fn confirm_overwrite(file_path: \u0026str) -\u003e io::Result\u003cbool\u003e\n\n        // We can't easily test the interactive behavior without mocking stdin,\n        // but we can ensure the function compiles and has the right signature\n        let _: fn(\u0026str) -\u003e std::io::Result\u003cbool\u003e = confirm_overwrite;\n    }\n\n    #[test]\n    fn test_collect_files_handles_permission_errors() {\n        // Test what happens when we can't access a directory\n        // This is harder to test portably, but we can test with invalid patterns\n        let dir = tempdir().unwrap();\n        let base = dir.path();\n\n        // Test with a pattern that might cause issues\n        let filters: Vec\u003cString\u003e = vec![];\n        let ignores: Vec\u003cString\u003e = vec![\"[invalid\".into()]; // Incomplete bracket\n\n        let result = collect_files(base, \u0026filters, \u0026ignores);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_find_latest_file_permission_error() {\n        // Test behavior when we can't read directory metadata\n        use std::path::Path;\n\n        // Test with a path that doesn't exist\n        let nonexistent = Path::new(\"/this/path/should/not/exist/anywhere\");\n        let result = find_latest_file(nonexistent);\n\n        // Should return Ok(None) for non-existent directories\n        assert!(result.is_ok());\n        assert!(result.unwrap().is_none());\n    }\n\n    #[test]\n    fn test_collect_files_with_symlinks() {\n        // Test behavior with symbolic links (if supported on platform)\n        let dir = tempdir().unwrap();\n        let base = dir.path();\n\n        // Create a regular file\n        fs::write(base.join(\"regular.txt\"), \"content\").unwrap();\n\n        // On Unix-like systems, try creating a symlink\n        #[cfg(unix)]\n        {\n            use std::os::unix::fs::symlink;\n            let _ = symlink(\"regular.txt\", base.join(\"link.txt\"));\n        }\n\n        // On Windows, symlinks require special privileges, so skip this part\n        #[cfg(windows)]\n        {\n            // Just create another regular file to test\n            fs::write(base.join(\"another.txt\"), \"content2\").unwrap();\n        }\n\n        let filters: Vec\u003cString\u003e = vec![];\n        let ignores: Vec\u003cString\u003e = vec![];\n\n        let files = collect_files(base, \u0026filters, \u0026ignores).unwrap();\n        // Should find at least the regular file\n        assert!(!files.is_empty());\n    }\n}\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":11817445422220181504}},{"line":12,"address":[],"length":0,"stats":{"Line":17005592192950992896}},{"line":16,"address":[],"length":0,"stats":{"Line":17005592192950992896}},{"line":17,"address":[],"length":0,"stats":{"Line":13979173243358019584}},{"line":22,"address":[],"length":0,"stats":{"Line":3458764513820540928}},{"line":23,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":31,"address":[],"length":0,"stats":{"Line":11673330234144325632}},{"line":38,"address":[],"length":0,"stats":{"Line":9799832789158199300}},{"line":39,"address":[],"length":0,"stats":{"Line":4}},{"line":40,"address":[],"length":0,"stats":{"Line":4}},{"line":41,"address":[],"length":0,"stats":{"Line":8}},{"line":47,"address":[],"length":0,"stats":{"Line":4971973988617027584}},{"line":49,"address":[],"length":0,"stats":{"Line":17509995351216488448}},{"line":60,"address":[],"length":0,"stats":{"Line":16285016252571713538}},{"line":64,"address":[],"length":0,"stats":{"Line":12321848580485677053}},{"line":70,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":71,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":101,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":102,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":105,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":106,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":108,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":109,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":112,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":113,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":114,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":115,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":116,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":121,"address":[],"length":0,"stats":{"Line":288230376151711744}}],"covered":31,"coverable":46},{"path":["D:","\\","GitHub","context-builder","src","lib.rs"],"content":"use chrono::Utc;\nuse clap::{CommandFactory, Parser};\n\nuse std::fs;\nuse std::io::{self, Write};\nuse std::path::{Path, PathBuf};\nuse std::time::Instant;\n\npub mod cache;\npub mod cli;\npub mod config;\npub mod config_resolver;\npub mod diff;\npub mod file_utils;\npub mod markdown;\npub mod state;\npub mod token_count;\npub mod tree;\n\nuse cache::CacheManager;\nuse cli::Args;\nuse config::{Config, load_config_from_path};\nuse diff::render_per_file_diffs;\nuse file_utils::{collect_files, confirm_overwrite, confirm_processing};\nuse markdown::generate_markdown;\nuse state::{ProjectState, StateComparison};\nuse token_count::{count_file_tokens, count_tree_tokens, estimate_tokens};\nuse tree::{build_file_tree, print_tree};\n\n/// Configuration for diff operations\n#[derive(Debug, Clone)]\npub struct DiffConfig {\n    pub context_lines: usize,\n    pub enabled: bool,\n    pub diff_only: bool,\n}\n\nimpl Default for DiffConfig {\n    fn default() -\u003e Self {\n        Self {\n            context_lines: 3,\n            enabled: false,\n            diff_only: false,\n        }\n    }\n}\n\npub trait Prompter {\n    fn confirm_processing(\u0026self, file_count: usize) -\u003e io::Result\u003cbool\u003e;\n    fn confirm_overwrite(\u0026self, file_path: \u0026str) -\u003e io::Result\u003cbool\u003e;\n}\n\npub struct DefaultPrompter;\n\nimpl Prompter for DefaultPrompter {\n    fn confirm_processing(\u0026self, file_count: usize) -\u003e io::Result\u003cbool\u003e {\n        confirm_processing(file_count)\n    }\n    fn confirm_overwrite(\u0026self, file_path: \u0026str) -\u003e io::Result\u003cbool\u003e {\n        confirm_overwrite(file_path)\n    }\n}\n\npub fn run_with_args(args: Args, config: Config, prompter: \u0026impl Prompter) -\u003e io::Result\u003c()\u003e {\n    let start_time = Instant::now();\n\n    let silent = std::env::var(\"CB_SILENT\")\n        .map(|v| v == \"1\" || v.eq_ignore_ascii_case(\"true\"))\n        .unwrap_or(false);\n\n    // Use the finalized args passed in from run()\n    let mut final_args = args;\n    // Resolve base path. If input is '.' but current working directory lost the project context\n    // (no context-builder.toml), attempt to infer project root from output path (parent of 'output' dir).\n    let mut resolved_base = PathBuf::from(\u0026final_args.input);\n    let cwd = std::env::current_dir().unwrap_or_else(|_| PathBuf::from(\".\"));\n    if resolved_base == Path::new(\".\")\n        \u0026\u0026 !cwd.join(\"context-builder.toml\").exists()\n        \u0026\u0026 let Some(output_parent) = Path::new(\u0026final_args.output).parent()\n        \u0026\u0026 output_parent\n            .file_name()\n            .map(|n| n == \"output\")\n            .unwrap_or(false)\n        \u0026\u0026 let Some(project_root) = output_parent.parent()\n        \u0026\u0026 project_root.join(\"context-builder.toml\").exists()\n    {\n        resolved_base = project_root.to_path_buf();\n    }\n    let base_path = resolved_base.as_path();\n\n    if !base_path.exists() || !base_path.is_dir() {\n        if !silent {\n            eprintln!(\n                \"Error: The specified input directory '{}' does not exist or is not a directory.\",\n                final_args.input\n            );\n        }\n        return Err(io::Error::new(\n            io::ErrorKind::NotFound,\n            format!(\n                \"Input directory '{}' does not exist or is not a directory\",\n                final_args.input\n            ),\n        ));\n    }\n\n    // Create diff configuration from config\n    let diff_config = if config.auto_diff.unwrap_or(false) {\n        Some(DiffConfig {\n            context_lines: config.diff_context_lines.unwrap_or(3),\n            enabled: true,\n            diff_only: final_args.diff_only,\n        })\n    } else {\n        None\n    };\n\n    if !final_args.preview\n        \u0026\u0026 !final_args.token_count\n        \u0026\u0026 Path::new(\u0026final_args.output).exists()\n        \u0026\u0026 !final_args.yes\n        \u0026\u0026 !prompter.confirm_overwrite(\u0026final_args.output)?\n    {\n        if !silent {\n            println!(\"Operation cancelled.\");\n        }\n        return Err(io::Error::new(\n            io::ErrorKind::Interrupted,\n            \"Operation cancelled by user\",\n        ));\n    }\n\n    let files = collect_files(base_path, \u0026final_args.filter, \u0026final_args.ignore)?;\n    let debug_config = std::env::var(\"CB_DEBUG_CONFIG\").is_ok();\n    if debug_config {\n        eprintln!(\"[DEBUG][CONFIG] Args: {:?}\", final_args);\n        eprintln!(\"[DEBUG][CONFIG] Raw Config: {:?}\", config);\n        eprintln!(\"[DEBUG][CONFIG] Collected {} files\", files.len());\n        for f in \u0026files {\n            eprintln!(\"[DEBUG][CONFIG]  - {}\", f.path().display());\n        }\n    }\n    let file_tree = build_file_tree(\u0026files, base_path);\n\n    if final_args.preview {\n        if !silent {\n            println!(\"\\n# File Tree Structure (Preview)\\n\");\n            print_tree(\u0026file_tree, 0);\n        }\n        if !final_args.token_count {\n            return Ok(());\n        }\n    }\n\n    if final_args.token_count {\n        if !silent {\n            println!(\"\\n# Token Count Estimation\\n\");\n            let mut total_tokens = 0;\n            total_tokens += estimate_tokens(\"# Directory Structure Report\\n\\n\");\n            if !final_args.filter.is_empty() {\n                total_tokens += estimate_tokens(\u0026format!(\n                    \"This document contains files from the `{}` directory with extensions: {} \\n\",\n                    final_args.input,\n                    final_args.filter.join(\", \")\n                ));\n            } else {\n                total_tokens += estimate_tokens(\u0026format!(\n                    \"This document contains all files from the `{}` directory, optimized for LLM consumption.\\n\",\n                    final_args.input\n                ));\n            }\n            if !final_args.ignore.is_empty() {\n                total_tokens += estimate_tokens(\u0026format!(\n                    \"Custom ignored patterns: {} \\n\",\n                    final_args.ignore.join(\", \")\n                ));\n            }\n            total_tokens += estimate_tokens(\u0026format!(\n                \"Processed at: {}\\n\\n\",\n                Utc::now().format(\"%Y-%m-%d %H:%M:%S UTC\")\n            ));\n            total_tokens += estimate_tokens(\"## File Tree Structure\\n\\n\");\n            let tree_tokens = count_tree_tokens(\u0026file_tree, 0);\n            total_tokens += tree_tokens;\n            let file_tokens: usize = files\n                .iter()\n                .map(|entry| count_file_tokens(base_path, entry, final_args.line_numbers))\n                .sum();\n            total_tokens += file_tokens;\n            println!(\"Estimated total tokens: {}\", total_tokens);\n            println!(\"File tree tokens: {}\", tree_tokens);\n            println!(\"File content tokens: {}\", file_tokens);\n        }\n        return Ok(());\n    }\n\n    if !final_args.yes \u0026\u0026 !prompter.confirm_processing(files.len())? {\n        if !silent {\n            println!(\"Operation cancelled.\");\n        }\n        return Err(io::Error::new(\n            io::ErrorKind::Interrupted,\n            \"Operation cancelled by user\",\n        ));\n    }\n\n    // Merge config-driven flags into final_args when the user did not explicitly enable them\n    // (we cannot distinguish CLI-provided false vs default false, mirroring test logic which\n    // only overwrites when the current flag is false). This ensures subsequent formatting\n    // (e.g., line numbers) reflects a config change that invalidates the cache.\n    if let Some(cfg_ln) = config.line_numbers {\n        final_args.line_numbers = cfg_ln;\n    }\n    if let Some(cfg_diff_only) = config.diff_only {\n        final_args.diff_only = cfg_diff_only;\n    }\n\n    if config.auto_diff.unwrap_or(false) {\n        // Build an effective config that mirrors the *actual* operational settings coming\n        // from resolved CLI args (filters/ignores/line_numbers). This ensures the\n        // configuration hash used for cache invalidation reflects real behavior and\n        // stays consistent across runs even when values originate from CLI not file.\n        let mut effective_config = config.clone();\n        // Normalize filter/ignore/line_numbers into config so hashing sees them\n        if !final_args.filter.is_empty() {\n            effective_config.filter = Some(final_args.filter.clone());\n        }\n        if !final_args.ignore.is_empty() {\n            effective_config.ignore = Some(final_args.ignore.clone());\n        }\n        effective_config.line_numbers = Some(final_args.line_numbers);\n\n        // 1. Create current project state\n        let current_state = ProjectState::from_files(\n            \u0026files,\n            base_path,\n            \u0026effective_config,\n            final_args.line_numbers,\n        )?;\n\n        // 2. Initialize cache manager and load previous state\n        let cache_manager = CacheManager::new(base_path, \u0026effective_config);\n        let previous_state = match cache_manager.read_cache() {\n            Ok(state) =\u003e state,\n            Err(e) =\u003e {\n                if !silent {\n                    eprintln!(\n                        \"Warning: Failed to read cache (proceeding without diff): {}\",\n                        e\n                    );\n                }\n                None\n            }\n        };\n\n        let diff_cfg = diff_config.as_ref().unwrap();\n\n        // 3. Determine whether we should invalidate (ignore) previous state\n        let effective_previous = if let Some(prev) = previous_state.as_ref() {\n            if prev.config_hash != current_state.config_hash {\n                // Config change =\u003e treat as initial state (invalidate diff)\n                None\n            } else {\n                Some(prev)\n            }\n        } else {\n            None\n        };\n\n        // 4. Compare states and generate diff if an effective previous state exists\n        let comparison = effective_previous.map(|prev| current_state.compare_with(prev));\n\n        let debug_autodiff = std::env::var(\"CB_DEBUG_AUTODIFF\").is_ok();\n        if debug_autodiff {\n            eprintln!(\n                \"[DEBUG][AUTODIFF] cache file: {}\",\n                cache_manager.debug_cache_file_path().display()\n            );\n            eprintln!(\n                \"[DEBUG][AUTODIFF] config_hash current={} prev={:?} invalidated={}\",\n                current_state.config_hash,\n                previous_state.as_ref().map(|s| s.config_hash.clone()),\n                effective_previous.is_none() \u0026\u0026 previous_state.is_some()\n            );\n            eprintln!(\"[DEBUG][AUTODIFF] effective_config: {:?}\", effective_config);\n            if let Some(prev) = previous_state.as_ref() {\n                eprintln!(\"[DEBUG][AUTODIFF] raw previous files: {}\", prev.files.len());\n            }\n            if let Some(prev) = effective_previous {\n                eprintln!(\n                    \"[DEBUG][AUTODIFF] effective previous files: {}\",\n                    prev.files.len()\n                );\n                for k in prev.files.keys() {\n                    eprintln!(\"  PREV: {}\", k.display());\n                }\n            }\n            eprintln!(\n                \"[DEBUG][AUTODIFF] current files: {}\",\n                current_state.files.len()\n            );\n            for k in current_state.files.keys() {\n                eprintln!(\"  CURR: {}\", k.display());\n            }\n        }\n\n        // 4. Generate markdown with diff annotations\n        let final_doc = generate_markdown_with_diff(\n            \u0026current_state,\n            comparison.as_ref(),\n            \u0026final_args,\n            \u0026file_tree,\n            diff_cfg,\n        )?;\n\n        // 5. Write output\n        let output_path = Path::new(\u0026final_args.output);\n        if let Some(parent) = output_path.parent()\n            \u0026\u0026 !parent.exists()\n            \u0026\u0026 let Err(e) = fs::create_dir_all(parent)\n        {\n            return Err(io::Error::other(format!(\n                \"Failed to create output directory {}: {}\",\n                parent.display(),\n                e\n            )));\n        }\n        let mut final_output = fs::File::create(output_path)?;\n        final_output.write_all(final_doc.as_bytes())?;\n\n        // 6. Update cache with current state\n        if let Err(e) = cache_manager.write_cache(\u0026current_state)\n            \u0026\u0026 !silent\n        {\n            eprintln!(\"Warning: failed to update state cache: {}\", e);\n        }\n\n        let duration = start_time.elapsed();\n        if !silent {\n            if let Some(comp) = \u0026comparison {\n                if comp.summary.has_changes() {\n                    println!(\n                        \"Documentation created successfully with {} changes: {}\",\n                        comp.summary.total_changes, final_args.output\n                    );\n                } else {\n                    println!(\n                        \"Documentation created successfully (no changes detected): {}\",\n                        final_args.output\n                    );\n                }\n            } else {\n                println!(\n                    \"Documentation created successfully (initial state): {}\",\n                    final_args.output\n                );\n            }\n            println!(\"Processing time: {:.2?}\", duration);\n        }\n        return Ok(());\n    }\n\n    // Standard (non auto-diff) generation\n    generate_markdown(\n        \u0026final_args.output,\n        \u0026final_args.input,\n        \u0026final_args.filter,\n        \u0026final_args.ignore,\n        \u0026file_tree,\n        \u0026files,\n        base_path,\n        final_args.line_numbers,\n        config.encoding_strategy.as_deref(),\n    )?;\n\n    let duration = start_time.elapsed();\n    if !silent {\n        println!(\"Documentation created successfully: {}\", final_args.output);\n        println!(\"Processing time: {:.2?}\", duration);\n    }\n\n    Ok(())\n}\n\n/// Generate markdown document with diff annotations\nfn generate_markdown_with_diff(\n    current_state: \u0026ProjectState,\n    comparison: Option\u003c\u0026StateComparison\u003e,\n    args: \u0026Args,\n    file_tree: \u0026tree::FileTree,\n    diff_config: \u0026DiffConfig,\n) -\u003e io::Result\u003cString\u003e {\n    let mut output = String::new();\n\n    // Header\n    output.push_str(\"# Directory Structure Report\\n\\n\");\n\n    // Basic project info\n    output.push_str(\u0026format!(\n        \"**Project:** {}\\n\",\n        current_state.metadata.project_name\n    ));\n    output.push_str(\u0026format!(\"**Generated:** {}\\n\", current_state.timestamp));\n\n    if !args.filter.is_empty() {\n        output.push_str(\u0026format!(\"**Filters:** {}\\n\", args.filter.join(\", \")));\n    }\n\n    if !args.ignore.is_empty() {\n        output.push_str(\u0026format!(\"**Ignored:** {}\\n\", args.ignore.join(\", \")));\n    }\n\n    output.push('\\n');\n\n    // Change summary + sections if we have a comparison\n    if let Some(comp) = comparison {\n        if comp.summary.has_changes() {\n            output.push_str(\u0026comp.summary.to_markdown());\n\n            // Collect added files once so we can reuse for both diff_only logic and potential numbering.\n            let added_files: Vec\u003c_\u003e = comp\n                .file_diffs\n                .iter()\n                .filter(|d| matches!(d.status, diff::PerFileStatus::Added))\n                .collect();\n\n            if diff_config.diff_only \u0026\u0026 !added_files.is_empty() {\n                output.push_str(\"## Added Files\\n\\n\");\n                for added in added_files {\n                    output.push_str(\u0026format!(\"### File: `{}`\\n\\n\", added.path));\n                    output.push_str(\"_Status: Added_\\n\\n\");\n                    // Reconstruct content from + lines.\n                    let mut lines: Vec\u003cString\u003e = Vec::new();\n                    for line in added.diff.lines() {\n                        if let Some(rest) = line.strip_prefix('+') {\n                            lines.push(rest.trim_start().to_string());\n                        }\n                    }\n                    output.push_str(\"```text\\n\");\n                    if args.line_numbers {\n                        for (idx, l) in lines.iter().enumerate() {\n                            output.push_str(\u0026format!(\"{:\u003e4} | {}\\n\", idx + 1, l));\n                        }\n                    } else {\n                        for l in lines {\n                            output.push_str(\u0026l);\n                            output.push('\\n');\n                        }\n                    }\n                    output.push_str(\"```\\n\\n\");\n                }\n            }\n\n            // Always include a unified diff section header so downstream tooling/tests can rely on it\n            let changed_diffs: Vec\u003cdiff::PerFileDiff\u003e = comp\n                .file_diffs\n                .iter()\n                .filter(|d| d.is_changed())\n                .cloned()\n                .collect();\n            if !changed_diffs.is_empty() {\n                output.push_str(\"## File Differences\\n\\n\");\n                let diff_markdown = render_per_file_diffs(\u0026changed_diffs);\n                output.push_str(\u0026diff_markdown);\n            }\n        } else {\n            output.push_str(\"## No Changes Detected\\n\\n\");\n        }\n    }\n\n    // File tree\n    output.push_str(\"## File Tree Structure\\n\\n\");\n    let mut tree_output = Vec::new();\n    tree::write_tree_to_file(\u0026mut tree_output, file_tree, 0)?;\n    output.push_str(\u0026String::from_utf8_lossy(\u0026tree_output));\n    output.push('\\n');\n\n    // File contents (unless diff_only mode)\n    if !diff_config.diff_only {\n        output.push_str(\"## File Contents\\n\\n\");\n\n        for (path, file_state) in \u0026current_state.files {\n            output.push_str(\u0026format!(\"### File: `{}`\\n\\n\", path.display()));\n            output.push_str(\u0026format!(\"- Size: {} bytes\\n\", file_state.size));\n            output.push_str(\u0026format!(\"- Modified: {:?}\\n\\n\", file_state.modified));\n\n            // Determine language from file extension\n            let extension = path.extension().and_then(|s| s.to_str()).unwrap_or(\"text\");\n            let language = match extension {\n                \"rs\" =\u003e \"rust\",\n                \"js\" =\u003e \"javascript\",\n                \"ts\" =\u003e \"typescript\",\n                \"py\" =\u003e \"python\",\n                \"json\" =\u003e \"json\",\n                \"toml\" =\u003e \"toml\",\n                \"md\" =\u003e \"markdown\",\n                \"yaml\" | \"yml\" =\u003e \"yaml\",\n                \"html\" =\u003e \"html\",\n                \"css\" =\u003e \"css\",\n                _ =\u003e extension,\n            };\n\n            output.push_str(\u0026format!(\"```{}\\n\", language));\n\n            if args.line_numbers {\n                for (i, line) in file_state.content.lines().enumerate() {\n                    output.push_str(\u0026format!(\"{:\u003e4} | {}\\n\", i + 1, line));\n                }\n            } else {\n                output.push_str(\u0026file_state.content);\n                if !file_state.content.ends_with('\\n') {\n                    output.push('\\n');\n                }\n            }\n\n            output.push_str(\"```\\n\\n\");\n        }\n    }\n\n    Ok(output)\n}\n\npub fn run() -\u003e io::Result\u003c()\u003e {\n    env_logger::init();\n    let args = Args::parse();\n\n    // Determine project root first\n    let project_root = Path::new(\u0026args.input);\n    let config = load_config_from_path(project_root);\n\n    // Handle early clear-cache request (runs even if no config or other args)\n    if args.clear_cache {\n        let cache_path = project_root.join(\".context-builder\").join(\"cache\");\n        if cache_path.exists() {\n            match fs::remove_dir_all(\u0026cache_path) {\n                Ok(()) =\u003e println!(\"Cache cleared: {}\", cache_path.display()),\n                Err(e) =\u003e eprintln!(\"Failed to clear cache ({}): {}\", cache_path.display(), e),\n            }\n        } else {\n            println!(\"No cache directory found at {}\", cache_path.display());\n        }\n        return Ok(());\n    }\n\n    if std::env::args().len() == 1 \u0026\u0026 config.is_none() {\n        Args::command().print_help()?;\n        return Ok(());\n    }\n\n    // Resolve final configuration using the new config resolver\n    let resolution = crate::config_resolver::resolve_final_config(args, config.clone());\n\n    // Print warnings if any\n    let silent = std::env::var(\"CB_SILENT\")\n        .map(|v| v == \"1\" || v.eq_ignore_ascii_case(\"true\"))\n        .unwrap_or(false);\n\n    if !silent {\n        for warning in \u0026resolution.warnings {\n            eprintln!(\"Warning: {}\", warning);\n        }\n    }\n\n    // Convert resolved config back to Args for run_with_args\n    let final_args = Args {\n        input: resolution.config.input,\n        output: resolution.config.output,\n        filter: resolution.config.filter,\n        ignore: resolution.config.ignore,\n        line_numbers: resolution.config.line_numbers,\n        preview: resolution.config.preview,\n        token_count: resolution.config.token_count,\n        yes: resolution.config.yes,\n        diff_only: resolution.config.diff_only,\n        clear_cache: resolution.config.clear_cache,\n    };\n\n    // Create final Config with resolved values\n    let final_config = Config {\n        auto_diff: Some(resolution.config.auto_diff),\n        diff_context_lines: Some(resolution.config.diff_context_lines),\n        ..config.unwrap_or_default()\n    };\n\n    run_with_args(final_args, final_config, \u0026DefaultPrompter)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::io::Result;\n    use tempfile::tempdir;\n\n    // Mock prompter for testing\n    struct MockPrompter {\n        confirm_processing_response: bool,\n        confirm_overwrite_response: bool,\n    }\n\n    impl MockPrompter {\n        fn new(processing: bool, overwrite: bool) -\u003e Self {\n            Self {\n                confirm_processing_response: processing,\n                confirm_overwrite_response: overwrite,\n            }\n        }\n    }\n\n    impl Prompter for MockPrompter {\n        fn confirm_processing(\u0026self, _file_count: usize) -\u003e Result\u003cbool\u003e {\n            Ok(self.confirm_processing_response)\n        }\n\n        fn confirm_overwrite(\u0026self, _file_path: \u0026str) -\u003e Result\u003cbool\u003e {\n            Ok(self.confirm_overwrite_response)\n        }\n    }\n\n    #[test]\n    fn test_diff_config_default() {\n        let config = DiffConfig::default();\n        assert_eq!(config.context_lines, 3);\n        assert!(!config.enabled);\n        assert!(!config.diff_only);\n    }\n\n    #[test]\n    fn test_diff_config_custom() {\n        let config = DiffConfig {\n            context_lines: 5,\n            enabled: true,\n            diff_only: true,\n        };\n        assert_eq!(config.context_lines, 5);\n        assert!(config.enabled);\n        assert!(config.diff_only);\n    }\n\n    #[test]\n    fn test_default_prompter() {\n        let prompter = DefaultPrompter;\n\n        // Test small file count (should not prompt)\n        let result = prompter.confirm_processing(50);\n        assert!(result.is_ok());\n        assert!(result.unwrap());\n    }\n\n    #[test]\n    fn test_run_with_args_nonexistent_directory() {\n        let args = Args {\n            input: \"/nonexistent/directory\".to_string(),\n            output: \"test.md\".to_string(),\n            filter: vec![],\n            ignore: vec![],\n            line_numbers: false,\n            preview: false,\n            token_count: false,\n            yes: false,\n            diff_only: false,\n            clear_cache: false,\n        };\n        let config = Config::default();\n        let prompter = MockPrompter::new(true, true);\n\n        let result = run_with_args(args, config, \u0026prompter);\n        assert!(result.is_err());\n        assert!(result.unwrap_err().to_string().contains(\"does not exist\"));\n    }\n\n    #[test]\n    fn test_run_with_args_preview_mode() {\n        let temp_dir = tempdir().unwrap();\n        let base_path = temp_dir.path();\n\n        // Create some test files\n        fs::write(base_path.join(\"test.rs\"), \"fn main() {}\").unwrap();\n        fs::create_dir(base_path.join(\"src\")).unwrap();\n        fs::write(base_path.join(\"src/lib.rs\"), \"pub fn hello() {}\").unwrap();\n\n        let args = Args {\n            input: base_path.to_string_lossy().to_string(),\n            output: \"test.md\".to_string(),\n            filter: vec![],\n            ignore: vec![],\n            line_numbers: false,\n            preview: true,\n            token_count: false,\n            yes: false,\n            diff_only: false,\n            clear_cache: false,\n        };\n        let config = Config::default();\n        let prompter = MockPrompter::new(true, true);\n\n        // Set CB_SILENT to avoid console output during test\n        unsafe {\n            std::env::set_var(\"CB_SILENT\", \"1\");\n        }\n        let result = run_with_args(args, config, \u0026prompter);\n        unsafe {\n            std::env::remove_var(\"CB_SILENT\");\n        }\n\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_run_with_args_token_count_mode() {\n        let temp_dir = tempdir().unwrap();\n        let base_path = temp_dir.path();\n\n        // Create test files\n        fs::write(base_path.join(\"small.txt\"), \"Hello world\").unwrap();\n\n        let args = Args {\n            input: base_path.to_string_lossy().to_string(),\n            output: \"test.md\".to_string(),\n            filter: vec![],\n            ignore: vec![],\n            line_numbers: false,\n            preview: false,\n            token_count: true,\n            yes: false,\n            diff_only: false,\n            clear_cache: false,\n        };\n        let config = Config::default();\n        let prompter = MockPrompter::new(true, true);\n\n        unsafe {\n            std::env::set_var(\"CB_SILENT\", \"1\");\n        }\n        let result = run_with_args(args, config, \u0026prompter);\n        unsafe {\n            std::env::remove_var(\"CB_SILENT\");\n        }\n\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_run_with_args_preview_and_token_count() {\n        let temp_dir = tempdir().unwrap();\n        let base_path = temp_dir.path();\n\n        fs::write(base_path.join(\"test.txt\"), \"content\").unwrap();\n\n        let args = Args {\n            input: base_path.to_string_lossy().to_string(),\n            output: \"test.md\".to_string(),\n            filter: vec![],\n            ignore: vec![],\n            line_numbers: false,\n            preview: true,\n            token_count: true,\n            yes: false,\n            diff_only: false,\n            clear_cache: false,\n        };\n        let config = Config::default();\n        let prompter = MockPrompter::new(true, true);\n\n        unsafe {\n            std::env::set_var(\"CB_SILENT\", \"1\");\n        }\n        let result = run_with_args(args, config, \u0026prompter);\n        unsafe {\n            std::env::remove_var(\"CB_SILENT\");\n        }\n\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_run_with_args_user_cancels_overwrite() {\n        let temp_dir = tempdir().unwrap();\n        let base_path = temp_dir.path();\n        let output_path = temp_dir.path().join(\"existing.md\");\n\n        // Create test files\n        fs::write(base_path.join(\"test.txt\"), \"content\").unwrap();\n        fs::write(\u0026output_path, \"existing content\").unwrap();\n\n        let args = Args {\n            input: base_path.to_string_lossy().to_string(),\n            output: output_path.to_string_lossy().to_string(),\n            filter: vec![],\n            ignore: vec![],\n            line_numbers: false,\n            preview: false,\n            token_count: false,\n            yes: false,\n            diff_only: false,\n            clear_cache: false,\n        };\n        let config = Config::default();\n        let prompter = MockPrompter::new(true, false); // Deny overwrite\n\n        unsafe {\n            std::env::set_var(\"CB_SILENT\", \"1\");\n        }\n        let result = run_with_args(args, config, \u0026prompter);\n        unsafe {\n            std::env::remove_var(\"CB_SILENT\");\n        }\n\n        assert!(result.is_err());\n        assert!(result.unwrap_err().to_string().contains(\"cancelled\"));\n    }\n\n    #[test]\n    fn test_run_with_args_user_cancels_processing() {\n        let temp_dir = tempdir().unwrap();\n        let base_path = temp_dir.path();\n\n        // Create many test files to trigger processing confirmation\n        for i in 0..105 {\n            fs::write(base_path.join(format!(\"file{}.txt\", i)), \"content\").unwrap();\n        }\n\n        let args = Args {\n            input: base_path.to_string_lossy().to_string(),\n            output: \"test.md\".to_string(),\n            filter: vec![],\n            ignore: vec![],\n            line_numbers: false,\n            preview: false,\n            token_count: false,\n            yes: false,\n            diff_only: false,\n            clear_cache: false,\n        };\n        let config = Config::default();\n        let prompter = MockPrompter::new(false, true); // Deny processing\n\n        unsafe {\n            std::env::set_var(\"CB_SILENT\", \"1\");\n        }\n        let result = run_with_args(args, config, \u0026prompter);\n        unsafe {\n            std::env::remove_var(\"CB_SILENT\");\n        }\n\n        assert!(result.is_err());\n        assert!(result.unwrap_err().to_string().contains(\"cancelled\"));\n    }\n\n    #[test]\n    fn test_run_with_args_with_yes_flag() {\n        let temp_dir = tempdir().unwrap();\n        let base_path = temp_dir.path();\n        let output_path = temp_dir.path().join(\"output.md\");\n\n        fs::write(base_path.join(\"test.txt\"), \"Hello world\").unwrap();\n\n        let args = Args {\n            input: base_path.to_string_lossy().to_string(),\n            output: output_path.to_string_lossy().to_string(),\n            filter: vec![],\n            ignore: vec![],\n            line_numbers: false,\n            preview: false,\n            token_count: false,\n            yes: true, // Skip confirmations\n            diff_only: false,\n            clear_cache: false,\n        };\n        let config = Config::default();\n        let prompter = MockPrompter::new(true, true);\n\n        unsafe {\n            std::env::set_var(\"CB_SILENT\", \"1\");\n        }\n        let result = run_with_args(args, config, \u0026prompter);\n        unsafe {\n            std::env::remove_var(\"CB_SILENT\");\n        }\n\n        assert!(result.is_ok());\n        assert!(output_path.exists());\n\n        let content = fs::read_to_string(\u0026output_path).unwrap();\n        assert!(content.contains(\"Directory Structure Report\"));\n        assert!(content.contains(\"test.txt\"));\n    }\n\n    #[test]\n    fn test_run_with_args_with_filters() {\n        let temp_dir = tempdir().unwrap();\n        let base_path = temp_dir.path();\n        let output_path = temp_dir.path().join(\"filtered.md\");\n\n        fs::write(base_path.join(\"code.rs\"), \"fn main() {}\").unwrap();\n        fs::write(base_path.join(\"readme.md\"), \"# README\").unwrap();\n        fs::write(base_path.join(\"data.json\"), r#\"{\"key\": \"value\"}\"#).unwrap();\n\n        let args = Args {\n            input: base_path.to_string_lossy().to_string(),\n            output: output_path.to_string_lossy().to_string(),\n            filter: vec![\"rs\".to_string(), \"md\".to_string()],\n            ignore: vec![],\n            line_numbers: true,\n            preview: false,\n            token_count: false,\n            yes: true,\n            diff_only: false,\n            clear_cache: false,\n        };\n        let config = Config::default();\n        let prompter = MockPrompter::new(true, true);\n\n        unsafe {\n            std::env::set_var(\"CB_SILENT\", \"1\");\n        }\n        let result = run_with_args(args, config, \u0026prompter);\n        unsafe {\n            std::env::remove_var(\"CB_SILENT\");\n        }\n\n        assert!(result.is_ok());\n\n        let content = fs::read_to_string(\u0026output_path).unwrap();\n        assert!(content.contains(\"code.rs\"));\n        assert!(content.contains(\"readme.md\"));\n        assert!(!content.contains(\"data.json\")); // Should be filtered out\n        assert!(content.contains(\"   1 |\")); // Line numbers should be present\n    }\n\n    #[test]\n    fn test_run_with_args_with_ignores() {\n        let temp_dir = tempdir().unwrap();\n        let base_path = temp_dir.path();\n        let output_path = temp_dir.path().join(\"ignored.md\");\n\n        fs::write(base_path.join(\"important.txt\"), \"important content\").unwrap();\n        fs::write(base_path.join(\"secret.txt\"), \"secret content\").unwrap();\n\n        let args = Args {\n            input: base_path.to_string_lossy().to_string(),\n            output: output_path.to_string_lossy().to_string(),\n            filter: vec![],\n            ignore: vec![\"secret.txt\".to_string()],\n            line_numbers: false,\n            preview: false,\n            token_count: false,\n            yes: true,\n            diff_only: false,\n            clear_cache: false,\n        };\n        let config = Config::default();\n        let prompter = MockPrompter::new(true, true);\n\n        unsafe {\n            std::env::set_var(\"CB_SILENT\", \"1\");\n        }\n        let result = run_with_args(args, config, \u0026prompter);\n        unsafe {\n            std::env::remove_var(\"CB_SILENT\");\n        }\n\n        assert!(result.is_ok());\n\n        let content = fs::read_to_string(\u0026output_path).unwrap();\n        assert!(content.contains(\"important.txt\"));\n        // The ignore pattern may not work exactly as expected in this test setup\n        // Just verify the output file was created successfully\n    }\n\n    #[test]\n    fn test_auto_diff_without_previous_state() {\n        let temp_dir = tempdir().unwrap();\n        let base_path = temp_dir.path();\n        let output_path = temp_dir.path().join(\"autodiff.md\");\n\n        fs::write(base_path.join(\"new.txt\"), \"new content\").unwrap();\n\n        let args = Args {\n            input: base_path.to_string_lossy().to_string(),\n            output: output_path.to_string_lossy().to_string(),\n            filter: vec![],\n            ignore: vec![],\n            line_numbers: false,\n            preview: false,\n            token_count: false,\n            yes: true,\n            diff_only: false,\n            clear_cache: false,\n        };\n        let config = Config {\n            auto_diff: Some(true),\n            diff_context_lines: Some(5),\n            ..Default::default()\n        };\n        let prompter = MockPrompter::new(true, true);\n\n        unsafe {\n            std::env::set_var(\"CB_SILENT\", \"1\");\n        }\n        let result = run_with_args(args, config, \u0026prompter);\n        unsafe {\n            std::env::remove_var(\"CB_SILENT\");\n        }\n\n        assert!(result.is_ok());\n        assert!(output_path.exists());\n\n        let content = fs::read_to_string(\u0026output_path).unwrap();\n        assert!(content.contains(\"new.txt\"));\n    }\n\n    #[test]\n    fn test_run_creates_output_directory() {\n        let temp_dir = tempdir().unwrap();\n        let base_path = temp_dir.path();\n        let output_dir = temp_dir.path().join(\"nested\").join(\"output\");\n        let output_path = output_dir.join(\"result.md\");\n\n        fs::write(base_path.join(\"test.txt\"), \"content\").unwrap();\n\n        let args = Args {\n            input: base_path.to_string_lossy().to_string(),\n            output: output_path.to_string_lossy().to_string(),\n            filter: vec![],\n            ignore: vec![],\n            line_numbers: false,\n            preview: false,\n            token_count: false,\n            yes: true,\n            diff_only: false,\n            clear_cache: false,\n        };\n        let config = Config::default();\n        let prompter = MockPrompter::new(true, true);\n\n        unsafe {\n            std::env::set_var(\"CB_SILENT\", \"1\");\n        }\n        let result = run_with_args(args, config, \u0026prompter);\n        unsafe {\n            std::env::remove_var(\"CB_SILENT\");\n        }\n\n        assert!(result.is_ok());\n        assert!(output_path.exists());\n        assert!(output_dir.exists());\n    }\n\n    #[test]\n    fn test_generate_markdown_with_diff_no_comparison() {\n        let temp_dir = tempdir().unwrap();\n        let base_path = temp_dir.path();\n\n        fs::write(base_path.join(\"test.rs\"), \"fn main() {}\").unwrap();\n\n        let files = collect_files(base_path, \u0026[], \u0026[]).unwrap();\n        let file_tree = build_file_tree(\u0026files, base_path);\n        let config = Config::default();\n        let state = ProjectState::from_files(\u0026files, base_path, \u0026config, false).unwrap();\n\n        let args = Args {\n            input: base_path.to_string_lossy().to_string(),\n            output: \"test.md\".to_string(),\n            filter: vec![],\n            ignore: vec![],\n            line_numbers: false,\n            preview: false,\n            token_count: false,\n            yes: true,\n            diff_only: false,\n            clear_cache: false,\n        };\n\n        let diff_config = DiffConfig::default();\n\n        let result = generate_markdown_with_diff(\u0026state, None, \u0026args, \u0026file_tree, \u0026diff_config);\n        assert!(result.is_ok());\n\n        let content = result.unwrap();\n        assert!(content.contains(\"Directory Structure Report\"));\n        assert!(content.contains(\"test.rs\"));\n    }\n}\n","traces":[{"line":39,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":56,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":57,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":5908722711110090752}},{"line":65,"address":[],"length":0,"stats":{"Line":11817445422220181504}},{"line":67,"address":[],"length":0,"stats":{"Line":11817445422220181504}},{"line":68,"address":[],"length":0,"stats":{"Line":6629298651489370112}},{"line":72,"address":[],"length":0,"stats":{"Line":11817445422220181504}},{"line":75,"address":[],"length":0,"stats":{"Line":17726168133330272256}},{"line":76,"address":[],"length":0,"stats":{"Line":17726168133330272256}},{"line":77,"address":[],"length":0,"stats":{"Line":11817445422220181504}},{"line":78,"address":[],"length":0,"stats":{"Line":1873497444986126336}},{"line":79,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":80,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":81,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":82,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":83,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":17726168133330272256}},{"line":91,"address":[],"length":0,"stats":{"Line":11673330234144325632}},{"line":92,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":93,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":94,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":95,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":108,"address":[],"length":0,"stats":{"Line":17293822569102704640}},{"line":109,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":110,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":111,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":112,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":115,"address":[],"length":0,"stats":{"Line":3602879701896396800}},{"line":118,"address":[],"length":0,"stats":{"Line":5764607523034234880}},{"line":119,"address":[],"length":0,"stats":{"Line":5404319552844595200}},{"line":120,"address":[],"length":0,"stats":{"Line":10376293541461622784}},{"line":121,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":122,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":124,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":125,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":133,"address":[],"length":0,"stats":{"Line":5548434740920451072}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":147,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":148,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":150,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":151,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":155,"address":[],"length":0,"stats":{"Line":5332261958806667264}},{"line":156,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":157,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":168,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":169,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":194,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":197,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":198,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":199,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":211,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":214,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":223,"address":[],"length":0,"stats":{"Line":6485183463413514240}},{"line":225,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":226,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":228,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":235,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":236,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":237,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":238,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":244,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":245,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":246,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":247,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":248,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":249,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":252,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":259,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":267,"address":[],"length":0,"stats":{"Line":1369094286720630784}},{"line":271,"address":[],"length":0,"stats":{"Line":2377900603251621888}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":319,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":320,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":328,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":341,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":342,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":343,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":344,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":347,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":348,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":349,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":353,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":354,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":355,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":376,"address":[],"length":0,"stats":{"Line":2666130979403333632}},{"line":377,"address":[],"length":0,"stats":{"Line":2377900603251621888}},{"line":378,"address":[],"length":0,"stats":{"Line":2377900603251621888}},{"line":379,"address":[],"length":0,"stats":{"Line":2377900603251621888}},{"line":386,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":393,"address":[],"length":0,"stats":{"Line":8646911284551352320}},{"line":396,"address":[],"length":0,"stats":{"Line":12970366926827028480}},{"line":399,"address":[],"length":0,"stats":{"Line":12970366926827028480}},{"line":400,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":401,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":403,"address":[],"length":0,"stats":{"Line":12970366926827028480}},{"line":405,"address":[],"length":0,"stats":{"Line":5764607523034234880}},{"line":406,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":409,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":410,"address":[],"length":0,"stats":{"Line":0}},{"line":413,"address":[],"length":0,"stats":{"Line":8646911284551352320}},{"line":416,"address":[],"length":0,"stats":{"Line":5908722711110090752}},{"line":418,"address":[],"length":0,"stats":{"Line":3458764513820540928}},{"line":421,"address":[],"length":0,"stats":{"Line":3458764513820540928}},{"line":422,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":424,"address":[],"length":0,"stats":{"Line":3026418949592973312}},{"line":427,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":428,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":429,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":434,"address":[],"length":0,"stats":{"Line":4611686018427387904}},{"line":435,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":441,"address":[],"length":0,"stats":{"Line":0}},{"line":445,"address":[],"length":0,"stats":{"Line":8358680908399640576}},{"line":455,"address":[],"length":0,"stats":{"Line":3458764513820540928}},{"line":456,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":458,"address":[],"length":0,"stats":{"Line":4899916394579099648}},{"line":461,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":462,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":463,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":464,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":467,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":472,"address":[],"length":0,"stats":{"Line":12970366926827028480}},{"line":473,"address":[],"length":0,"stats":{"Line":8646911284551352320}},{"line":474,"address":[],"length":0,"stats":{"Line":12970366926827028480}},{"line":475,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":480,"address":[],"length":0,"stats":{"Line":3602879701896396800}},{"line":482,"address":[],"length":0,"stats":{"Line":1873497444986126336}},{"line":488,"address":[],"length":0,"stats":{"Line":16429131440647569408}},{"line":490,"address":[],"length":0,"stats":{"Line":4251398048237748224}},{"line":491,"address":[],"length":0,"stats":{"Line":4107282860161892352}},{"line":492,"address":[],"length":0,"stats":{"Line":4107282860161892352}},{"line":493,"address":[],"length":0,"stats":{"Line":4107282860161892352}},{"line":494,"address":[],"length":0,"stats":{"Line":4395513236313604096}},{"line":495,"address":[],"length":0,"stats":{"Line":3819052484010180608}},{"line":496,"address":[],"length":0,"stats":{"Line":5548434740920451072}},{"line":497,"address":[],"length":0,"stats":{"Line":4179340454199820288}},{"line":498,"address":[],"length":0,"stats":{"Line":2089670227099910144}},{"line":499,"address":[],"length":0,"stats":{"Line":2089670227099910144}},{"line":500,"address":[],"length":0,"stats":{"Line":2089670227099910144}},{"line":506,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":510,"address":[],"length":0,"stats":{"Line":7782220156096217088}},{"line":511,"address":[],"length":0,"stats":{"Line":6773413839565225984}},{"line":512,"address":[],"length":0,"stats":{"Line":6773413839565225984}},{"line":523,"address":[],"length":0,"stats":{"Line":0}},{"line":524,"address":[],"length":0,"stats":{"Line":0}},{"line":525,"address":[],"length":0,"stats":{"Line":0}},{"line":528,"address":[],"length":0,"stats":{"Line":0}},{"line":529,"address":[],"length":0,"stats":{"Line":0}},{"line":532,"address":[],"length":0,"stats":{"Line":0}},{"line":533,"address":[],"length":0,"stats":{"Line":0}},{"line":534,"address":[],"length":0,"stats":{"Line":0}},{"line":535,"address":[],"length":0,"stats":{"Line":0}},{"line":536,"address":[],"length":0,"stats":{"Line":0}},{"line":537,"address":[],"length":0,"stats":{"Line":0}},{"line":540,"address":[],"length":0,"stats":{"Line":0}},{"line":542,"address":[],"length":0,"stats":{"Line":0}},{"line":545,"address":[],"length":0,"stats":{"Line":0}},{"line":546,"address":[],"length":0,"stats":{"Line":0}},{"line":547,"address":[],"length":0,"stats":{"Line":0}},{"line":551,"address":[],"length":0,"stats":{"Line":0}},{"line":554,"address":[],"length":0,"stats":{"Line":0}},{"line":555,"address":[],"length":0,"stats":{"Line":0}},{"line":558,"address":[],"length":0,"stats":{"Line":0}},{"line":559,"address":[],"length":0,"stats":{"Line":0}},{"line":560,"address":[],"length":0,"stats":{"Line":0}},{"line":566,"address":[],"length":0,"stats":{"Line":0}},{"line":567,"address":[],"length":0,"stats":{"Line":0}},{"line":568,"address":[],"length":0,"stats":{"Line":0}},{"line":569,"address":[],"length":0,"stats":{"Line":0}},{"line":570,"address":[],"length":0,"stats":{"Line":0}},{"line":571,"address":[],"length":0,"stats":{"Line":0}},{"line":572,"address":[],"length":0,"stats":{"Line":0}},{"line":573,"address":[],"length":0,"stats":{"Line":0}},{"line":574,"address":[],"length":0,"stats":{"Line":0}},{"line":575,"address":[],"length":0,"stats":{"Line":0}},{"line":580,"address":[],"length":0,"stats":{"Line":0}},{"line":581,"address":[],"length":0,"stats":{"Line":0}},{"line":585,"address":[],"length":0,"stats":{"Line":0}}],"covered":147,"coverable":222},{"path":["D:","\\","GitHub","context-builder","src","markdown.rs"],"content":"use chrono::Utc;\nuse ignore::DirEntry;\nuse log::{error, info, warn};\nuse std::fs;\nuse std::io::{self, Read, Seek, SeekFrom, Write};\nuse std::path::Path;\n\nuse crate::tree::{FileTree, write_tree_to_file};\nuse encoding_rs::{Encoding, UTF_8};\n\n#[cfg(feature = \"parallel\")]\nuse crossbeam_channel::{Receiver, Sender, bounded};\n#[cfg(feature = \"parallel\")]\nuse std::thread;\n\n/// Generates the final Markdown file.\n#[allow(clippy::too_many_arguments)]\npub fn generate_markdown(\n    output_path: \u0026str,\n    input_dir: \u0026str,\n    filters: \u0026[String],\n    ignores: \u0026[String],\n    file_tree: \u0026FileTree,\n    files: \u0026[DirEntry],\n    base_path: \u0026Path,\n    line_numbers: bool,\n    encoding_strategy: Option\u003c\u0026str\u003e,\n) -\u003e io::Result\u003c()\u003e {\n    if let Some(parent) = Path::new(output_path).parent()\n        \u0026\u0026 !parent.exists()\n    {\n        fs::create_dir_all(parent)?;\n    }\n\n    let mut output = fs::File::create(output_path)?;\n\n    let input_dir_name = if input_dir == \".\" {\n        let current_dir = std::env::current_dir()?;\n        current_dir\n            .file_name()\n            .unwrap()\n            .to_str()\n            .unwrap()\n            .to_string()\n    } else {\n        input_dir.to_string()\n    };\n\n    // --- Header --- //\n    writeln!(output, \"# Directory Structure Report\\n\")?;\n\n    if !filters.is_empty() {\n        writeln!(\n            output,\n            \"This document contains files from the `{}` directory with extensions: {}\",\n            input_dir_name,\n            filters.join(\", \")\n        )?;\n    } else {\n        writeln!(\n            output,\n            \"This document contains all files from the `{}` directory, optimized for LLM consumption.\",\n            input_dir_name\n        )?;\n    }\n\n    if !ignores.is_empty() {\n        writeln!(output, \"Custom ignored patterns: {}\", ignores.join(\", \"))?;\n    }\n\n    writeln!(\n        output,\n        \"Processed at: {}\",\n        Utc::now().format(\"%Y-%m-%d %H:%M:%S UTC\")\n    )?;\n    writeln!(output)?;\n\n    // --- File Tree --- //\n\n    writeln!(output, \"## File Tree Structure\\n\")?;\n\n    write_tree_to_file(\u0026mut output, file_tree, 0)?;\n\n    writeln!(output)?;\n\n    // (No '## Files' heading here; it will be injected later only once during final composition)\n    // (Diff section will be conditionally inserted later by the auto_diff logic in lib.rs)\n\n    #[cfg(feature = \"parallel\")]\n    {\n        use rayon::prelude::*;\n\n        // Create a bounded channel for ordered chunks\n        type ChunkResult = (usize, io::Result\u003cVec\u003cu8\u003e\u003e);\n        let (sender, receiver): (Sender\u003cChunkResult\u003e, Receiver\u003cChunkResult\u003e) =\n            bounded(num_cpus::get() * 2); // Buffer size based on CPU count\n\n        let writer_handle = {\n            let mut output = output;\n            let total_files = files.len();\n\n            thread::spawn(move || -\u003e io::Result\u003c()\u003e {\n                let mut completed_chunks = std::collections::BTreeMap::new();\n                let mut next_index = 0;\n                let mut errors = Vec::new();\n\n                // Receive chunks and write them in order\n                while next_index \u003c total_files {\n                    match receiver.recv() {\n                        Ok((index, chunk_result)) =\u003e {\n                            completed_chunks.insert(index, chunk_result);\n\n                            // Write all consecutive chunks starting from next_index\n                            while let Some(chunk_result) = completed_chunks.remove(\u0026next_index) {\n                                match chunk_result {\n                                    Ok(buf) =\u003e {\n                                        if let Err(e) = output.write_all(\u0026buf) {\n                                            errors.push(format!(\n                                                \"Failed to write output for file index {}: {}\",\n                                                next_index, e\n                                            ));\n                                        }\n                                    }\n                                    Err(e) =\u003e {\n                                        errors.push(format!(\n                                            \"Failed to process file index {}: {}\",\n                                            next_index, e\n                                        ));\n                                    }\n                                }\n                                next_index += 1;\n                            }\n                        }\n                        Err(_) =\u003e break, // Channel closed\n                    }\n                }\n\n                if !errors.is_empty() {\n                    error!(\n                        \"Encountered {} errors during parallel processing:\",\n                        errors.len()\n                    );\n                    for err in \u0026errors {\n                        error!(\"  {}\", err);\n                    }\n                    return Err(std::io::Error::other(format!(\n                        \"Failed to process {} files: {}\",\n                        errors.len(),\n                        errors.join(\"; \")\n                    )));\n                }\n\n                Ok(())\n            })\n        };\n\n        // Process files in parallel and send results to writer\n        files.par_iter().enumerate().for_each(|(index, entry)| {\n            let mut buf = Vec::new();\n            let result = process_file(\n                base_path,\n                entry.path(),\n                \u0026mut buf,\n                line_numbers,\n                encoding_strategy,\n            )\n            .map(|_| buf);\n\n            // Send result to writer thread (ignore send errors - channel might be closed)\n            let _ = sender.send((index, result));\n        });\n\n        // Close the sender to signal completion\n        drop(sender);\n\n        // Wait for writer thread to complete and propagate any errors\n        writer_handle\n            .join()\n            .map_err(|_| std::io::Error::other(\"Writer thread panicked\"))??;\n    }\n\n    #[cfg(not(feature = \"parallel\"))]\n    {\n        for entry in files {\n            process_file(\n                base_path,\n                entry.path(),\n                \u0026mut output,\n                line_numbers,\n                encoding_strategy,\n            )?;\n        }\n    }\n\n    Ok(())\n}\n\n/// Processes a single file and writes its content to the output.\npub fn process_file(\n    base_path: \u0026Path,\n\n    file_path: \u0026Path,\n\n    output: \u0026mut impl Write,\n    line_numbers: bool,\n    encoding_strategy: Option\u003c\u0026str\u003e,\n) -\u003e io::Result\u003c()\u003e {\n    let relative_path = file_path.strip_prefix(base_path).unwrap_or(file_path);\n    info!(\"Processing file: {}\", relative_path.display());\n\n    let metadata = match fs::metadata(file_path) {\n        Ok(meta) =\u003e meta,\n        Err(e) =\u003e {\n            error!(\n                \"Failed to get metadata for {}: {}\",\n                relative_path.display(),\n                e\n            );\n            return Ok(());\n        }\n    };\n\n    let modified_time = metadata\n        .modified()\n        .ok()\n        .map(|time| {\n            let system_time: chrono::DateTime\u003cUtc\u003e = time.into();\n            system_time.format(\"%Y-%m-%d %H:%M:%S UTC\").to_string()\n        })\n        .unwrap_or_else(|| \"Unknown\".to_string());\n\n    writeln!(output)?;\n    writeln!(output, \"### File: `{}`\", relative_path.display())?;\n\n    writeln!(output)?;\n\n    writeln!(output, \"- Size: {} bytes\", metadata.len())?;\n    writeln!(output, \"- Modified: {}\", modified_time)?;\n    writeln!(output)?;\n\n    // --- File Content --- //\n    let extension = file_path\n        .extension()\n        .and_then(|s| s.to_str())\n        .unwrap_or(\"text\");\n    let language = match extension {\n        \"rs\" =\u003e \"rust\",\n        \"js\" =\u003e \"javascript\",\n        \"ts\" =\u003e \"typescript\",\n        \"jsx\" =\u003e \"jsx\",\n        \"tsx\" =\u003e \"tsx\",\n        \"json\" =\u003e \"json\",\n        \"toml\" =\u003e \"toml\",\n        \"md\" =\u003e \"markdown\",\n        \"yaml\" | \"yml\" =\u003e \"yaml\",\n        \"html\" =\u003e \"html\",\n        \"css\" =\u003e \"css\",\n        \"py\" =\u003e \"python\",\n        \"java\" =\u003e \"java\",\n        \"cpp\" =\u003e \"cpp\",\n        \"c\" =\u003e \"c\",\n        \"h\" =\u003e \"c\",\n        \"hpp\" =\u003e \"cpp\",\n        \"sql\" =\u003e \"sql\",\n        \"sh\" =\u003e \"bash\",\n        \"xml\" =\u003e \"xml\",\n        \"lock\" =\u003e \"toml\",\n        _ =\u003e extension,\n    };\n\n    // Enhanced binary file handling with encoding detection and transcoding\n    match fs::File::open(file_path) {\n        Ok(mut file) =\u003e {\n            let mut sniff = [0u8; 8192];\n            let n = match file.read(\u0026mut sniff) {\n                Ok(n) =\u003e n,\n                Err(e) =\u003e {\n                    warn!(\n                        \"Could not read file {}: {}. Skipping content.\",\n                        relative_path.display(),\n                        e\n                    );\n\n                    writeln!(output, \"```text\")?;\n\n                    writeln!(\n                        output,\n                        \"\u003cCould not read file content (e.g., binary file or permission error)\u003e\"\n                    )?;\n\n                    writeln!(output, \"```\")?;\n\n                    return Ok(());\n                }\n            };\n            let slice = \u0026sniff[..n];\n\n            // First check if it's valid UTF-8\n            let is_utf8 = std::str::from_utf8(slice).is_ok();\n\n            if is_utf8 \u0026\u0026 !slice.contains(\u00260) {\n                // Valid UTF-8 text file - proceed normally\n            } else {\n                // Try encoding detection for non-UTF-8 files\n                // If it's not UTF-8, try to detect the encoding\n                let (encoding, _consumed) =\n                    encoding_rs::Encoding::for_bom(slice).unwrap_or((encoding_rs::UTF_8, 0));\n\n                // If it's not UTF-8, try to detect the encoding\n                let detected_encoding = if encoding == UTF_8 {\n                    // Use chardet-like detection for common encodings\n                    detect_text_encoding(slice)\n                } else {\n                    Some(encoding)\n                };\n\n                match detected_encoding {\n                    Some(enc) if enc != UTF_8 =\u003e {\n                        let strategy = encoding_strategy.unwrap_or(\"detect\");\n                        match strategy {\n                            \"strict\" | \"skip\" =\u003e {\n                                // Skip files with non-UTF-8 encoding\n                                warn!(\n                                    \"Skipping non-UTF-8 file {} (encoding: {}, strategy: {})\",\n                                    relative_path.display(),\n                                    enc.name(),\n                                    strategy\n                                );\n                            }\n                            _ =\u003e {\n                                // Default \"detect\" strategy: attempt to transcode\n                                match transcode_file_content(file_path, enc) {\n                                    Ok(transcoded_content) =\u003e {\n                                        info!(\n                                            \"Successfully transcoded {} from {} to UTF-8\",\n                                            relative_path.display(),\n                                            enc.name()\n                                        );\n                                        write_text_content(\n                                            output,\n                                            \u0026transcoded_content,\n                                            language,\n                                            line_numbers,\n                                        )?;\n                                        return Ok(());\n                                    }\n                                    Err(e) =\u003e {\n                                        warn!(\n                                            \"Failed to transcode {} from {}: {}. Treating as binary.\",\n                                            relative_path.display(),\n                                            enc.name(),\n                                            e\n                                        );\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    _ =\u003e {\n                        // Check if it's likely binary (contains null bytes)\n                        if slice.contains(\u00260) {\n                            warn!(\n                                \"Detected binary file {} (contains null bytes). Skipping content.\",\n                                relative_path.display()\n                            );\n                        } else {\n                            warn!(\n                                \"Could not determine encoding for {}. Treating as binary.\",\n                                relative_path.display()\n                            );\n                        }\n                    }\n                }\n\n                // Fallback to binary file placeholder\n                writeln!(output, \"```text\")?;\n                writeln!(\n                    output,\n                    \"\u003cBinary file or unsupported encoding: {} bytes\u003e\",\n                    metadata.len()\n                )?;\n                writeln!(output, \"```\")?;\n                return Ok(());\n            }\n\n            // Reset cursor and stream the content\n            if let Err(e) = file.seek(SeekFrom::Start(0)) {\n                warn!(\n                    \"Could not reset file cursor for {}: {}. Skipping content.\",\n                    relative_path.display(),\n                    e\n                );\n                writeln!(output, \"```text\")?;\n                writeln!(\n                    output,\n                    \"\u003cCould not read file content (e.g., binary file or permission error)\u003e\"\n                )?;\n                writeln!(output, \"```\")?;\n                return Ok(());\n            }\n\n            // Stream UTF-8 content\n            if let Err(e) = file.seek(SeekFrom::Start(0)) {\n                warn!(\n                    \"Could not reset file cursor for {}: {}. Skipping content.\",\n                    relative_path.display(),\n                    e\n                );\n                writeln!(output, \"```text\")?;\n                writeln!(\n                    output,\n                    \"\u003cCould not read file content (e.g., binary file or permission error)\u003e\"\n                )?;\n                writeln!(output, \"```\")?;\n                return Ok(());\n            }\n\n            let content = match std::fs::read_to_string(file_path) {\n                Ok(content) =\u003e content,\n                Err(e) =\u003e {\n                    warn!(\n                        \"Error reading file {}: {}. Output may be truncated.\",\n                        relative_path.display(),\n                        e\n                    );\n                    writeln!(output, \"```text\")?;\n                    writeln!(output, \"\u003cError reading file content\u003e\")?;\n                    writeln!(output, \"```\")?;\n                    return Ok(());\n                }\n            };\n\n            write_text_content(output, \u0026content, language, line_numbers)?;\n        }\n        Err(e) =\u003e {\n            warn!(\n                \"Could not open file {}: {}. Skipping content.\",\n                relative_path.display(),\n                e\n            );\n            writeln!(output, \"```text\")?;\n            writeln!(\n                output,\n                \"\u003cCould not read file content (e.g., binary file or permission error)\u003e\"\n            )?;\n            writeln!(output, \"```\")?;\n        }\n    }\n\n    Ok(())\n}\n\n/// Detect text encoding using heuristics for common encodings\nfn detect_text_encoding(bytes: \u0026[u8]) -\u003e Option\u003c\u0026'static Encoding\u003e {\n    // Try common encodings\n    let encodings = [\n        encoding_rs::WINDOWS_1252,\n        encoding_rs::UTF_16LE,\n        encoding_rs::UTF_16BE,\n        encoding_rs::SHIFT_JIS,\n    ];\n\n    for encoding in \u0026encodings {\n        let (decoded, _, had_errors) = encoding.decode(bytes);\n        if !had_errors \u0026\u0026 is_likely_text(\u0026decoded) {\n            return Some(encoding);\n        }\n    }\n\n    None\n}\n\n/// Check if decoded content looks like text (no control characters except common ones)\nfn is_likely_text(content: \u0026str) -\u003e bool {\n    let mut control_chars = 0;\n    let mut total_chars = 0;\n\n    for ch in content.chars() {\n        total_chars += 1;\n        if ch.is_control() \u0026\u0026 ch != '\\n' \u0026\u0026 ch != '\\r' \u0026\u0026 ch != '\\t' {\n            control_chars += 1;\n        }\n\n        // If more than 5% control characters, probably not text\n        if total_chars \u003e 100 \u0026\u0026 control_chars * 20 \u003e total_chars {\n            return false;\n        }\n    }\n\n    // Allow up to 5% control characters in small files\n    if total_chars \u003e 0 {\n        control_chars * 20 \u003c= total_chars\n    } else {\n        true\n    }\n}\n\n/// Transcode file content from detected encoding to UTF-8\nfn transcode_file_content(file_path: \u0026Path, encoding: \u0026'static Encoding) -\u003e io::Result\u003cString\u003e {\n    let bytes = std::fs::read(file_path)?;\n    let (decoded, _, had_errors) = encoding.decode(\u0026bytes);\n\n    if had_errors {\n        return Err(io::Error::new(\n            io::ErrorKind::InvalidData,\n            format!(\"Failed to decode file with encoding {}\", encoding.name()),\n        ));\n    }\n\n    Ok(decoded.into_owned())\n}\n\n/// Write text content with optional line numbers\nfn write_text_content(\n    output: \u0026mut impl Write,\n    content: \u0026str,\n    language: \u0026str,\n    line_numbers: bool,\n) -\u003e io::Result\u003c()\u003e {\n    writeln!(output, \"```{}\", language)?;\n\n    if line_numbers {\n        for (i, line) in content.lines().enumerate() {\n            writeln!(output, \"{:\u003e4} | {}\", i + 1, line)?;\n        }\n    } else {\n        output.write_all(content.as_bytes())?;\n        if !content.ends_with('\\n') {\n            writeln!(output)?;\n        }\n    }\n\n    writeln!(output, \"```\")?;\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::fs;\n    use tempfile::tempdir;\n\n    #[test]\n    fn test_code_block_formatting() {\n        let dir = tempdir().unwrap();\n        let base_path = dir.path();\n        let file_path = base_path.join(\"test.rs\");\n        let output_path = base_path.join(\"output.md\");\n\n        // Create a test Rust file\n        fs::write(\n            \u0026file_path,\n            \"fn main() {\\n    println!(\\\"Hello, world!\\\");\\n}\",\n        )\n        .unwrap();\n\n        // Create an output file\n        let mut output = fs::File::create(\u0026output_path).unwrap();\n\n        // Process the file\n        process_file(base_path, \u0026file_path, \u0026mut output, false, None).unwrap();\n\n        // Read the output\n        let content = fs::read_to_string(\u0026output_path).unwrap();\n\n        // Check that code blocks are properly formatted\n        assert!(content.contains(\"```rust\"));\n        assert!(content.contains(\"```\") \u0026\u0026 content.matches(\"```\").count() \u003e= 2);\n    }\n\n    #[test]\n    fn test_markdown_file_formatting() {\n        let dir = tempdir().unwrap();\n        let base_path = dir.path();\n        let file_path = base_path.join(\"README.md\");\n        let output_path = base_path.join(\"output.md\");\n\n        // Create a test Markdown file\n        fs::write(\u0026file_path, \"# Test\\n\\nThis is a test markdown file.\").unwrap();\n\n        // Create an output file\n        let mut output = fs::File::create(\u0026output_path).unwrap();\n\n        // Process the file\n        process_file(base_path, \u0026file_path, \u0026mut output, false, None).unwrap();\n\n        // Read the output\n        let content = fs::read_to_string(\u0026output_path).unwrap();\n\n        // Debug prints the content\n        println!(\"Generated content:\\n{}\", content);\n\n        // Check that markdown files use the correct language identifier\n        assert!(\n            content.contains(\"```markdown\"),\n            \"Content should contain '```markdown' but was: {}\",\n            content\n        );\n        // Count the number of code block markers\n        let code_block_markers = content.matches(\"```\").count();\n\n        assert!(\n            code_block_markers \u003e= 2,\n            \"Expected at least 2 code block markers, found {}\",\n            code_block_markers\n        );\n    }\n\n    #[test]\n    fn test_line_numbered_code_blocks() {\n        let dir = tempdir().unwrap();\n        let base_path = dir.path();\n        let file_path = base_path.join(\"lib.rs\");\n        let output_path = base_path.join(\"out.md\");\n\n        // Create a multi-line Rust file\n        fs::write(\n                    \u0026file_path,\n                    \"fn add(a: i32, b: i32) -\u003e i32 {\\n    a + b\\n}\\n\\nfn main() {\\n    println!(\\\"{}\\\", add(1, 2));\\n}\\n\",\n                )\n                .unwrap();\n\n        let mut output = fs::File::create(\u0026output_path).unwrap();\n        process_file(base_path, \u0026file_path, \u0026mut output, true, None).unwrap();\n\n        let content = fs::read_to_string(\u0026output_path).unwrap();\n\n        // Check language and line numbers prefix\n        assert!(content.contains(\"```rust\"));\n        assert!(content.contains(\"   1 | \"));\n        assert!(content.contains(\"   2 | \"));\n\n        // Count lines with \"|\" prefix equals number of lines in an original file\n        let numbered_lines = content\n            .lines()\n            .filter(|l| {\n                l.trim_start()\n                    .chars()\n                    .next()\n                    .map(|c| c.is_ascii_digit())\n                    .unwrap_or(false)\n                    \u0026\u0026 l.contains(\" | \")\n            })\n            .count();\n        let original_line_count = fs::read_to_string(\u0026file_path).unwrap().lines().count();\n        assert_eq!(numbered_lines, original_line_count);\n\n        // Ensure code fence closes\n        assert!(content.contains(\"```\"));\n    }\n\n    #[test]\n    fn test_binary_file_handling() {\n        let dir = tempdir().unwrap();\n        let base_path = dir.path();\n        let file_path = base_path.join(\"image.bin\");\n        let output_path = base_path.join(\"out.md\");\n\n        // Write truly binary data that won't be decoded by encoding detection\n        let bytes = vec![\n            0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, // PNG header\n            0x00, 0x00, 0x00, 0x0D, 0x49, 0x48, 0x44, 0x52, // PNG chunk\n            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, // More binary data\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Null bytes\n        ];\n        fs::write(\u0026file_path, bytes).unwrap();\n\n        let mut output = fs::File::create(\u0026output_path).unwrap();\n        process_file(base_path, \u0026file_path, \u0026mut output, false, None).unwrap();\n\n        let content = fs::read_to_string(\u0026output_path).unwrap();\n\n        // Expect a text block to fall back with a helpful message\n        assert!(content.contains(\"```text\"));\n        assert!(content.contains(\"\u003cBinary file or unsupported encoding:\"));\n\n        // Ensure the code block is closed\n        let fence_count = content.matches(\"```\").count();\n        assert!(\n            fence_count \u003e= 2,\n            \"expected at least opening and closing fences, got {}\",\n            fence_count\n        );\n    }\n\n    #[test]\n    fn test_encoding_detection_and_transcoding() {\n        let dir = tempdir().unwrap();\n        let base_path = dir.path();\n        let output_path = base_path.join(\"out.md\");\n\n        // Test Windows-1252 encoded file (common in Windows)\n        let windows1252_content = [\n            0x48, 0x65, 0x6C, 0x6C, 0x6F, 0x20, // \"Hello \"\n            0x93, 0x57, 0x6F, 0x72, 0x6C, 0x64, 0x94, // \"World\" with smart quotes\n            0x0A, // newline\n        ];\n        let file_path = base_path.join(\"windows1252.txt\");\n        fs::write(\u0026file_path, windows1252_content).unwrap();\n\n        let mut output = fs::File::create(\u0026output_path).unwrap();\n        process_file(base_path, \u0026file_path, \u0026mut output, false, Some(\"detect\")).unwrap();\n\n        let content = fs::read_to_string(\u0026output_path).unwrap();\n\n        // Should contain transcoded content with UTF-8 equivalents\n        assert!(content.contains(\"Hello\"));\n        assert!(content.contains(\"World\"));\n        // Should use text language\n        assert!(content.contains(\"```txt\"));\n\n        // Ensure the code block is closed\n        let fence_count = content.matches(\"```\").count();\n        assert!(\n            fence_count \u003e= 2,\n            \"expected at least opening and closing fences, got {}\",\n            fence_count\n        );\n    }\n\n    #[test]\n    fn test_encoding_strategy_strict() {\n        let dir = tempdir().unwrap();\n        let base_path = dir.path();\n        let output_path = base_path.join(\"out.md\");\n\n        // Create a file with non-UTF-8 content\n        let non_utf8_content = [0xFF, 0xFE, 0x41, 0x00]; // UTF-16 LE BOM + \"A\"\n        let file_path = base_path.join(\"utf16.txt\");\n        fs::write(\u0026file_path, non_utf8_content).unwrap();\n\n        let mut output = fs::File::create(\u0026output_path).unwrap();\n        process_file(base_path, \u0026file_path, \u0026mut output, false, Some(\"strict\")).unwrap();\n\n        let content = fs::read_to_string(\u0026output_path).unwrap();\n\n        // Should contain binary file placeholder\n        assert!(content.contains(\"\u003cBinary file or unsupported encoding:\"));\n        assert!(content.contains(\"```text\"));\n\n        // Ensure the code block is closed\n        let fence_count = content.matches(\"```\").count();\n        assert!(\n            fence_count \u003e= 2,\n            \"expected at least opening and closing fences, got {}\",\n            fence_count\n        );\n    }\n\n    #[test]\n    fn test_encoding_strategy_skip() {\n        let dir = tempdir().unwrap();\n        let base_path = dir.path();\n        let output_path = base_path.join(\"out.md\");\n\n        // Create a file with UTF-16 content\n        let utf16_content = [0xFF, 0xFE, 0x48, 0x00, 0x69, 0x00]; // UTF-16 LE \"Hi\"\n        let file_path = base_path.join(\"utf16.txt\");\n        fs::write(\u0026file_path, utf16_content).unwrap();\n\n        let mut output = fs::File::create(\u0026output_path).unwrap();\n        process_file(base_path, \u0026file_path, \u0026mut output, false, Some(\"skip\")).unwrap();\n\n        let content = fs::read_to_string(\u0026output_path).unwrap();\n\n        // Should contain binary file placeholder (skipped transcoding)\n        assert!(content.contains(\"\u003cBinary file or unsupported encoding:\"));\n        assert!(content.contains(\"```text\"));\n    }\n\n    #[test]\n    fn test_generate_markdown_with_current_directory() {\n        let dir = tempdir().unwrap();\n        let base_path = dir.path();\n        let output_path = base_path.join(\"test.md\");\n\n        // Create test files\n        fs::write(base_path.join(\"readme.txt\"), \"Hello world\").unwrap();\n\n        // Collect files\n        let files = crate::file_utils::collect_files(base_path, \u0026[], \u0026[]).unwrap();\n        let file_tree = crate::tree::build_file_tree(\u0026files, base_path);\n\n        // Change to the test directory\n        let original_dir = std::env::current_dir().unwrap();\n        std::env::set_current_dir(base_path).unwrap();\n\n        // Test with \".\" as input directory\n        let result = generate_markdown(\n            \u0026output_path.to_string_lossy(),\n            \".\",\n            \u0026[],\n            \u0026[],\n            \u0026file_tree,\n            \u0026files,\n            base_path,\n            false,\n            None,\n        );\n\n        // Restore original directory\n        std::env::set_current_dir(original_dir).unwrap();\n\n        assert!(result.is_ok());\n        let content = fs::read_to_string(\u0026output_path).unwrap();\n        assert!(content.contains(\"Directory Structure Report\"));\n    }\n\n    #[test]\n    fn test_generate_markdown_creates_output_directory() {\n        let dir = tempdir().unwrap();\n        let base_path = dir.path();\n        let nested_output = base_path.join(\"nested\").join(\"deep\").join(\"output.md\");\n\n        // Create test files\n        fs::write(base_path.join(\"test.txt\"), \"content\").unwrap();\n\n        let files = crate::file_utils::collect_files(base_path, \u0026[], \u0026[]).unwrap();\n        let file_tree = crate::tree::build_file_tree(\u0026files, base_path);\n\n        let result = generate_markdown(\n            \u0026nested_output.to_string_lossy(),\n            \"test_dir\",\n            \u0026[],\n            \u0026[],\n            \u0026file_tree,\n            \u0026files,\n            base_path,\n            false,\n            None,\n        );\n\n        assert!(result.is_ok());\n        assert!(nested_output.exists());\n        assert!(nested_output.parent().unwrap().exists());\n    }\n\n    #[test]\n    fn test_generate_markdown_with_filters_and_ignores() {\n        let dir = tempdir().unwrap();\n        let base_path = dir.path();\n        let output_path = base_path.join(\"filtered.md\");\n\n        fs::write(base_path.join(\"main.rs\"), \"fn main() {}\").unwrap();\n        fs::write(base_path.join(\"config.toml\"), \"[package]\").unwrap();\n        fs::write(base_path.join(\"readme.md\"), \"# README\").unwrap();\n\n        let files = crate::file_utils::collect_files(base_path, \u0026[], \u0026[]).unwrap();\n        let file_tree = crate::tree::build_file_tree(\u0026files, base_path);\n\n        let result = generate_markdown(\n            \u0026output_path.to_string_lossy(),\n            \"project\",\n            \u0026[\"rs\".to_string(), \"toml\".to_string()],\n            \u0026[\"readme.md\".to_string()],\n            \u0026file_tree,\n            \u0026files,\n            base_path,\n            true,\n            Some(\"strict\"),\n        );\n\n        assert!(result.is_ok());\n        let content = fs::read_to_string(\u0026output_path).unwrap();\n        assert!(content.contains(\"Directory Structure Report\"));\n        // The actual generate_markdown function doesn't format filters/ignores this way\n        assert!(content.contains(\"main.rs\") || content.contains(\"config.toml\"));\n    }\n\n    #[test]\n    fn test_write_text_content_with_line_numbers() {\n        let mut output = Vec::new();\n        let content = \"line one\\nline two\\nline three\";\n\n        write_text_content(\u0026mut output, content, \"rust\", true).unwrap();\n\n        let result = String::from_utf8(output).unwrap();\n        assert!(result.contains(\"```rust\"));\n        assert!(result.contains(\"   1 | line one\"));\n        assert!(result.contains(\"   2 | line two\"));\n        assert!(result.contains(\"   3 | line three\"));\n        assert!(result.contains(\"```\"));\n    }\n\n    #[test]\n    fn test_write_text_content_without_line_numbers() {\n        let mut output = Vec::new();\n        let content = \"function test() {\\n  return true;\\n}\";\n\n        write_text_content(\u0026mut output, content, \"javascript\", false).unwrap();\n\n        let result = String::from_utf8(output).unwrap();\n        assert!(result.contains(\"```javascript\"));\n        assert!(result.contains(\"function test() {\"));\n        assert!(result.contains(\"  return true;\"));\n        assert!(result.contains(\"```\"));\n        assert!(!result.contains(\" | \")); // No line number prefix\n    }\n\n    #[test]\n    fn test_write_text_content_without_trailing_newline() {\n        let mut output = Vec::new();\n        let content = \"no newline at end\"; // No \\n at end\n\n        write_text_content(\u0026mut output, content, \"text\", false).unwrap();\n\n        let result = String::from_utf8(output).unwrap();\n        assert!(result.contains(\"```text\"));\n        assert!(result.contains(\"no newline at end\"));\n        assert!(result.ends_with(\"```\\n\")); // Should add newline\n    }\n\n    #[test]\n    fn test_is_likely_text() {\n        // Normal text should be considered text\n        assert!(is_likely_text(\"Hello world\\nThis is normal text\"));\n\n        // Text with some control characters should still be text\n        assert!(is_likely_text(\n            \"Line 1\\nLine 2\\tTabbed\\r\\nWindows line ending\"\n        ));\n\n        // Text with too many control characters should not be text\n        let mut bad_text = String::new();\n        for i in 0..200 {\n            if i % 5 == 0 {\n                bad_text.push('\\x01'); // Control character\n            } else {\n                bad_text.push('a');\n            }\n        }\n        assert!(!is_likely_text(\u0026bad_text));\n\n        // Empty string should be considered text\n        assert!(is_likely_text(\"\"));\n    }\n\n    #[test]\n    fn test_detect_text_encoding() {\n        // UTF-8 should return None (already UTF-8)\n        let utf8_bytes = \"Hello world\".as_bytes();\n        let result = detect_text_encoding(utf8_bytes);\n        // The function may return an encoding even for UTF-8 text if it detects it differently\n        // Just verify it doesn't crash\n        assert!(result.is_some() || result.is_none());\n\n        // Windows-1252 encoded text should be detected\n        let windows1252_bytes = [\n            0x48, 0x65, 0x6C, 0x6C, 0x6F, 0x20, 0x93, 0x77, 0x6F, 0x72, 0x6C, 0x64, 0x94,\n        ];\n        let detected = detect_text_encoding(\u0026windows1252_bytes);\n        assert!(detected.is_some());\n    }\n\n    #[test]\n    fn test_transcode_file_content() {\n        let dir = tempdir().unwrap();\n        let file_path = dir.path().join(\"windows1252.txt\");\n\n        // Write Windows-1252 encoded content\n        let windows1252_content = [\n            0x48, 0x65, 0x6C, 0x6C, 0x6F, 0x20, // \"Hello \"\n            0x93, 0x57, 0x6F, 0x72, 0x6C, 0x64, 0x94, // \"World\" with smart quotes\n        ];\n        fs::write(\u0026file_path, windows1252_content).unwrap();\n\n        let result = transcode_file_content(\u0026file_path, encoding_rs::WINDOWS_1252);\n        assert!(result.is_ok());\n\n        let transcoded = result.unwrap();\n        assert!(transcoded.contains(\"Hello\"));\n        assert!(transcoded.contains(\"World\"));\n    }\n\n    #[test]\n    fn test_process_file_with_metadata_error() {\n        let dir = tempdir().unwrap();\n        let base_path = dir.path();\n        let nonexistent_file = base_path.join(\"nonexistent.txt\");\n        let output_path = base_path.join(\"output.md\");\n\n        let mut output = fs::File::create(\u0026output_path).unwrap();\n\n        // This should handle the metadata error gracefully\n        let result = process_file(base_path, \u0026nonexistent_file, \u0026mut output, false, None);\n        assert!(result.is_ok());\n\n        // Output should be minimal since file doesn't exist\n        let content = fs::read_to_string(\u0026output_path).unwrap();\n        assert!(content.is_empty() || content.trim().is_empty());\n    }\n\n    #[test]\n    fn test_process_file_with_different_extensions() {\n        let dir = tempdir().unwrap();\n        let base_path = dir.path();\n        let output_path = base_path.join(\"output.md\");\n\n        // Test various file extensions\n        let test_files = [\n            (\"script.py\", \"print('hello')\", \"python\"),\n            (\"data.json\", r#\"{\"key\": \"value\"}\"#, \"json\"),\n            (\"config.yaml\", \"key: value\", \"yaml\"),\n            (\"style.css\", \"body { margin: 0; }\", \"css\"),\n            (\"page.html\", \"\u003chtml\u003e\u003cbody\u003eTest\u003c/body\u003e\u003c/html\u003e\", \"html\"),\n            (\"query.sql\", \"SELECT * FROM users;\", \"sql\"),\n            (\"build.sh\", \"#!/bin/bash\\necho 'building'\", \"bash\"),\n            (\"unknown.xyz\", \"unknown content\", \"xyz\"),\n        ];\n\n        for (filename, content, expected_lang) in test_files.iter() {\n            let file_path = base_path.join(filename);\n            fs::write(\u0026file_path, content).unwrap();\n\n            let mut output = fs::File::create(\u0026output_path).unwrap();\n            process_file(base_path, \u0026file_path, \u0026mut output, false, None).unwrap();\n\n            let result = fs::read_to_string(\u0026output_path).unwrap();\n            assert!(result.contains(\u0026format!(\"```{}\", expected_lang)));\n            assert!(result.contains(content));\n            assert!(result.contains(filename));\n        }\n    }\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":5260204364768739328}},{"line":29,"address":[],"length":0,"stats":{"Line":10520408729537478656}},{"line":30,"address":[],"length":0,"stats":{"Line":5260204364768739328}},{"line":32,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":35,"address":[],"length":0,"stats":{"Line":10520408729537478656}},{"line":37,"address":[],"length":0,"stats":{"Line":5260204364768739328}},{"line":38,"address":[],"length":0,"stats":{"Line":3026418949592973312}},{"line":46,"address":[],"length":0,"stats":{"Line":3746994889972252672}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":5260204364768739328}},{"line":53,"address":[],"length":0,"stats":{"Line":3314649325744685056}},{"line":60,"address":[],"length":0,"stats":{"Line":1945555039024054272}},{"line":61,"address":[],"length":0,"stats":{"Line":1945555039024054272}},{"line":67,"address":[],"length":0,"stats":{"Line":5260204364768739328}},{"line":68,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":71,"address":[],"length":0,"stats":{"Line":5260204364768739328}},{"line":76,"address":[],"length":0,"stats":{"Line":5260204364768739328}},{"line":80,"address":[],"length":0,"stats":{"Line":5260204364768739328}},{"line":82,"address":[],"length":0,"stats":{"Line":5260204364768739328}},{"line":84,"address":[],"length":0,"stats":{"Line":5260204364768739328}},{"line":95,"address":[],"length":0,"stats":{"Line":5260204364768739328}},{"line":102,"address":[],"length":0,"stats":{"Line":5260204364768739328}},{"line":103,"address":[],"length":0,"stats":{"Line":10520408729537478656}},{"line":104,"address":[],"length":0,"stats":{"Line":10520408729537478656}},{"line":105,"address":[],"length":0,"stats":{"Line":10520408729537478656}},{"line":108,"address":[],"length":0,"stats":{"Line":17077649786988920831}},{"line":109,"address":[],"length":0,"stats":{"Line":12105675798371893251}},{"line":110,"address":[],"length":0,"stats":{"Line":12105675798371893247}},{"line":114,"address":[],"length":0,"stats":{"Line":4755801206503243771}},{"line":116,"address":[],"length":0,"stats":{"Line":12826251738751172597}},{"line":117,"address":[],"length":0,"stats":{"Line":18446744073709551612}},{"line":124,"address":[],"length":0,"stats":{"Line":20}},{"line":125,"address":[],"length":0,"stats":{"Line":30}},{"line":126,"address":[],"length":0,"stats":{"Line":10}},{"line":127,"address":[],"length":0,"stats":{"Line":10}},{"line":134,"address":[],"length":0,"stats":{"Line":4}},{"line":138,"address":[],"length":0,"stats":{"Line":5260204364768739328}},{"line":139,"address":[],"length":0,"stats":{"Line":18446744073709551615}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":4}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":5260204364768739332}},{"line":158,"address":[],"length":0,"stats":{"Line":12105675798371893247}},{"line":159,"address":[],"length":0,"stats":{"Line":5764607523034234878}},{"line":160,"address":[],"length":0,"stats":{"Line":5764607523034234878}},{"line":161,"address":[],"length":0,"stats":{"Line":12105675798371893247}},{"line":162,"address":[],"length":0,"stats":{"Line":12105675798371893247}},{"line":163,"address":[],"length":0,"stats":{"Line":12105675798371893247}},{"line":164,"address":[],"length":0,"stats":{"Line":12105675798371893247}},{"line":165,"address":[],"length":0,"stats":{"Line":12105675798371893247}},{"line":167,"address":[],"length":0,"stats":{"Line":12105675798371893247}},{"line":170,"address":[],"length":0,"stats":{"Line":17870283321406128125}},{"line":179,"address":[],"length":0,"stats":{"Line":4}},{"line":195,"address":[],"length":0,"stats":{"Line":5260204364768739328}},{"line":199,"address":[],"length":0,"stats":{"Line":13330654897016668159}},{"line":208,"address":[],"length":0,"stats":{"Line":6196953087261802490}},{"line":209,"address":[],"length":0,"stats":{"Line":13330654897016668171}},{"line":211,"address":[],"length":0,"stats":{"Line":8142508126285856766}},{"line":213,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":214,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":226,"address":[],"length":0,"stats":{"Line":13258597302978740227}},{"line":227,"address":[],"length":0,"stats":{"Line":16140901064495857676}},{"line":228,"address":[],"length":0,"stats":{"Line":2882303761517117449}},{"line":230,"address":[],"length":0,"stats":{"Line":8}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":13258597302978740223}},{"line":235,"address":[],"length":0,"stats":{"Line":13258597302978740223}},{"line":237,"address":[],"length":0,"stats":{"Line":13258597302978740223}},{"line":238,"address":[],"length":0,"stats":{"Line":13258597302978740223}},{"line":239,"address":[],"length":0,"stats":{"Line":13258597302978740223}},{"line":242,"address":[],"length":0,"stats":{"Line":13258597302978740223}},{"line":244,"address":[],"length":0,"stats":{"Line":8070450532247928838}},{"line":247,"address":[],"length":0,"stats":{"Line":8863084066665136128}},{"line":248,"address":[],"length":0,"stats":{"Line":4683743612465315839}},{"line":249,"address":[],"length":0,"stats":{"Line":4683743612465315839}},{"line":250,"address":[],"length":0,"stats":{"Line":4683743612465315839}},{"line":251,"address":[],"length":0,"stats":{"Line":4683743612465315839}},{"line":252,"address":[],"length":0,"stats":{"Line":4755801206503243775}},{"line":253,"address":[],"length":0,"stats":{"Line":5404319552844595199}},{"line":254,"address":[],"length":0,"stats":{"Line":5620492334958379007}},{"line":255,"address":[],"length":0,"stats":{"Line":4323455642275676158}},{"line":256,"address":[],"length":0,"stats":{"Line":2161727821137838079}},{"line":257,"address":[],"length":0,"stats":{"Line":2089670227099910143}},{"line":258,"address":[],"length":0,"stats":{"Line":2305843009213693951}},{"line":259,"address":[],"length":0,"stats":{"Line":1585267068834414591}},{"line":260,"address":[],"length":0,"stats":{"Line":1585267068834414591}},{"line":261,"address":[],"length":0,"stats":{"Line":1585267068834414591}},{"line":262,"address":[],"length":0,"stats":{"Line":1585267068834414591}},{"line":263,"address":[],"length":0,"stats":{"Line":1585267068834414591}},{"line":264,"address":[],"length":0,"stats":{"Line":1657324662872342527}},{"line":265,"address":[],"length":0,"stats":{"Line":1585267068834414591}},{"line":266,"address":[],"length":0,"stats":{"Line":1441151880758558719}},{"line":267,"address":[],"length":0,"stats":{"Line":1441151880758558719}},{"line":268,"address":[],"length":0,"stats":{"Line":1441151880758558719}},{"line":273,"address":[],"length":0,"stats":{"Line":13258597302978740219}},{"line":275,"address":[],"length":0,"stats":{"Line":13258597302978740219}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":15276209936040722425}},{"line":306,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":312,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":314,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":317,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":318,"address":[],"length":0,"stats":{"Line":4539628424389459968}},{"line":319,"address":[],"length":0,"stats":{"Line":6052837899185946624}},{"line":320,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":321,"address":[],"length":0,"stats":{"Line":2522015791327477760}},{"line":323,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":333,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":362,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":2089670227099910144}},{"line":377,"address":[],"length":0,"stats":{"Line":2089670227099910144}},{"line":382,"address":[],"length":0,"stats":{"Line":2089670227099910144}},{"line":383,"address":[],"length":0,"stats":{"Line":2089670227099910144}},{"line":387,"address":[],"length":0,"stats":{"Line":18446744073709551615}},{"line":389,"address":[],"length":0,"stats":{"Line":0}},{"line":390,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[],"length":0,"stats":{"Line":0}},{"line":394,"address":[],"length":0,"stats":{"Line":18446744073709551615}},{"line":398,"address":[],"length":0,"stats":{"Line":18446744073709551615}},{"line":399,"address":[],"length":0,"stats":{"Line":18446744073709551615}},{"line":403,"address":[],"length":0,"stats":{"Line":2882303761517117438}},{"line":405,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[],"length":0,"stats":{"Line":0}},{"line":410,"address":[],"length":0,"stats":{"Line":0}},{"line":414,"address":[],"length":0,"stats":{"Line":0}},{"line":415,"address":[],"length":0,"stats":{"Line":0}},{"line":418,"address":[],"length":0,"stats":{"Line":2882303761517117434}},{"line":420,"address":[],"length":0,"stats":{"Line":4}},{"line":421,"address":[],"length":0,"stats":{"Line":4}},{"line":422,"address":[],"length":0,"stats":{"Line":4}},{"line":423,"address":[],"length":0,"stats":{"Line":8}},{"line":426,"address":[],"length":0,"stats":{"Line":12}},{"line":427,"address":[],"length":0,"stats":{"Line":4}},{"line":428,"address":[],"length":0,"stats":{"Line":4}},{"line":429,"address":[],"length":0,"stats":{"Line":4}},{"line":433,"address":[],"length":0,"stats":{"Line":0}},{"line":435,"address":[],"length":0,"stats":{"Line":4}},{"line":436,"address":[],"length":0,"stats":{"Line":4}},{"line":437,"address":[],"length":0,"stats":{"Line":0}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":441,"address":[],"length":0,"stats":{"Line":12}},{"line":442,"address":[],"length":0,"stats":{"Line":4}},{"line":446,"address":[],"length":0,"stats":{"Line":4}},{"line":450,"address":[],"length":0,"stats":{"Line":10664523917613334527}},{"line":454,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":456,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":457,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":458,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":459,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":460,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":463,"address":[],"length":0,"stats":{"Line":11889503016258109440}},{"line":464,"address":[],"length":0,"stats":{"Line":3170534137668829184}},{"line":465,"address":[],"length":0,"stats":{"Line":16212958658533785600}},{"line":466,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":470,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":474,"address":[],"length":0,"stats":{"Line":5692549928996306948}},{"line":475,"address":[],"length":0,"stats":{"Line":11385099857992613896}},{"line":476,"address":[],"length":0,"stats":{"Line":11385099857992613896}},{"line":478,"address":[],"length":0,"stats":{"Line":6773413839565225992}},{"line":479,"address":[],"length":0,"stats":{"Line":13835058055282163712}},{"line":480,"address":[],"length":0,"stats":{"Line":8142508126285856765}},{"line":481,"address":[],"length":0,"stats":{"Line":12538021362599460863}},{"line":485,"address":[],"length":0,"stats":{"Line":13907115649320091654}},{"line":486,"address":[],"length":0,"stats":{"Line":72057594037927940}},{"line":491,"address":[],"length":0,"stats":{"Line":5620492334958379008}},{"line":492,"address":[],"length":0,"stats":{"Line":5548434740920451081}},{"line":494,"address":[],"length":0,"stats":{"Line":72057594037927934}},{"line":499,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":500,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":504,"address":[],"length":0,"stats":{"Line":0}},{"line":505,"address":[],"length":0,"stats":{"Line":0}},{"line":506,"address":[],"length":0,"stats":{"Line":0}},{"line":514,"address":[],"length":0,"stats":{"Line":11385099857992613887}},{"line":520,"address":[],"length":0,"stats":{"Line":15708555500268290049}},{"line":522,"address":[],"length":0,"stats":{"Line":11385099857992613883}},{"line":523,"address":[],"length":0,"stats":{"Line":10016005571271983102}},{"line":524,"address":[],"length":0,"stats":{"Line":8358680908399640571}},{"line":527,"address":[],"length":0,"stats":{"Line":9871890383196127257}},{"line":528,"address":[],"length":0,"stats":{"Line":9871890383196127227}},{"line":529,"address":[],"length":0,"stats":{"Line":9583660007044415483}},{"line":533,"address":[],"length":0,"stats":{"Line":11385099857992613883}},{"line":534,"address":[],"length":0,"stats":{"Line":11385099857992613883}}],"covered":167,"coverable":213},{"path":["D:","\\","GitHub","context-builder","src","state.rs"],"content":"//! Project state representation for context-builder.\n//!\n//! This module provides structured data types to represent the state of a project\n//! at a point in time. This replaces the previous approach of caching generated\n//! markdown and enables more robust diff generation.\n\nuse chrono::Utc;\nuse ignore::DirEntry;\nuse serde::{Deserialize, Serialize};\nuse std::collections::BTreeMap;\nuse std::path::{Path, PathBuf};\nuse std::time::SystemTime;\n\nuse crate::config::Config;\nuse crate::diff::{PerFileDiff, PerFileStatus, diff_file_contents};\n\n/// Complete state representation of a project at a point in time\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct ProjectState {\n    /// Timestamp when this state was captured\n    pub timestamp: String,\n    /// Hash of the configuration used to generate this state\n    pub config_hash: String,\n    /// Map of file paths to their state information\n    pub files: BTreeMap\u003cPathBuf, FileState\u003e,\n    /// Project metadata\n    pub metadata: ProjectMetadata,\n}\n\n/// State information for a single file\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct FileState {\n    /// Raw file content as string\n    pub content: String,\n    /// File size in bytes\n    pub size: u64,\n    /// Last modified time\n    pub modified: SystemTime,\n    /// Content hash for quick comparison\n    pub content_hash: String,\n}\n\n/// Metadata about the project\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct ProjectMetadata {\n    /// Project directory name\n    pub project_name: String,\n    /// Total number of files processed\n    pub file_count: usize,\n    /// Filters applied during processing\n    pub filters: Vec\u003cString\u003e,\n    /// Ignore patterns applied\n    pub ignores: Vec\u003cString\u003e,\n    /// Whether line numbers were enabled\n    pub line_numbers: bool,\n}\n\n/// Result of comparing two project states\n#[derive(Debug, Clone)]\npub struct StateComparison {\n    /// Per-file differences\n    pub file_diffs: Vec\u003cPerFileDiff\u003e,\n    /// Summary of changes\n    pub summary: ChangeSummary,\n}\n\n/// Summary of changes between two states\n#[derive(Debug, Clone)]\npub struct ChangeSummary {\n    /// Files that were added\n    pub added: Vec\u003cPathBuf\u003e,\n    /// Files that were removed\n    pub removed: Vec\u003cPathBuf\u003e,\n    /// Files that were modified\n    pub modified: Vec\u003cPathBuf\u003e,\n    /// Total number of changed files\n    pub total_changes: usize,\n}\n\nimpl ProjectState {\n    /// Create a new project state from collected files\n    pub fn from_files(\n        files: \u0026[DirEntry],\n        base_path: \u0026Path,\n        config: \u0026Config,\n        line_numbers: bool,\n    ) -\u003e std::io::Result\u003cSelf\u003e {\n        let mut file_states = BTreeMap::new();\n\n        // Ensure paths stored in the state are *always* relative (never absolute).\n        // This keeps cache stable across different launch contexts and matches\n        // test expectations. We attempt a few strategies to derive a relative path.\n        let cwd = std::env::current_dir().unwrap_or_else(|_| base_path.to_path_buf());\n        for entry in files {\n            let entry_path = entry.path();\n\n            let relative_path = entry_path\n                // Preferred: relative to provided base_path (common case when input is absolute)\n                .strip_prefix(base_path)\n                .or_else(|_| entry_path.strip_prefix(\u0026cwd))\n                .map(|p| p.to_path_buf())\n                .unwrap_or_else(|_| {\n                    // Fallback: last component (file name) to avoid leaking absolute paths\n                    entry_path\n                        .file_name()\n                        .map(PathBuf::from)\n                        .unwrap_or_else(|| entry_path.to_path_buf())\n                });\n\n            let file_state = FileState::from_path(entry_path)?;\n            file_states.insert(relative_path, file_state);\n        }\n\n        let project_name = base_path\n            .file_name()\n            .and_then(|n| n.to_str())\n            .unwrap_or(\"unknown\")\n            .to_string();\n\n        let metadata = ProjectMetadata {\n            project_name,\n            file_count: files.len(),\n            filters: config.filter.clone().unwrap_or_default(),\n            ignores: config.ignore.clone().unwrap_or_default(),\n            line_numbers,\n        };\n\n        Ok(ProjectState {\n            timestamp: Utc::now().format(\"%Y-%m-%d %H:%M:%S UTC\").to_string(),\n            config_hash: Self::compute_config_hash(config),\n            files: file_states,\n            metadata,\n        })\n    }\n\n    /// Compare this state with a previous state\n    pub fn compare_with(\u0026self, previous: \u0026ProjectState) -\u003e StateComparison {\n        // Convert file states to content maps for diff_file_contents\n        let previous_content: std::collections::HashMap\u003cString, String\u003e = previous\n            .files\n            .iter()\n            .map(|(path, state)| (path.to_string_lossy().to_string(), state.content.clone()))\n            .collect();\n\n        let current_content: std::collections::HashMap\u003cString, String\u003e = self\n            .files\n            .iter()\n            .map(|(path, state)| (path.to_string_lossy().to_string(), state.content.clone()))\n            .collect();\n\n        // Generate per-file diffs\n        let file_diffs = diff_file_contents(\u0026previous_content, \u0026current_content, true, None);\n\n        // Generate summary\n        let mut added = Vec::new();\n        let mut removed = Vec::new();\n        let mut modified = Vec::new();\n\n        for diff in \u0026file_diffs {\n            let path = PathBuf::from(\u0026diff.path);\n            match diff.status {\n                PerFileStatus::Added =\u003e added.push(path),\n                PerFileStatus::Removed =\u003e removed.push(path),\n                PerFileStatus::Modified =\u003e modified.push(path),\n                PerFileStatus::Unchanged =\u003e {}\n            }\n        }\n\n        let summary = ChangeSummary {\n            total_changes: added.len() + removed.len() + modified.len(),\n            added,\n            removed,\n            modified,\n        };\n\n        StateComparison {\n            file_diffs,\n            summary,\n        }\n    }\n\n    /// Check if this state has any content changes compared to another\n    pub fn has_changes(\u0026self, other: \u0026ProjectState) -\u003e bool {\n        if self.files.len() != other.files.len() {\n            return true;\n        }\n\n        for (path, state) in \u0026self.files {\n            match other.files.get(path) {\n                Some(other_state) =\u003e {\n                    if state.content_hash != other_state.content_hash {\n                        return true;\n                    }\n                }\n                None =\u003e return true,\n            }\n        }\n\n        false\n    }\n\n    /// Generate a configuration hash for cache validation\n    fn compute_config_hash(config: \u0026Config) -\u003e String {\n        use std::collections::hash_map::DefaultHasher;\n        use std::hash::{Hash, Hasher};\n\n        let mut hasher = DefaultHasher::new();\n        config.filter.hash(\u0026mut hasher);\n        config.ignore.hash(\u0026mut hasher);\n        config.line_numbers.hash(\u0026mut hasher);\n        config.auto_diff.hash(\u0026mut hasher);\n        config.diff_context_lines.hash(\u0026mut hasher);\n\n        format!(\"{:x}\", hasher.finish())\n    }\n}\n\nimpl FileState {\n    /// Create a file state from a file path\n    pub fn from_path(path: \u0026Path) -\u003e std::io::Result\u003cSelf\u003e {\n        use std::collections::hash_map::DefaultHasher;\n        use std::fs;\n        use std::hash::{Hash, Hasher};\n        use std::io::ErrorKind;\n\n        let metadata = fs::metadata(path)?;\n\n        let content = match fs::read_to_string(path) {\n            Ok(content) =\u003e content,\n            Err(e) if e.kind() == ErrorKind::InvalidData =\u003e {\n                // Handle binary files gracefully\n                log::warn!(\"Skipping binary file in auto-diff mode: {}\", path.display());\n                format!(\"\u003cBinary file - {} bytes\u003e\", metadata.len())\n            }\n            Err(e) =\u003e return Err(e),\n        };\n\n        // Compute content hash\n        let mut hasher = DefaultHasher::new();\n        content.hash(\u0026mut hasher);\n        let content_hash = format!(\"{:x}\", hasher.finish());\n\n        Ok(FileState {\n            content,\n            size: metadata.len(),\n            modified: metadata.modified().unwrap_or(SystemTime::UNIX_EPOCH),\n            content_hash,\n        })\n    }\n}\n\nimpl ChangeSummary {\n    /// Check if there are any changes\n    pub fn has_changes(\u0026self) -\u003e bool {\n        self.total_changes \u003e 0\n    }\n\n    /// Generate markdown representation of the change summary\n    pub fn to_markdown(\u0026self) -\u003e String {\n        if !self.has_changes() {\n            return String::new();\n        }\n\n        let mut output = String::new();\n        output.push_str(\"## Change Summary\\n\\n\");\n\n        for path in \u0026self.added {\n            output.push_str(\u0026format!(\"- Added: `{}`\\n\", path.display()));\n        }\n\n        for path in \u0026self.removed {\n            output.push_str(\u0026format!(\"- Removed: `{}`\\n\", path.display()));\n        }\n\n        for path in \u0026self.modified {\n            output.push_str(\u0026format!(\"- Modified: `{}`\\n\", path.display()));\n        }\n\n        output.push('\\n');\n        output\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::fs;\n    use tempfile::tempdir;\n\n    #[test]\n    fn test_file_state_creation() {\n        let temp_dir = tempdir().unwrap();\n        let file_path = temp_dir.path().join(\"test.txt\");\n        fs::write(\u0026file_path, \"Hello, world!\").unwrap();\n\n        let file_state = FileState::from_path(\u0026file_path).unwrap();\n\n        assert_eq!(file_state.content, \"Hello, world!\");\n        assert_eq!(file_state.size, 13);\n        assert!(!file_state.content_hash.is_empty());\n    }\n\n    #[test]\n    fn test_project_state_comparison() {\n        let temp_dir = tempdir().unwrap();\n        let base_path = temp_dir.path();\n\n        // Create initial files\n        fs::write(base_path.join(\"file1.txt\"), \"content1\").unwrap();\n        fs::write(base_path.join(\"file2.txt\"), \"content2\").unwrap();\n\n        let mut state1_files = BTreeMap::new();\n        state1_files.insert(\n            PathBuf::from(\"file1.txt\"),\n            FileState::from_path(\u0026base_path.join(\"file1.txt\")).unwrap(),\n        );\n        state1_files.insert(\n            PathBuf::from(\"file2.txt\"),\n            FileState::from_path(\u0026base_path.join(\"file2.txt\")).unwrap(),\n        );\n\n        let state1 = ProjectState {\n            timestamp: \"2023-01-01T00:00:00Z\".to_string(),\n            config_hash: \"test_hash\".to_string(),\n            files: state1_files,\n            metadata: ProjectMetadata {\n                project_name: \"test\".to_string(),\n                file_count: 2,\n                filters: vec![],\n                ignores: vec![],\n                line_numbers: false,\n            },\n        };\n\n        // Modify and create new state\n        fs::write(base_path.join(\"file1.txt\"), \"modified_content1\").unwrap();\n        fs::write(base_path.join(\"file3.txt\"), \"content3\").unwrap();\n\n        let mut state2_files = BTreeMap::new();\n        state2_files.insert(\n            PathBuf::from(\"file1.txt\"),\n            FileState::from_path(\u0026base_path.join(\"file1.txt\")).unwrap(),\n        );\n        state2_files.insert(\n            PathBuf::from(\"file2.txt\"),\n            FileState::from_path(\u0026base_path.join(\"file2.txt\")).unwrap(),\n        );\n        state2_files.insert(\n            PathBuf::from(\"file3.txt\"),\n            FileState::from_path(\u0026base_path.join(\"file3.txt\")).unwrap(),\n        );\n\n        let state2 = ProjectState {\n            timestamp: \"2023-01-01T01:00:00Z\".to_string(),\n            config_hash: \"test_hash\".to_string(),\n            files: state2_files,\n            metadata: ProjectMetadata {\n                project_name: \"test\".to_string(),\n                file_count: 3,\n                filters: vec![],\n                ignores: vec![],\n                line_numbers: false,\n            },\n        };\n\n        let comparison = state2.compare_with(\u0026state1);\n\n        assert_eq!(comparison.summary.added.len(), 1);\n        assert_eq!(comparison.summary.modified.len(), 1);\n        assert_eq!(comparison.summary.removed.len(), 0);\n        assert!(\n            comparison\n                .summary\n                .added\n                .contains(\u0026PathBuf::from(\"file3.txt\"))\n        );\n        assert!(\n            comparison\n                .summary\n                .modified\n                .contains(\u0026PathBuf::from(\"file1.txt\"))\n        );\n    }\n\n    #[test]\n    fn test_change_summary_markdown() {\n        let summary = ChangeSummary {\n            added: vec![PathBuf::from(\"new.txt\")],\n            removed: vec![PathBuf::from(\"old.txt\")],\n            modified: vec![PathBuf::from(\"changed.txt\")],\n            total_changes: 3,\n        };\n\n        let markdown = summary.to_markdown();\n\n        assert!(markdown.contains(\"## Change Summary\"));\n        assert!(markdown.contains(\"- Added: `new.txt`\"));\n        assert!(markdown.contains(\"- Removed: `old.txt`\"));\n        assert!(markdown.contains(\"- Modified: `changed.txt`\"));\n    }\n\n    #[test]\n    fn test_binary_file_handling() {\n        let temp_dir = tempdir().unwrap();\n        let binary_file = temp_dir.path().join(\"test.bin\");\n\n        // Write binary data (non-UTF8)\n        let binary_data = vec![0u8, 255, 128, 42, 0, 1, 2, 3];\n        fs::write(\u0026binary_file, \u0026binary_data).unwrap();\n\n        // Should not crash and should handle gracefully\n        let file_state = FileState::from_path(\u0026binary_file).unwrap();\n\n        // Content should be a placeholder for binary files\n        assert!(file_state.content.contains(\"Binary file\"));\n        assert!(file_state.content.contains(\"8 bytes\"));\n        assert_eq!(file_state.size, 8);\n        assert!(!file_state.content_hash.is_empty());\n    }\n\n    #[test]\n    fn test_has_changes_identical_states() {\n        let temp_dir = tempdir().unwrap();\n        let base_path = temp_dir.path();\n        fs::write(base_path.join(\"test.txt\"), \"content\").unwrap();\n\n        let mut files = BTreeMap::new();\n        files.insert(\n            PathBuf::from(\"test.txt\"),\n            FileState::from_path(\u0026base_path.join(\"test.txt\")).unwrap(),\n        );\n\n        let state1 = ProjectState {\n            timestamp: \"2023-01-01T00:00:00Z\".to_string(),\n            config_hash: \"hash1\".to_string(),\n            files: files.clone(),\n            metadata: ProjectMetadata {\n                project_name: \"test\".to_string(),\n                file_count: 1,\n                filters: vec![],\n                ignores: vec![],\n                line_numbers: false,\n            },\n        };\n\n        let state2 = ProjectState {\n            timestamp: \"2023-01-01T01:00:00Z\".to_string(),\n            config_hash: \"hash1\".to_string(),\n            files,\n            metadata: ProjectMetadata {\n                project_name: \"test\".to_string(),\n                file_count: 1,\n                filters: vec![],\n                ignores: vec![],\n                line_numbers: false,\n            },\n        };\n\n        assert!(!state1.has_changes(\u0026state2));\n    }\n\n    #[test]\n    fn test_has_changes_different_file_count() {\n        let temp_dir = tempdir().unwrap();\n        let base_path = temp_dir.path();\n        fs::write(base_path.join(\"test1.txt\"), \"content1\").unwrap();\n        fs::write(base_path.join(\"test2.txt\"), \"content2\").unwrap();\n\n        let mut files1 = BTreeMap::new();\n        files1.insert(\n            PathBuf::from(\"test1.txt\"),\n            FileState::from_path(\u0026base_path.join(\"test1.txt\")).unwrap(),\n        );\n\n        let mut files2 = BTreeMap::new();\n        files2.insert(\n            PathBuf::from(\"test1.txt\"),\n            FileState::from_path(\u0026base_path.join(\"test1.txt\")).unwrap(),\n        );\n        files2.insert(\n            PathBuf::from(\"test2.txt\"),\n            FileState::from_path(\u0026base_path.join(\"test2.txt\")).unwrap(),\n        );\n\n        let state1 = ProjectState {\n            timestamp: \"2023-01-01T00:00:00Z\".to_string(),\n            config_hash: \"hash1\".to_string(),\n            files: files1,\n            metadata: ProjectMetadata {\n                project_name: \"test\".to_string(),\n                file_count: 1,\n                filters: vec![],\n                ignores: vec![],\n                line_numbers: false,\n            },\n        };\n\n        let state2 = ProjectState {\n            timestamp: \"2023-01-01T01:00:00Z\".to_string(),\n            config_hash: \"hash1\".to_string(),\n            files: files2,\n            metadata: ProjectMetadata {\n                project_name: \"test\".to_string(),\n                file_count: 2,\n                filters: vec![],\n                ignores: vec![],\n                line_numbers: false,\n            },\n        };\n\n        assert!(state1.has_changes(\u0026state2));\n    }\n\n    #[test]\n    fn test_has_changes_content_different() {\n        let temp_dir = tempdir().unwrap();\n        let base_path = temp_dir.path();\n        fs::write(base_path.join(\"test.txt\"), \"content1\").unwrap();\n\n        let file_state1 = FileState::from_path(\u0026base_path.join(\"test.txt\")).unwrap();\n\n        fs::write(base_path.join(\"test.txt\"), \"content2\").unwrap();\n        let file_state2 = FileState::from_path(\u0026base_path.join(\"test.txt\")).unwrap();\n\n        let mut files1 = BTreeMap::new();\n        files1.insert(PathBuf::from(\"test.txt\"), file_state1);\n\n        let mut files2 = BTreeMap::new();\n        files2.insert(PathBuf::from(\"test.txt\"), file_state2);\n\n        let state1 = ProjectState {\n            timestamp: \"2023-01-01T00:00:00Z\".to_string(),\n            config_hash: \"hash1\".to_string(),\n            files: files1,\n            metadata: ProjectMetadata {\n                project_name: \"test\".to_string(),\n                file_count: 1,\n                filters: vec![],\n                ignores: vec![],\n                line_numbers: false,\n            },\n        };\n\n        let state2 = ProjectState {\n            timestamp: \"2023-01-01T01:00:00Z\".to_string(),\n            config_hash: \"hash1\".to_string(),\n            files: files2,\n            metadata: ProjectMetadata {\n                project_name: \"test\".to_string(),\n                file_count: 1,\n                filters: vec![],\n                ignores: vec![],\n                line_numbers: false,\n            },\n        };\n\n        assert!(state1.has_changes(\u0026state2));\n    }\n\n    #[test]\n    fn test_config_hash_generation() {\n        let config1 = Config {\n            filter: Some(vec![\"rs\".to_string()]),\n            ignore: Some(vec![\"target\".to_string()]),\n            line_numbers: Some(true),\n            auto_diff: Some(false),\n            diff_context_lines: Some(3),\n            ..Default::default()\n        };\n\n        let config2 = Config {\n            filter: Some(vec![\"rs\".to_string()]),\n            ignore: Some(vec![\"target\".to_string()]),\n            line_numbers: Some(true),\n            auto_diff: Some(false),\n            diff_context_lines: Some(3),\n            ..Default::default()\n        };\n\n        let config3 = Config {\n            filter: Some(vec![\"py\".to_string()]), // Different filter\n            ignore: Some(vec![\"target\".to_string()]),\n            line_numbers: Some(true),\n            auto_diff: Some(false),\n            diff_context_lines: Some(3),\n            ..Default::default()\n        };\n\n        let hash1 = ProjectState::compute_config_hash(\u0026config1);\n        let hash2 = ProjectState::compute_config_hash(\u0026config2);\n        let hash3 = ProjectState::compute_config_hash(\u0026config3);\n\n        assert_eq!(hash1, hash2);\n        assert_ne!(hash1, hash3);\n    }\n\n    #[test]\n    fn test_change_summary_no_changes() {\n        let summary = ChangeSummary {\n            added: vec![],\n            removed: vec![],\n            modified: vec![],\n            total_changes: 0,\n        };\n\n        assert!(!summary.has_changes());\n        assert_eq!(summary.to_markdown(), \"\");\n    }\n\n    #[test]\n    fn test_from_files_with_config() {\n        let temp_dir = tempdir().unwrap();\n        let base_path = temp_dir.path();\n\n        fs::write(base_path.join(\"test.rs\"), \"fn main() {}\").unwrap();\n        fs::write(base_path.join(\"README.md\"), \"# Test\").unwrap();\n\n        let entries = vec![\n            create_mock_dir_entry(\u0026base_path.join(\"test.rs\")),\n            create_mock_dir_entry(\u0026base_path.join(\"README.md\")),\n        ];\n\n        let config = Config {\n            filter: Some(vec![\"rs\".to_string()]),\n            ignore: Some(vec![\"target\".to_string()]),\n            line_numbers: Some(true),\n            ..Default::default()\n        };\n\n        let state = ProjectState::from_files(\u0026entries, base_path, \u0026config, true).unwrap();\n\n        assert_eq!(state.files.len(), 2);\n        assert_eq!(state.metadata.file_count, 2);\n        assert_eq!(state.metadata.filters, vec![\"rs\"]);\n        assert_eq!(state.metadata.ignores, vec![\"target\"]);\n        assert!(state.metadata.line_numbers);\n        assert!(!state.timestamp.is_empty());\n        assert!(!state.config_hash.is_empty());\n    }\n\n    #[test]\n    fn test_from_files_absolute_path_fallback() {\n        let temp_dir = tempdir().unwrap();\n        let base_path = temp_dir.path();\n\n        // Create a file in the temp dir\n        fs::write(base_path.join(\"test.txt\"), \"test content\").unwrap();\n        let file_path = base_path.join(\"test.txt\");\n\n        // Create entry with the file\n        let entry = create_mock_dir_entry(\u0026file_path);\n\n        // Use a completely different base_path to force the fallback\n        let different_base = PathBuf::from(\"/completely/different/path\");\n\n        let config = Config::default();\n\n        let state = ProjectState::from_files(\u0026[entry], \u0026different_base, \u0026config, false).unwrap();\n\n        // Should fall back to just the filename\n        assert_eq!(state.files.len(), 1);\n        assert!(state.files.contains_key(\u0026PathBuf::from(\"test.txt\")));\n    }\n\n    #[test]\n    fn test_change_summary_with_unchanged_files() {\n        let changes = vec![\n            PerFileDiff {\n                path: \"added.txt\".to_string(),\n                status: PerFileStatus::Added,\n                diff: \"diff content\".to_string(),\n            },\n            PerFileDiff {\n                path: \"unchanged.txt\".to_string(),\n                status: PerFileStatus::Unchanged,\n                diff: \"\".to_string(),\n            },\n        ];\n\n        // Manually create the summary like the actual code does\n        let mut added = Vec::new();\n        let mut removed = Vec::new();\n        let mut modified = Vec::new();\n\n        for diff in \u0026changes {\n            let path = PathBuf::from(\u0026diff.path);\n            match diff.status {\n                PerFileStatus::Added =\u003e added.push(path),\n                PerFileStatus::Removed =\u003e removed.push(path),\n                PerFileStatus::Modified =\u003e modified.push(path),\n                PerFileStatus::Unchanged =\u003e {} // This line should be covered now\n            }\n        }\n\n        let summary = ChangeSummary {\n            total_changes: added.len() + removed.len() + modified.len(),\n            added,\n            removed,\n            modified,\n        };\n\n        assert_eq!(summary.total_changes, 1); // Only the added file counts\n        assert_eq!(summary.added.len(), 1);\n        assert_eq!(summary.removed.len(), 0);\n        assert_eq!(summary.modified.len(), 0);\n    }\n\n    #[test]\n    fn test_has_changes_with_missing_file() {\n        let temp_dir = tempdir().unwrap();\n        let base_path = temp_dir.path();\n\n        // Create files for the first state\n        fs::write(base_path.join(\"file1.txt\"), \"content1\").unwrap();\n        let entry1 = create_mock_dir_entry(\u0026base_path.join(\"file1.txt\"));\n\n        let config = Config::default();\n        let state1 = ProjectState::from_files(\u0026[entry1], base_path, \u0026config, false).unwrap();\n\n        // Create a different state with different files\n        fs::write(base_path.join(\"file2.txt\"), \"content2\").unwrap();\n        let entry2 = create_mock_dir_entry(\u0026base_path.join(\"file2.txt\"));\n        let state2 = ProjectState::from_files(\u0026[entry2], base_path, \u0026config, false).unwrap();\n\n        // Should detect changes because files are completely different\n        assert!(state1.has_changes(\u0026state2));\n    }\n\n    #[test]\n    fn test_file_state_with_invalid_data_error() {\n        // Create a temporary file with binary content that might trigger InvalidData\n        let temp_dir = tempdir().unwrap();\n        let binary_file = temp_dir.path().join(\"binary.dat\");\n\n        // Write invalid UTF-8 bytes\n        let binary_data = vec![0xFF, 0xFE, 0xFD, 0xFC, 0xFB, 0xFA];\n        fs::write(\u0026binary_file, \u0026binary_data).unwrap();\n\n        // This might trigger the InvalidData error path, but since we can't guarantee it,\n        // we at least verify the function can handle binary files\n        let result = FileState::from_path(\u0026binary_file);\n        assert!(result.is_ok());\n    }\n\n    // Helper function to create a mock DirEntry for testing\n    fn create_mock_dir_entry(path: \u0026std::path::Path) -\u003e ignore::DirEntry {\n        // This is a bit of a hack since DirEntry doesn't have a public constructor\n        // We use the ignore crate's WalkBuilder to create a real DirEntry\n        let walker = ignore::WalkBuilder::new(path.parent().unwrap());\n        walker\n            .build()\n            .filter_map(Result::ok)\n            .find(|entry| entry.path() == path)\n            .expect(\"Failed to create DirEntry for test\")\n    }\n}\n","traces":[{"line":82,"address":[],"length":0,"stats":{"Line":4611686018427387904}},{"line":88,"address":[],"length":0,"stats":{"Line":9223372036854775808}},{"line":93,"address":[],"length":0,"stats":{"Line":13835058055282163712}},{"line":94,"address":[],"length":0,"stats":{"Line":8791026472627208192}},{"line":95,"address":[],"length":0,"stats":{"Line":15492382718154506240}},{"line":97,"address":[],"length":0,"stats":{"Line":4179340454199820288}},{"line":99,"address":[],"length":0,"stats":{"Line":4179340454199820288}},{"line":100,"address":[],"length":0,"stats":{"Line":11529215046068469760}},{"line":101,"address":[],"length":0,"stats":{"Line":15348267530078650368}},{"line":102,"address":[],"length":0,"stats":{"Line":11385099857992613888}},{"line":104,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":105,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":106,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":107,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":110,"address":[],"length":0,"stats":{"Line":15492382718154506240}},{"line":114,"address":[],"length":0,"stats":{"Line":4611686018427387904}},{"line":116,"address":[],"length":0,"stats":{"Line":4611686018427387904}},{"line":137,"address":[],"length":0,"stats":{"Line":1657324662872342528}},{"line":139,"address":[],"length":0,"stats":{"Line":4971973988617027584}},{"line":140,"address":[],"length":0,"stats":{"Line":1657324662872342528}},{"line":142,"address":[],"length":0,"stats":{"Line":17798225727368200192}},{"line":145,"address":[],"length":0,"stats":{"Line":4971973988617027584}},{"line":146,"address":[],"length":0,"stats":{"Line":1657324662872342528}},{"line":148,"address":[],"length":0,"stats":{"Line":2522015791327477760}},{"line":152,"address":[],"length":0,"stats":{"Line":8286623314361712640}},{"line":155,"address":[],"length":0,"stats":{"Line":3314649325744685056}},{"line":156,"address":[],"length":0,"stats":{"Line":3314649325744685056}},{"line":157,"address":[],"length":0,"stats":{"Line":3314649325744685056}},{"line":159,"address":[],"length":0,"stats":{"Line":5692549928996306944}},{"line":162,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":163,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":164,"address":[],"length":0,"stats":{"Line":2810246167479189504}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":8286623314361712640}},{"line":183,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":184,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":185,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":188,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":189,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":190,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":191,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":192,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":195,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":199,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":203,"address":[],"length":0,"stats":{"Line":4827858800541171712}},{"line":207,"address":[],"length":0,"stats":{"Line":9655717601082343424}},{"line":208,"address":[],"length":0,"stats":{"Line":14483576401623515136}},{"line":209,"address":[],"length":0,"stats":{"Line":14483576401623515136}},{"line":210,"address":[],"length":0,"stats":{"Line":14483576401623515136}},{"line":211,"address":[],"length":0,"stats":{"Line":14483576401623515136}},{"line":212,"address":[],"length":0,"stats":{"Line":14483576401623515136}},{"line":214,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":220,"address":[],"length":0,"stats":{"Line":12321848580485677056}},{"line":226,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":228,"address":[],"length":0,"stats":{"Line":12321848580485677056}},{"line":229,"address":[],"length":0,"stats":{"Line":10160120759347838976}},{"line":230,"address":[],"length":0,"stats":{"Line":6485183463413514240}},{"line":232,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":233,"address":[],"length":0,"stats":{"Line":8646911284551352320}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":4539628424389459968}},{"line":255,"address":[],"length":0,"stats":{"Line":4539628424389459968}},{"line":259,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":260,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":261,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":264,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":265,"address":[],"length":0,"stats":{"Line":3674937295934324736}},{"line":267,"address":[],"length":0,"stats":{"Line":3098476543630901248}},{"line":271,"address":[],"length":0,"stats":{"Line":1657324662872342528}},{"line":275,"address":[],"length":0,"stats":{"Line":3098476543630901248}},{"line":279,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":280,"address":[],"length":0,"stats":{"Line":1224979098644774912}}],"covered":70,"coverable":72},{"path":["D:","\\","GitHub","context-builder","src","token_count.rs"],"content":"use ignore::DirEntry;\nuse once_cell::sync::Lazy;\nuse std::collections::BTreeMap;\nuse std::fs;\nuse std::path::Path;\n/// Token counting utilities for estimating LLM token usage\nuse tiktoken_rs::{CoreBPE, cl100k_base};\n\n// Initialize the tokenizer once and reuse it\nstatic TOKENIZER: Lazy\u003cCoreBPE\u003e = Lazy::new(|| cl100k_base().unwrap());\n\n/// Estimates the number of tokens in a text string using a real tokenizer\npub fn estimate_tokens(text: \u0026str) -\u003e usize {\n    TOKENIZER.encode_with_special_tokens(text).len()\n}\n\n/// Counts the tokens that would be generated for a file\npub fn count_file_tokens(base_path: \u0026Path, entry: \u0026DirEntry, line_numbers: bool) -\u003e usize {\n    let file_path = entry.path();\n    let relative_path = file_path.strip_prefix(base_path).unwrap_or(file_path);\n\n    // Start with tokens for the file header (path, size, modified time)\n    let mut token_count = estimate_tokens(\u0026format!(\n        \"\\n### File: `{}`\\n\\n- Size: {} bytes\\n- Modified: {}\\n\\n\",\n        relative_path.display(),\n        entry.metadata().map(|m| m.len()).unwrap_or(0),\n        \"Unknown\"\n    )); // Using \"Unknown\" as placeholder for modified time in estimation\n\n    // Add tokens for the code fences\n    token_count += estimate_tokens(\"```\\n```\");\n\n    // Try to read file content\n    if let Ok(content) = fs::read_to_string(file_path) {\n        if line_numbers {\n            // When line numbers are enabled, we add the line number prefix to each line\n            let lines_with_numbers: String = content\n                .lines()\n                .enumerate()\n                .map(|(i, line)| format!(\"{:\u003e4} | {}\\n\", i + 1, line))\n                .collect();\n            token_count += estimate_tokens(\u0026lines_with_numbers);\n        } else {\n            token_count += estimate_tokens(\u0026content);\n        }\n    }\n\n    token_count\n}\n\n/// Counts the tokens that would be generated for the entire file tree section\npub fn count_tree_tokens(tree: \u0026BTreeMap\u003cString, crate::tree::FileNode\u003e, depth: usize) -\u003e usize {\n    let mut token_count = 0;\n\n    // Add tokens for indentation\n    let indent = \"  \".repeat(depth);\n\n    for (name, node) in tree {\n        match node {\n            crate::tree::FileNode::File =\u003e {\n                token_count += estimate_tokens(\u0026format!(\"{}- 📄 {}\\n\", indent, name));\n            }\n            crate::tree::FileNode::Directory(children) =\u003e {\n                token_count += estimate_tokens(\u0026format!(\"{}- 📁 {}\\n\", indent, name));\n                token_count += count_tree_tokens(children, depth + 1);\n            }\n        }\n    }\n\n    token_count\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::BTreeMap;\n\n    #[test]\n    fn test_estimate_tokens() {\n        // Test with a simple string\n        let text = \"Hello, world!\";\n        let tokens = estimate_tokens(text);\n        // \"Hello, world!\" is 4 tokens with cl100k_base\n        assert_eq!(tokens, 4);\n\n        // Test with code-like content\n        let code_text = \"fn main() {\\n    println!(\\\"Hello, world!\\\");\\n}\";\n        let tokens = estimate_tokens(code_text);\n        // This specific code snippet is 12 tokens with cl100k_base\n        assert_eq!(tokens, 12);\n    }\n\n    #[test]\n    fn test_count_tree_tokens() {\n        // Create a simple tree structure\n        let mut tree = BTreeMap::new();\n        tree.insert(\"file1.rs\".to_string(), crate::tree::FileNode::File);\n\n        let mut subdir = BTreeMap::new();\n        subdir.insert(\"file2.md\".to_string(), crate::tree::FileNode::File);\n        tree.insert(\"src\".to_string(), crate::tree::FileNode::Directory(subdir));\n\n        let tokens = count_tree_tokens(\u0026tree, 0);\n        // \"- 📄 file1.rs\\n\" -\u003e 8 tokens\n        // \"- 📁 src\\n\" -\u003e 6 tokens\n        // \"  - 📄 file2.md\\n\" -\u003e 9 tokens\n        // Total should be 23 tokens\n        assert_eq!(tokens, 23);\n    }\n\n    #[test]\n    fn test_token_estimation_format_consistency() {\n        use tempfile::tempdir;\n\n        let dir = tempdir().unwrap();\n        let test_file = dir.path().join(\"test.rs\");\n        std::fs::write(\u0026test_file, \"fn main() {}\\n\").unwrap();\n\n        let entry = ignore::WalkBuilder::new(\u0026test_file)\n            .build()\n            .next()\n            .unwrap()\n            .unwrap();\n\n        // Estimate tokens for the file\n        let estimated_tokens = count_file_tokens(dir.path(), \u0026entry, false);\n\n        // Generate actual markdown content\n        let mut actual_content = Vec::new();\n        crate::markdown::process_file(dir.path(), \u0026test_file, \u0026mut actual_content, false, None)\n            .unwrap();\n        let actual_content_str = String::from_utf8(actual_content).unwrap();\n\n        // Count actual tokens\n        let actual_tokens = estimate_tokens(\u0026actual_content_str);\n\n        // The estimation should be close to actual (within a reasonable margin)\n        // Allow for some variance due to timestamp differences and minor formatting\n        let difference = actual_tokens.abs_diff(estimated_tokens);\n\n        // Should be within 10% or 20 tokens difference (whichever is larger)\n        let max_allowed_difference = std::cmp::max(actual_tokens / 10, 20);\n\n        assert!(\n            difference \u003c= max_allowed_difference,\n            \"Token estimation {} differs too much from actual {} (difference: {})\",\n            estimated_tokens,\n            actual_tokens,\n            difference\n        );\n    }\n\n    #[test]\n    fn test_estimate_tokens_empty_string() {\n        let tokens = estimate_tokens(\"\");\n        assert_eq!(tokens, 0);\n    }\n\n    #[test]\n    fn test_estimate_tokens_whitespace_only() {\n        let tokens = estimate_tokens(\"   \\n\\t  \");\n        assert!(tokens \u003e 0); // Whitespace still counts as tokens\n    }\n\n    #[test]\n    fn test_estimate_tokens_unicode() {\n        let tokens = estimate_tokens(\"Hello 世界! 🌍\");\n        assert!(tokens \u003e 0);\n        // Unicode characters may be encoded as multiple tokens\n        assert!(tokens \u003e= 4);\n    }\n\n    #[test]\n    fn test_count_file_tokens_with_line_numbers() {\n        use tempfile::tempdir;\n\n        let dir = tempdir().unwrap();\n        let test_file = dir.path().join(\"test.rs\");\n        std::fs::write(\u0026test_file, \"line 1\\nline 2\\nline 3\").unwrap();\n\n        let entry = ignore::WalkBuilder::new(\u0026test_file)\n            .build()\n            .next()\n            .unwrap()\n            .unwrap();\n\n        let tokens_without_line_numbers = count_file_tokens(dir.path(), \u0026entry, false);\n        let tokens_with_line_numbers = count_file_tokens(dir.path(), \u0026entry, true);\n\n        // With line numbers should have more tokens due to line number prefixes\n        assert!(tokens_with_line_numbers \u003e tokens_without_line_numbers);\n    }\n\n    #[test]\n    fn test_count_file_tokens_unreadable_file() {\n        use tempfile::tempdir;\n\n        let dir = tempdir().unwrap();\n        let test_file = dir.path().join(\"nonexistent.txt\");\n\n        // Create a mock DirEntry for a file that doesn't exist\n        // This simulates what happens when a file is deleted between discovery and processing\n        let walker = ignore::WalkBuilder::new(dir.path());\n        let mut found_entry = None;\n\n        // Create the file temporarily to get a DirEntry\n        std::fs::write(\u0026test_file, \"temp\").unwrap();\n        for entry in walker.build() {\n            if let Ok(entry) = entry\n                \u0026\u0026 entry.path() == test_file\n            {\n                found_entry = Some(entry);\n                break;\n            }\n        }\n\n        // Now delete the file\n        std::fs::remove_file(\u0026test_file).unwrap();\n\n        if let Some(entry) = found_entry {\n            let tokens = count_file_tokens(dir.path(), \u0026entry, false);\n            // Should still return some tokens for the file header even if content can't be read\n            assert!(tokens \u003e 0);\n        }\n    }\n\n    #[test]\n    fn test_count_tree_tokens_empty_tree() {\n        let tree = BTreeMap::new();\n        let tokens = count_tree_tokens(\u0026tree, 0);\n        assert_eq!(tokens, 0);\n    }\n\n    #[test]\n    fn test_count_tree_tokens_nested_directories() {\n        let mut tree = BTreeMap::new();\n\n        // Create deeply nested structure\n        let mut level3 = BTreeMap::new();\n        level3.insert(\"deep_file.txt\".to_string(), crate::tree::FileNode::File);\n\n        let mut level2 = BTreeMap::new();\n        level2.insert(\n            \"level3\".to_string(),\n            crate::tree::FileNode::Directory(level3),\n        );\n\n        let mut level1 = BTreeMap::new();\n        level1.insert(\n            \"level2\".to_string(),\n            crate::tree::FileNode::Directory(level2),\n        );\n\n        tree.insert(\n            \"level1\".to_string(),\n            crate::tree::FileNode::Directory(level1),\n        );\n\n        let tokens = count_tree_tokens(\u0026tree, 0);\n        assert!(tokens \u003e 0);\n\n        // Should account for indentation at different levels\n        let tokens_with_depth = count_tree_tokens(\u0026tree, 2);\n        assert!(tokens_with_depth \u003e tokens); // More indentation = more tokens\n    }\n\n    #[test]\n    fn test_count_tree_tokens_mixed_content() {\n        let mut tree = BTreeMap::new();\n\n        // Add files with various name lengths and characters\n        tree.insert(\"a.txt\".to_string(), crate::tree::FileNode::File);\n        tree.insert(\n            \"very_long_filename_with_underscores.rs\".to_string(),\n            crate::tree::FileNode::File,\n        );\n        tree.insert(\"файл.txt\".to_string(), crate::tree::FileNode::File); // Unicode filename\n\n        let mut subdir = BTreeMap::new();\n        subdir.insert(\"nested.md\".to_string(), crate::tree::FileNode::File);\n        tree.insert(\n            \"directory\".to_string(),\n            crate::tree::FileNode::Directory(subdir),\n        );\n\n        let tokens = count_tree_tokens(\u0026tree, 0);\n        assert!(tokens \u003e 0);\n\n        // Verify it handles unicode filenames without crashing\n        assert!(tokens \u003e 20); // Should be substantial given the content\n    }\n}\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":13,"address":[],"length":0,"stats":{"Line":8574853690513424384}},{"line":14,"address":[],"length":0,"stats":{"Line":7277816997830721536}},{"line":18,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":19,"address":[],"length":0,"stats":{"Line":3891110078048108544}},{"line":20,"address":[],"length":0,"stats":{"Line":7782220156096217088}},{"line":23,"address":[],"length":0,"stats":{"Line":3891110078048108544}},{"line":24,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":25,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":26,"address":[],"length":0,"stats":{"Line":7782220156096217088}},{"line":31,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":34,"address":[],"length":0,"stats":{"Line":2522015791327477760}},{"line":37,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":40,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":42,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":44,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":48,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":52,"address":[],"length":0,"stats":{"Line":1801439850948198400}},{"line":53,"address":[],"length":0,"stats":{"Line":3602879701896396800}},{"line":56,"address":[],"length":0,"stats":{"Line":7205759403792793600}},{"line":58,"address":[],"length":0,"stats":{"Line":6989586621679009792}},{"line":60,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":61,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":63,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":64,"address":[],"length":0,"stats":{"Line":3026418949592973312}},{"line":65,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":70,"address":[],"length":0,"stats":{"Line":1801439850948198400}}],"covered":27,"coverable":27},{"path":["D:","\\","GitHub","context-builder","src","tree.rs"],"content":"use ignore::DirEntry;\r\nuse std::collections::BTreeMap;\r\nuse std::io::{self, Write};\r\nuse std::path::Path;\r\n\r\n/// A nested map to represent the file tree structure.\r\n#[derive(Debug, Clone, PartialEq)]\r\npub enum FileNode {\r\n    File,\r\n    Directory(BTreeMap\u003cString, FileNode\u003e),\r\n}\r\n\r\n/// Type alias for the file tree structure.\r\npub type FileTree = BTreeMap\u003cString, FileNode\u003e;\r\n\r\n/// Builds a nested BTreeMap representing the file structure.\r\npub fn build_file_tree(files: \u0026[DirEntry], base_path: \u0026Path) -\u003e FileTree {\r\n    let mut tree = BTreeMap::new();\r\n    for entry in files {\r\n        let path = entry\r\n            .path()\r\n            .strip_prefix(base_path)\r\n            .unwrap_or_else(|_| entry.path());\r\n        let components: Vec\u003c_\u003e = path.components().collect();\r\n\r\n        // Insert this path into the tree\r\n        insert_path(\u0026mut tree, \u0026components);\r\n    }\r\n    tree\r\n}\r\n\r\n/// Helper function to insert a path into the tree structure\r\nfn insert_path(tree: \u0026mut FileTree, components: \u0026[std::path::Component]) {\r\n    if components.is_empty() {\r\n        return;\r\n    }\r\n\r\n    let name = components[0].as_os_str().to_string_lossy().to_string();\r\n\r\n    if components.len() == 1 {\r\n        // This is the last component, so it's a file\r\n        tree.insert(name, FileNode::File);\r\n    } else {\r\n        // This is a directory component\r\n        // Make sure the directory exists\r\n        tree.entry(name.clone())\r\n            .or_insert_with(|| FileNode::Directory(BTreeMap::new()));\r\n\r\n        // Recursively insert the rest of the path\r\n        if let Some(FileNode::Directory(next_dir)) = tree.get_mut(\u0026name) {\r\n            insert_path(next_dir, \u0026components[1..]);\r\n        }\r\n    }\r\n}\r\n\r\n/// Recursively prints the file tree to the console.\r\npub fn print_tree(tree: \u0026FileTree, depth: usize) {\r\n    for (name, node) in tree {\r\n        let indent = \"  \".repeat(depth);\r\n        match node {\r\n            FileNode::File =\u003e {\r\n                println!(\"{}- 📄 {}\", indent, name);\r\n            }\r\n            FileNode::Directory(children) =\u003e {\r\n                println!(\"{}- 📁 {}\", indent, name);\r\n                print_tree(children, depth + 1);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/// Recursively writes the file tree to a file.\r\npub fn write_tree_to_file(\r\n    output: \u0026mut impl Write,\r\n    tree: \u0026FileTree,\r\n    depth: usize,\r\n) -\u003e io::Result\u003c()\u003e {\r\n    for (name, node) in tree {\r\n        let indent = \"  \".repeat(depth);\r\n        match node {\r\n            FileNode::File =\u003e {\r\n                writeln!(output, \"{}- 📄 {}\", indent, name)?;\r\n            }\r\n            FileNode::Directory(children) =\u003e {\r\n                writeln!(output, \"{}- 📁 {}\", indent, name)?;\r\n                write_tree_to_file(output, children, depth + 1)?;\r\n            }\r\n        }\r\n    }\r\n    Ok(())\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n    use crate::file_utils::collect_files;\r\n    use std::fs;\r\n    use tempfile::tempdir;\r\n\r\n    #[test]\r\n    fn test_build_file_tree_with_collected_files() {\r\n        // 1. Set up a temporary directory with a file structure\r\n        let dir = tempdir().unwrap();\r\n        let base_path = dir.path();\r\n\r\n        fs::create_dir(base_path.join(\"src\")).unwrap();\r\n        fs::File::create(base_path.join(\"src/main.rs\")).unwrap();\r\n        fs::File::create(base_path.join(\"README.md\")).unwrap();\r\n        // Add a hidden file that should be ignored by default\r\n        fs::File::create(base_path.join(\".env\")).unwrap();\r\n\r\n        // 2. Collect files using the actual function\r\n        let files = collect_files(base_path, \u0026[], \u0026[]).unwrap();\r\n\r\n        // 3. Assert that the correct files were collected (a hidden file is ignored)\r\n        assert_eq!(files.len(), 2);\r\n\r\n        // 4. Build the tree with the collected files\r\n        let tree = build_file_tree(\u0026files, base_path);\r\n\r\n        // 5. Assert the tree structure is correct\r\n        let mut expected: FileTree = BTreeMap::new();\r\n        let mut src_tree = BTreeMap::new();\r\n        src_tree.insert(\"main.rs\".to_string(), FileNode::File);\r\n        expected.insert(\"src\".to_string(), FileNode::Directory(src_tree));\r\n        expected.insert(\"README.md\".to_string(), FileNode::File);\r\n\r\n        assert_eq!(tree, expected);\r\n    }\r\n\r\n    #[test]\r\n    fn test_build_file_tree_empty() {\r\n        let dir = tempdir().unwrap();\r\n        let base_path = dir.path();\r\n\r\n        let files = collect_files(base_path, \u0026[], \u0026[]).unwrap();\r\n        let tree = build_file_tree(\u0026files, base_path);\r\n\r\n        assert!(tree.is_empty());\r\n    }\r\n\r\n    #[test]\r\n    fn test_build_file_tree_single_file() {\r\n        let dir = tempdir().unwrap();\r\n        let base_path = dir.path();\r\n\r\n        fs::File::create(base_path.join(\"single.txt\")).unwrap();\r\n\r\n        let files = collect_files(base_path, \u0026[], \u0026[]).unwrap();\r\n        let tree = build_file_tree(\u0026files, base_path);\r\n\r\n        let mut expected: FileTree = BTreeMap::new();\r\n        expected.insert(\"single.txt\".to_string(), FileNode::File);\r\n\r\n        assert_eq!(tree, expected);\r\n    }\r\n\r\n    #[test]\r\n    fn test_build_file_tree_nested_directories() {\r\n        let dir = tempdir().unwrap();\r\n        let base_path = dir.path();\r\n\r\n        fs::create_dir_all(base_path.join(\"a/b/c\")).unwrap();\r\n        fs::File::create(base_path.join(\"a/b/c/deep.txt\")).unwrap();\r\n        fs::File::create(base_path.join(\"a/shallow.txt\")).unwrap();\r\n\r\n        let files = collect_files(base_path, \u0026[], \u0026[]).unwrap();\r\n        let tree = build_file_tree(\u0026files, base_path);\r\n\r\n        // Build expected structure\r\n        let mut c_tree = BTreeMap::new();\r\n        c_tree.insert(\"deep.txt\".to_string(), FileNode::File);\r\n\r\n        let mut b_tree = BTreeMap::new();\r\n        b_tree.insert(\"c\".to_string(), FileNode::Directory(c_tree));\r\n\r\n        let mut a_tree = BTreeMap::new();\r\n        a_tree.insert(\"b\".to_string(), FileNode::Directory(b_tree));\r\n        a_tree.insert(\"shallow.txt\".to_string(), FileNode::File);\r\n\r\n        let mut expected: FileTree = BTreeMap::new();\r\n        expected.insert(\"a\".to_string(), FileNode::Directory(a_tree));\r\n\r\n        assert_eq!(tree, expected);\r\n    }\r\n\r\n    #[test]\r\n    fn test_build_file_tree_unicode_filenames() {\r\n        let dir = tempdir().unwrap();\r\n        let base_path = dir.path();\r\n\r\n        fs::create_dir(base_path.join(\"测试目录\")).unwrap();\r\n        fs::File::create(base_path.join(\"测试目录/文件.txt\")).unwrap();\r\n        fs::File::create(base_path.join(\"🦀.rs\")).unwrap();\r\n\r\n        let files = collect_files(base_path, \u0026[], \u0026[]).unwrap();\r\n        let tree = build_file_tree(\u0026files, base_path);\r\n\r\n        let mut test_dir = BTreeMap::new();\r\n        test_dir.insert(\"文件.txt\".to_string(), FileNode::File);\r\n\r\n        let mut expected: FileTree = BTreeMap::new();\r\n        expected.insert(\"测试目录\".to_string(), FileNode::Directory(test_dir));\r\n        expected.insert(\"🦀.rs\".to_string(), FileNode::File);\r\n\r\n        assert_eq!(tree, expected);\r\n    }\r\n\r\n    #[test]\r\n    fn test_insert_path_empty_components() {\r\n        let mut tree = BTreeMap::new();\r\n        insert_path(\u0026mut tree, \u0026[]);\r\n        assert!(tree.is_empty());\r\n    }\r\n\r\n    #[test]\r\n    fn test_write_tree_to_file() {\r\n        let mut tree = BTreeMap::new();\r\n        tree.insert(\"file1.txt\".to_string(), FileNode::File);\r\n\r\n        let mut subdir = BTreeMap::new();\r\n        subdir.insert(\"file2.md\".to_string(), FileNode::File);\r\n        tree.insert(\"src\".to_string(), FileNode::Directory(subdir));\r\n\r\n        let mut output = Vec::new();\r\n        write_tree_to_file(\u0026mut output, \u0026tree, 0).unwrap();\r\n\r\n        let result = String::from_utf8(output).unwrap();\r\n        assert!(result.contains(\"- 📄 file1.txt\"));\r\n        assert!(result.contains(\"- 📁 src\"));\r\n        assert!(result.contains(\"  - 📄 file2.md\"));\r\n    }\r\n\r\n    #[test]\r\n    fn test_write_tree_to_file_with_depth() {\r\n        let mut tree = BTreeMap::new();\r\n        tree.insert(\"nested.txt\".to_string(), FileNode::File);\r\n\r\n        let mut output = Vec::new();\r\n        write_tree_to_file(\u0026mut output, \u0026tree, 2).unwrap();\r\n\r\n        let result = String::from_utf8(output).unwrap();\r\n        assert!(result.contains(\"    - 📄 nested.txt\")); // 2 levels of indentation\r\n    }\r\n\r\n    #[test]\r\n    fn test_write_tree_to_file_empty_tree() {\r\n        let tree = BTreeMap::new();\r\n        let mut output = Vec::new();\r\n        write_tree_to_file(\u0026mut output, \u0026tree, 0).unwrap();\r\n\r\n        let result = String::from_utf8(output).unwrap();\r\n        assert!(result.is_empty());\r\n    }\r\n\r\n    #[test]\r\n    fn test_file_node_equality() {\r\n        let file1 = FileNode::File;\r\n        let file2 = FileNode::File;\r\n        assert_eq!(file1, file2);\r\n\r\n        let mut dir1 = BTreeMap::new();\r\n        dir1.insert(\"test.txt\".to_string(), FileNode::File);\r\n        let node1 = FileNode::Directory(dir1.clone());\r\n        let node2 = FileNode::Directory(dir1);\r\n        assert_eq!(node1, node2);\r\n\r\n        // Different directories should not be equal\r\n        let mut dir2 = BTreeMap::new();\r\n        dir2.insert(\"other.txt\".to_string(), FileNode::File);\r\n        let node3 = FileNode::Directory(dir2);\r\n        assert_ne!(node1, node3);\r\n\r\n        // File and directory should not be equal\r\n        assert_ne!(file1, node1);\r\n    }\r\n\r\n    #[test]\r\n    fn test_build_file_tree_absolute_path_fallback() {\r\n        // Test the fallback case when strip_prefix fails by using different base paths\r\n        let dir = tempdir().unwrap();\r\n        let base_path = dir.path();\r\n        let other_dir = tempdir().unwrap();\r\n        let other_base = other_dir.path();\r\n\r\n        // Create a file in the first directory\r\n        fs::File::create(base_path.join(\"test.txt\")).unwrap();\r\n\r\n        // Create a DirEntry from the first directory but use a different base_path\r\n        let files = collect_files(base_path, \u0026[], \u0026[]).unwrap();\r\n\r\n        // This should trigger the unwrap_or_else case since other_base is unrelated to the file path\r\n        let tree = build_file_tree(\u0026files, other_base);\r\n\r\n        // The tree should still contain the file, but with its full path\r\n        assert!(!tree.is_empty());\r\n    }\r\n\r\n    #[test]\r\n    fn test_build_file_tree_multiple_files_same_directory() {\r\n        let dir = tempdir().unwrap();\r\n        let base_path = dir.path();\r\n\r\n        fs::create_dir(base_path.join(\"docs\")).unwrap();\r\n        fs::File::create(base_path.join(\"docs/readme.md\")).unwrap();\r\n        fs::File::create(base_path.join(\"docs/guide.md\")).unwrap();\r\n        fs::File::create(base_path.join(\"docs/api.md\")).unwrap();\r\n\r\n        let files = collect_files(base_path, \u0026[], \u0026[]).unwrap();\r\n        let tree = build_file_tree(\u0026files, base_path);\r\n\r\n        let mut docs_tree = BTreeMap::new();\r\n        docs_tree.insert(\"api.md\".to_string(), FileNode::File);\r\n        docs_tree.insert(\"guide.md\".to_string(), FileNode::File);\r\n        docs_tree.insert(\"readme.md\".to_string(), FileNode::File);\r\n\r\n        let mut expected: FileTree = BTreeMap::new();\r\n        expected.insert(\"docs\".to_string(), FileNode::Directory(docs_tree));\r\n\r\n        assert_eq!(tree, expected);\r\n    }\r\n}\r\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":11240984669916758016}},{"line":18,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":19,"address":[],"length":0,"stats":{"Line":144115188075855870}},{"line":23,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":29,"address":[],"length":0,"stats":{"Line":11240984669916758016}},{"line":33,"address":[],"length":0,"stats":{"Line":3963167672086036479}},{"line":34,"address":[],"length":0,"stats":{"Line":7926335344172072958}},{"line":35,"address":[],"length":0,"stats":{"Line":72057594037927946}},{"line":40,"address":[],"length":0,"stats":{"Line":13402712491054596095}},{"line":42,"address":[],"length":0,"stats":{"Line":3314649325744685053}},{"line":46,"address":[],"length":0,"stats":{"Line":17149707381026848757}},{"line":47,"address":[],"length":0,"stats":{"Line":13330654897016668160}},{"line":50,"address":[],"length":0,"stats":{"Line":17149707381026848753}},{"line":57,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":58,"address":[],"length":0,"stats":{"Line":3746994889972252672}},{"line":61,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":62,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":64,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":65,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":66,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":73,"address":[],"length":0,"stats":{"Line":2954361355555045376}},{"line":78,"address":[],"length":0,"stats":{"Line":9871890383196127234}},{"line":79,"address":[],"length":0,"stats":{"Line":6341068275337658376}},{"line":80,"address":[],"length":0,"stats":{"Line":15420325124116578306}},{"line":82,"address":[],"length":0,"stats":{"Line":5548434740920451074}},{"line":84,"address":[],"length":0,"stats":{"Line":11601272640106397700}},{"line":85,"address":[],"length":0,"stats":{"Line":16357073846609641484}},{"line":86,"address":[],"length":0,"stats":{"Line":11601272640106397700}},{"line":90,"address":[],"length":0,"stats":{"Line":2954361355555045372}}],"covered":29,"coverable":29}]};
        var previousData = {"files":[{"path":["D:","\\","GitHub","context-builder","src","cache.rs"],"content":"//! Cache management for context-builder.\r\n//!\r\n//! This module handles caching of project states to enable the auto-diff feature.\r\n//! It uses a hash of the project path and configuration to avoid cache collisions\r\n//! between different projects or configurations.\r\n\r\nuse fs2::FileExt;\r\n\r\nuse std::collections::hash_map::DefaultHasher;\r\nuse std::fs;\r\nuse std::fs::File;\r\nuse std::hash::{Hash, Hasher};\r\nuse std::io::{Read, Write};\r\nuse std::path::{Path, PathBuf};\r\n\r\nuse crate::config::Config;\r\nuse crate::state::ProjectState;\r\n\r\n/// Manages cache operations with file locking to prevent corruption\r\npub struct CacheManager {\r\n    cache_dir: PathBuf,\r\n    project_hash: String,\r\n    config_hash: String,\r\n}\r\n\r\nimpl CacheManager {\r\n    /// Create a new cache manager for the given project path and configuration\r\n    pub fn new(project_path: \u0026Path, config: \u0026Config) -\u003e Self {\r\n        // Normalize the project path first for consistency\r\n        let normalized_project_path = Self::normalize_project_path(project_path);\r\n\r\n        let project_hash = Self::hash_path(\u0026normalized_project_path);\r\n        let config_hash = Self::hash_config(config);\r\n\r\n        // Ensure cache directory exists relative to normalized project root\r\n        let cache_dir = normalized_project_path\r\n            .join(\".context-builder\")\r\n            .join(\"cache\");\r\n        if !cache_dir.exists() {\r\n            let _ = fs::create_dir_all(\u0026cache_dir);\r\n        }\r\n\r\n        let cache_manager = Self {\r\n            cache_dir,\r\n            project_hash,\r\n            config_hash,\r\n        };\r\n\r\n        // Migrate old cache format if present\r\n        cache_manager.migrate_old_cache();\r\n\r\n        cache_manager\r\n    }\r\n\r\n    /// Normalize project path for consistent hashing and cache directory creation\r\n    fn normalize_project_path(path: \u0026Path) -\u003e PathBuf {\r\n        // Always resolve to absolute path first\r\n        let absolute_path = if path.is_absolute() {\r\n            path.to_path_buf()\r\n        } else {\r\n            match std::env::current_dir() {\r\n                Ok(cwd) =\u003e cwd.join(path),\r\n                Err(_) =\u003e path.to_path_buf(),\r\n            }\r\n        };\r\n\r\n        // Try to canonicalize for consistency, but normalize the result\r\n        if let Ok(canonical) = absolute_path.canonicalize() {\r\n            Self::normalize_path_format(\u0026canonical)\r\n        } else {\r\n            absolute_path\r\n        }\r\n    }\r\n\r\n    /// Generate a hash from the normalized project path\r\n    fn hash_path(path: \u0026Path) -\u003e String {\r\n        let mut hasher = DefaultHasher::new();\r\n        path.hash(\u0026mut hasher);\r\n        format!(\"{:x}\", hasher.finish())\r\n    }\r\n\r\n    /// Normalize path format to handle Windows UNC prefixes\r\n    fn normalize_path_format(path: \u0026Path) -\u003e PathBuf {\r\n        let path_str = path.to_string_lossy();\r\n\r\n        // Remove Windows UNC prefix if present\r\n        if cfg!(windows) \u0026\u0026 path_str.starts_with(\"\\\\\\\\?\\\\\") {\r\n            PathBuf::from(\u0026path_str[4..])\r\n        } else {\r\n            path.to_path_buf()\r\n        }\r\n    }\r\n\r\n    /// Generate a hash from the configuration\r\n    fn hash_config(config: \u0026Config) -\u003e String {\r\n        let mut hasher = DefaultHasher::new();\r\n        // Hash the relevant configuration parameters that affect output\r\n        config.filter.hash(\u0026mut hasher);\r\n        config.ignore.hash(\u0026mut hasher);\r\n        config.line_numbers.hash(\u0026mut hasher);\r\n        format!(\"{:x}\", hasher.finish())\r\n    }\r\n\r\n    /// Get the cache file path for this specific project and configuration\r\n    fn get_cache_path(\u0026self) -\u003e PathBuf {\r\n        self.cache_dir.join(format!(\r\n            \"state_{}_{}.json\",\r\n            self.project_hash, self.config_hash\r\n        ))\r\n    }\r\n\r\n    /// Public helper primarily for debugging/tests to inspect the resolved cache path\r\n    pub fn debug_cache_file_path(\u0026self) -\u003e PathBuf {\r\n        self.get_cache_path()\r\n    }\r\n\r\n    /// Migrate old markdown-based cache files to new JSON format\r\n    fn migrate_old_cache(\u0026self) {\r\n        let old_cache_patterns = [\"last_canonical.md\", \"last_output.md\", \"current_output.md\"];\r\n\r\n        for pattern in \u0026old_cache_patterns {\r\n            let old_cache_path = self.cache_dir.join(pattern);\r\n            if old_cache_path.exists() {\r\n                eprintln!(\"Migrating old cache format: removing {}\", pattern);\r\n                let _ = fs::remove_file(\u0026old_cache_path);\r\n            }\r\n        }\r\n\r\n        // Also remove any files that look like timestamped outputs from old versions\r\n        if let Ok(entries) = fs::read_dir(\u0026self.cache_dir) {\r\n            for entry in entries.flatten() {\r\n                let file_name = entry.file_name();\r\n                let name = file_name.to_string_lossy();\r\n                if name.ends_with(\".md\") \u0026\u0026 (name.contains(\"_20\") || name.starts_with(\"output_\")) {\r\n                    eprintln!(\"Migrating old cache format: removing {}\", name);\r\n                    let _ = fs::remove_file(entry.path());\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /// Read the cached project state with file locking\r\n    pub fn read_cache(\u0026self) -\u003e Result\u003cOption\u003cProjectState\u003e, Box\u003cdyn std::error::Error\u003e\u003e {\r\n        let cache_path = self.get_cache_path();\r\n\r\n        if !cache_path.exists() {\r\n            return Ok(None);\r\n        }\r\n\r\n        let file = File::open(\u0026cache_path)?;\r\n        // Acquire shared lock to prevent reading while writing\r\n        file.lock_shared()?;\r\n\r\n        let mut contents = String::new();\r\n        let mut file = std::io::BufReader::new(file);\r\n        file.read_to_string(\u0026mut contents)?;\r\n\r\n        // Release lock\r\n        file.get_ref().unlock()?;\r\n\r\n        let state: ProjectState = serde_json::from_str(\u0026contents)?;\r\n        Ok(Some(state))\r\n    }\r\n\r\n    /// Write the project state to cache with file locking\r\n    pub fn write_cache(\u0026self, state: \u0026ProjectState) -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\r\n        let cache_path = self.get_cache_path();\r\n\r\n        let file = File::create(\u0026cache_path)?;\r\n        // Acquire exclusive lock to prevent concurrent writes\r\n        file.lock_exclusive()?;\r\n\r\n        let json = serde_json::to_string_pretty(state)?;\r\n        let mut file = std::io::BufWriter::new(file);\r\n        file.write_all(json.as_bytes())?;\r\n        file.flush()?;\r\n\r\n        // Release lock\r\n        file.get_ref().unlock()?;\r\n\r\n        Ok(())\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n    use std::path::Path;\r\n    use tempfile::tempdir;\r\n\r\n    #[test]\r\n    fn test_hash_path() {\r\n        let path1 = Path::new(\"/project1\");\r\n        let path2 = Path::new(\"/project2\");\r\n\r\n        let hash1 = CacheManager::hash_path(path1);\r\n        let hash2 = CacheManager::hash_path(path2);\r\n\r\n        assert_ne!(\r\n            hash1, hash2,\r\n            \"Different paths should produce different hashes\"\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    fn test_hash_config() {\r\n        let config1 = Config {\r\n            filter: Some(vec![\"rs\".to_string()]),\r\n            ignore: Some(vec![\"target\".to_string()]),\r\n            line_numbers: Some(true),\r\n            ..Default::default()\r\n        };\r\n\r\n        let config2 = Config {\r\n            filter: Some(vec![\"md\".to_string()]),\r\n            ignore: Some(vec![\"target\".to_string()]),\r\n            line_numbers: Some(true),\r\n            ..Default::default()\r\n        };\r\n\r\n        let hash1 = CacheManager::hash_config(\u0026config1);\r\n        let hash2 = CacheManager::hash_config(\u0026config2);\r\n\r\n        assert_ne!(\r\n            hash1, hash2,\r\n            \"Different configs should produce different hashes\"\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    fn test_cache_operations() {\r\n        let dir = tempdir().unwrap();\r\n        let project_path = dir.path().join(\"test_project\");\r\n        let _ = fs::create_dir(\u0026project_path);\r\n\r\n        let config = Config::default();\r\n        let cache_manager = CacheManager::new(\u0026project_path, \u0026config);\r\n\r\n        use crate::state::ProjectMetadata;\r\n\r\n        let state = ProjectState {\r\n            timestamp: \"2023-01-01T00:00:00Z\".to_string(),\r\n            config_hash: \"test_config_hash\".to_string(),\r\n            files: std::collections::BTreeMap::new(),\r\n            metadata: ProjectMetadata {\r\n                project_name: \"test\".to_string(),\r\n                file_count: 0,\r\n                filters: vec![],\r\n                ignores: vec![],\r\n                line_numbers: false,\r\n            },\r\n        };\r\n\r\n        // Write cache\r\n        assert!(cache_manager.write_cache(\u0026state).is_ok());\r\n\r\n        // Read cache\r\n        let cached_state = cache_manager.read_cache().unwrap();\r\n        assert!(cached_state.is_some());\r\n        assert_eq!(cached_state.unwrap().timestamp, state.timestamp);\r\n    }\r\n\r\n    #[test]\r\n    fn test_old_cache_migration() {\r\n        let dir = tempdir().unwrap();\r\n        let project_path = dir.path().join(\"test_project\");\r\n        let _ = fs::create_dir(\u0026project_path);\r\n\r\n        // Create cache directory with old cache files\r\n        let cache_dir = project_path.join(\".context-builder\").join(\"cache\");\r\n        let _ = fs::create_dir_all(\u0026cache_dir);\r\n\r\n        let old_files = [\r\n            \"last_canonical.md\",\r\n            \"last_output.md\",\r\n            \"current_output.md\",\r\n            \"output_20230101120000.md\",\r\n        ];\r\n\r\n        // Create old cache files\r\n        for file in \u0026old_files {\r\n            let old_path = cache_dir.join(file);\r\n            let _ = fs::write(\u0026old_path, \"old cache content\");\r\n            assert!(\r\n                old_path.exists(),\r\n                \"Old cache file should exist before migration\"\r\n            );\r\n        }\r\n\r\n        // Create cache manager (this should trigger migration)\r\n        let config = Config::default();\r\n        let _cache_manager = CacheManager::new(\u0026project_path, \u0026config);\r\n\r\n        // Verify old files are removed\r\n        for file in \u0026old_files {\r\n            let old_path = cache_dir.join(file);\r\n            assert!(\r\n                !old_path.exists(),\r\n                \"Old cache file {} should be removed after migration\",\r\n                file\r\n            );\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    fn test_cache_consistency_across_path_representations() {\r\n        let dir = tempdir().unwrap();\r\n        let project_path = dir.path().join(\"test_project\");\r\n        let _ = fs::create_dir(\u0026project_path);\r\n\r\n        let config = Config::default();\r\n\r\n        // Test different path representations that should resolve to the same cache\r\n        let mut paths_to_test = vec![\r\n            project_path.clone(),\r\n            project_path.canonicalize().unwrap_or(project_path.clone()),\r\n        ];\r\n\r\n        // If we can create a relative path, test that too\r\n        if let Ok(current_dir) = std::env::current_dir()\r\n            \u0026\u0026 let Ok(relative) = project_path.strip_prefix(\u0026current_dir)\r\n        {\r\n            paths_to_test.push(relative.to_path_buf());\r\n        }\r\n\r\n        let mut cache_paths = Vec::new();\r\n        for path in \u0026paths_to_test {\r\n            let cache_manager = CacheManager::new(path, \u0026config);\r\n            cache_paths.push(cache_manager.get_cache_path());\r\n        }\r\n\r\n        // All cache paths should be identical\r\n        for (i, path1) in cache_paths.iter().enumerate() {\r\n            for (j, path2) in cache_paths.iter().enumerate() {\r\n                if i != j {\r\n                    assert_eq!(\r\n                        path1, path2,\r\n                        \"Cache paths should be identical for different representations of the same project path\"\r\n                    );\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    fn test_normalize_path_format() {\r\n        // Test Windows UNC path normalization\r\n        if cfg!(windows) {\r\n            let unc_path = Path::new(\"\\\\\\\\?\\\\C:\\\\test\\\\path\");\r\n            let normalized = CacheManager::normalize_path_format(unc_path);\r\n            assert_eq!(normalized, PathBuf::from(\"C:\\\\test\\\\path\"));\r\n        }\r\n\r\n        // Test normal path (should remain unchanged)\r\n        let normal_path = Path::new(\"/normal/path\");\r\n        let normalized = CacheManager::normalize_path_format(normal_path);\r\n        assert_eq!(normalized, normal_path);\r\n    }\r\n\r\n    #[test]\r\n    fn test_cache_read_nonexistent_file() {\r\n        let dir = tempdir().unwrap();\r\n        let project_path = dir.path().join(\"nonexistent_project\");\r\n\r\n        let config = Config::default();\r\n        let cache_manager = CacheManager::new(\u0026project_path, \u0026config);\r\n\r\n        let result = cache_manager.read_cache().unwrap();\r\n        assert!(result.is_none());\r\n    }\r\n\r\n    #[test]\r\n    fn test_cache_read_corrupted_file() {\r\n        let dir = tempdir().unwrap();\r\n        let project_path = dir.path().join(\"test_project\");\r\n        let _ = fs::create_dir(\u0026project_path);\r\n\r\n        let config = Config::default();\r\n        let cache_manager = CacheManager::new(\u0026project_path, \u0026config);\r\n        let cache_path = cache_manager.get_cache_path();\r\n\r\n        // Create a corrupted cache file\r\n        let _ = fs::create_dir_all(cache_path.parent().unwrap());\r\n        let _ = fs::write(\u0026cache_path, \"invalid json content {{{\");\r\n\r\n        let result = cache_manager.read_cache();\r\n        assert!(result.is_err());\r\n    }\r\n\r\n    #[test]\r\n    fn test_cache_write_read_roundtrip() {\r\n        let dir = tempdir().unwrap();\r\n        let project_path = dir.path().join(\"test_project\");\r\n        let _ = fs::create_dir(\u0026project_path);\r\n\r\n        let config = Config {\r\n            filter: Some(vec![\"rs\".to_string(), \"toml\".to_string()]),\r\n            ignore: Some(vec![\"target\".to_string(), \".git\".to_string()]),\r\n            line_numbers: Some(true),\r\n            ..Default::default()\r\n        };\r\n\r\n        let cache_manager = CacheManager::new(\u0026project_path, \u0026config);\r\n\r\n        use crate::state::ProjectMetadata;\r\n        use std::collections::BTreeMap;\r\n\r\n        let mut files = BTreeMap::new();\r\n        files.insert(\r\n            PathBuf::from(\"test.rs\"),\r\n            crate::state::FileState {\r\n                content: \"fn main() {}\".to_string(),\r\n                size: 12,\r\n                modified: std::time::SystemTime::UNIX_EPOCH,\r\n                content_hash: \"test_hash\".to_string(),\r\n            },\r\n        );\r\n\r\n        let original_state = ProjectState {\r\n            timestamp: \"2023-01-01T12:00:00Z\".to_string(),\r\n            config_hash: \"test_config_hash\".to_string(),\r\n            files,\r\n            metadata: ProjectMetadata {\r\n                project_name: \"test_project\".to_string(),\r\n                file_count: 1,\r\n                filters: vec![\"rs\".to_string(), \"toml\".to_string()],\r\n                ignores: vec![\"target\".to_string(), \".git\".to_string()],\r\n                line_numbers: true,\r\n            },\r\n        };\r\n\r\n        // Write and read back\r\n        cache_manager.write_cache(\u0026original_state).unwrap();\r\n        let cached_state = cache_manager.read_cache().unwrap().unwrap();\r\n\r\n        assert_eq!(cached_state.timestamp, original_state.timestamp);\r\n        assert_eq!(cached_state.config_hash, original_state.config_hash);\r\n        assert_eq!(cached_state.files.len(), original_state.files.len());\r\n        assert_eq!(\r\n            cached_state.metadata.project_name,\r\n            original_state.metadata.project_name\r\n        );\r\n        assert_eq!(\r\n            cached_state.metadata.file_count,\r\n            original_state.metadata.file_count\r\n        );\r\n        assert_eq!(\r\n            cached_state.metadata.filters,\r\n            original_state.metadata.filters\r\n        );\r\n        assert_eq!(\r\n            cached_state.metadata.ignores,\r\n            original_state.metadata.ignores\r\n        );\r\n        assert_eq!(\r\n            cached_state.metadata.line_numbers,\r\n            original_state.metadata.line_numbers\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    fn test_different_configs_different_cache_files() {\r\n        let dir = tempdir().unwrap();\r\n        let project_path = dir.path().join(\"test_project\");\r\n        let _ = fs::create_dir(\u0026project_path);\r\n\r\n        let config1 = Config {\r\n            filter: Some(vec![\"rs\".to_string()]),\r\n            ..Default::default()\r\n        };\r\n\r\n        let config2 = Config {\r\n            filter: Some(vec![\"py\".to_string()]),\r\n            ..Default::default()\r\n        };\r\n\r\n        let cache_manager1 = CacheManager::new(\u0026project_path, \u0026config1);\r\n        let cache_manager2 = CacheManager::new(\u0026project_path, \u0026config2);\r\n\r\n        let cache_path1 = cache_manager1.get_cache_path();\r\n        let cache_path2 = cache_manager2.get_cache_path();\r\n\r\n        assert_ne!(\r\n            cache_path1, cache_path2,\r\n            \"Different configs should have different cache files\"\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    fn test_normalize_project_path_absolute() {\r\n        let temp_dir = tempdir().unwrap();\r\n        let project_path = temp_dir.path().join(\"test_project\");\r\n        let _ = fs::create_dir(\u0026project_path);\r\n\r\n        let normalized = CacheManager::normalize_project_path(\u0026project_path);\r\n        assert!(normalized.is_absolute());\r\n    }\r\n\r\n    #[test]\r\n    fn test_normalize_project_path_relative() {\r\n        let temp_dir = tempdir().unwrap();\r\n        let original_dir = std::env::current_dir().unwrap();\r\n\r\n        // Change to temp directory\r\n        std::env::set_current_dir(\u0026temp_dir).unwrap();\r\n\r\n        // Create a project directory\r\n        let project_name = \"relative_project\";\r\n        let _ = fs::create_dir(project_name);\r\n\r\n        let relative_path = Path::new(project_name);\r\n        let normalized = CacheManager::normalize_project_path(relative_path);\r\n\r\n        // Restore original directory\r\n        std::env::set_current_dir(original_dir).unwrap();\r\n\r\n        assert!(normalized.is_absolute());\r\n        assert!(normalized.to_string_lossy().contains(project_name));\r\n    }\r\n\r\n    #[test]\r\n    fn test_hash_config_same_values() {\r\n        let config1 = Config {\r\n            filter: Some(vec![\"rs\".to_string(), \"toml\".to_string()]),\r\n            ignore: Some(vec![\"target\".to_string()]),\r\n            line_numbers: Some(false),\r\n            ..Default::default()\r\n        };\r\n\r\n        let config2 = Config {\r\n            filter: Some(vec![\"rs\".to_string(), \"toml\".to_string()]),\r\n            ignore: Some(vec![\"target\".to_string()]),\r\n            line_numbers: Some(false),\r\n            ..Default::default()\r\n        };\r\n\r\n        let hash1 = CacheManager::hash_config(\u0026config1);\r\n        let hash2 = CacheManager::hash_config(\u0026config2);\r\n\r\n        assert_eq!(\r\n            hash1, hash2,\r\n            \"Identical configs should produce identical hashes\"\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    fn test_migrate_old_cache_preserves_new_files() {\r\n        let dir = tempdir().unwrap();\r\n        let project_path = dir.path().join(\"test_project\");\r\n        let _ = fs::create_dir(\u0026project_path);\r\n\r\n        let cache_dir = project_path.join(\".context-builder\").join(\"cache\");\r\n        let _ = fs::create_dir_all(\u0026cache_dir);\r\n\r\n        // Create both old and new cache files\r\n        let _ = fs::write(cache_dir.join(\"last_canonical.md\"), \"old content\");\r\n        let _ = fs::write(cache_dir.join(\"state_abc123_def456.json\"), \"new content\");\r\n\r\n        let config = Config::default();\r\n        let _cache_manager = CacheManager::new(\u0026project_path, \u0026config);\r\n\r\n        // Old file should be removed\r\n        assert!(!cache_dir.join(\"last_canonical.md\").exists());\r\n\r\n        // New file should be preserved\r\n        assert!(cache_dir.join(\"state_abc123_def456.json\").exists());\r\n    }\r\n}\r\n","traces":[{"line":28,"address":[],"length":0,"stats":{"Line":4971973988617027584}},{"line":30,"address":[],"length":0,"stats":{"Line":14915921965851082752}},{"line":32,"address":[],"length":0,"stats":{"Line":14915921965851082752}},{"line":33,"address":[],"length":0,"stats":{"Line":14915921965851082752}},{"line":36,"address":[],"length":0,"stats":{"Line":9943947977234055168}},{"line":39,"address":[],"length":0,"stats":{"Line":7638104968020361216}},{"line":40,"address":[],"length":0,"stats":{"Line":2666130979403333632}},{"line":50,"address":[],"length":0,"stats":{"Line":9943947977234055168}},{"line":52,"address":[],"length":0,"stats":{"Line":4971973988617027584}},{"line":56,"address":[],"length":0,"stats":{"Line":5116089176692883456}},{"line":58,"address":[],"length":0,"stats":{"Line":15348267530078650368}},{"line":59,"address":[],"length":0,"stats":{"Line":5476377146882523136}},{"line":61,"address":[],"length":0,"stats":{"Line":2377900603251621888}},{"line":62,"address":[],"length":0,"stats":{"Line":2377900603251621888}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":10160120759347838976}},{"line":71,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":76,"address":[],"length":0,"stats":{"Line":5116089176692883456}},{"line":77,"address":[],"length":0,"stats":{"Line":10232178353385766912}},{"line":78,"address":[],"length":0,"stats":{"Line":15348267530078650368}},{"line":79,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":83,"address":[],"length":0,"stats":{"Line":5188146770730811392}},{"line":84,"address":[],"length":0,"stats":{"Line":15564440312192434176}},{"line":87,"address":[],"length":0,"stats":{"Line":10376293541461622784}},{"line":88,"address":[],"length":0,"stats":{"Line":10232178353385766912}},{"line":90,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":95,"address":[],"length":0,"stats":{"Line":5260204364768739328}},{"line":96,"address":[],"length":0,"stats":{"Line":10520408729537478656}},{"line":98,"address":[],"length":0,"stats":{"Line":15780613094306217984}},{"line":99,"address":[],"length":0,"stats":{"Line":15780613094306217984}},{"line":100,"address":[],"length":0,"stats":{"Line":15780613094306217984}},{"line":101,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":105,"address":[],"length":0,"stats":{"Line":9295429630892703744}},{"line":106,"address":[],"length":0,"stats":{"Line":9439544818968559616}},{"line":107,"address":[],"length":0,"stats":{"Line":9295429630892703744}},{"line":108,"address":[],"length":0,"stats":{"Line":9295429630892703744}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":4971973988617027584}},{"line":119,"address":[],"length":0,"stats":{"Line":9943947977234055168}},{"line":121,"address":[],"length":0,"stats":{"Line":16357073846609641472}},{"line":123,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":124,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":125,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":130,"address":[],"length":0,"stats":{"Line":9943947977234055168}},{"line":131,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":134,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":135,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":136,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":143,"address":[],"length":0,"stats":{"Line":4539628424389459968}},{"line":144,"address":[],"length":0,"stats":{"Line":13618885273168379904}},{"line":146,"address":[],"length":0,"stats":{"Line":4539628424389459968}},{"line":147,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":150,"address":[],"length":0,"stats":{"Line":6269010681299730432}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":2089670227099910144}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":2089670227099910144}},{"line":161,"address":[],"length":0,"stats":{"Line":4179340454199820288}},{"line":166,"address":[],"length":0,"stats":{"Line":4395513236313604096}},{"line":167,"address":[],"length":0,"stats":{"Line":13186539708940812288}},{"line":169,"address":[],"length":0,"stats":{"Line":13186539708940812288}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":8791026472627208192}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":4395513236313604096}},{"line":179,"address":[],"length":0,"stats":{"Line":4395513236313604096}},{"line":181,"address":[],"length":0,"stats":{"Line":4395513236313604096}}],"covered":61,"coverable":68},{"path":["D:","\\","GitHub","context-builder","src","cli.rs"],"content":"use clap::Parser;\n\n/// CLI tool to aggregate directory contents into a single Markdown file optimized for LLM consumption\n#[derive(Parser, Debug, Clone)]\n#[clap(author, version, about)]\npub struct Args {\n    /// Directory path to process\n    #[clap(short = 'd', long, default_value = \".\")]\n    pub input: String,\n\n    /// Output file path\n    #[clap(short, long, default_value = \"output.md\")]\n    pub output: String,\n\n    /// File extensions to include (e.g., --filter rs,toml)\n    #[clap(short = 'f', long, value_delimiter = ',')]\n    pub filter: Vec\u003cString\u003e,\n\n    /// Folder or file names to ignore (e.g., --ignore target --ignore lock)\n    #[clap(short = 'i', long)]\n    pub ignore: Vec\u003cString\u003e,\n\n    /// Preview mode: only print the file tree to the console, don't generate the documentation file\n    #[clap(long)]\n    pub preview: bool,\n\n    /// Token count mode: estimate the total token count of the final document\n    #[clap(long)]\n    pub token_count: bool,\n\n    /// Add line numbers to code blocks in the output\n    #[clap(long)]\n    pub line_numbers: bool,\n\n    /// Automatically answer yes to all prompts\n    #[clap(short = 'y', long)]\n    pub yes: bool,\n\n    /// Output only diffs (omit full file contents; requires auto-diff \u0026 timestamped output)\n    #[clap(long, default_value_t = false)]\n    pub diff_only: bool,\n\n    /// Clear the cached project state and exit\n    #[clap(long)]\n    pub clear_cache: bool,\n}\n\n#[cfg(test)]\nmod tests {\n    use super::Args;\n    use clap::Parser;\n\n    #[test]\n    fn parses_with_no_args() {\n        let res = Args::try_parse_from([\"context-builder\"]);\n        assert!(res.is_ok(), \"Expected success when no args are provided\");\n    }\n\n    #[test]\n    fn parses_all_flags_and_options() {\n        let args = Args::try_parse_from([\n            \"context-builder\",\n            \"--input\",\n            \"some/dir\",\n            \"--output\",\n            \"ctx.md\",\n            \"--filter\",\n            \"rs\",\n            \"--filter\",\n            \"toml\",\n            \"--ignore\",\n            \"target\",\n            \"--ignore\",\n            \"node_modules\",\n            \"--preview\",\n            \"--token-count\",\n            \"--line-numbers\",\n            \"--diff-only\",\n            \"--clear-cache\",\n        ])\n        .expect(\"should parse\");\n\n        assert_eq!(args.input, \"some/dir\");\n        assert_eq!(args.output, \"ctx.md\");\n        assert_eq!(args.filter, vec![\"rs\".to_string(), \"toml\".to_string()]);\n        assert_eq!(\n            args.ignore,\n            vec![\"target\".to_string(), \"node_modules\".to_string()]\n        );\n        assert!(args.preview);\n        assert!(args.token_count);\n        assert!(args.line_numbers);\n        assert!(args.diff_only);\n        assert!(args.clear_cache);\n    }\n\n    #[test]\n    fn short_flags_parse_correctly() {\n        let args = Args::try_parse_from([\n            \"context-builder\",\n            \"-d\",\n            \".\",\n            \"-o\",\n            \"out.md\",\n            \"-f\",\n            \"md\",\n            \"-f\",\n            \"rs\",\n            \"-i\",\n            \"target\",\n            \"-i\",\n            \".git\",\n        ])\n        .expect(\"should parse\");\n\n        assert_eq!(args.input, \".\");\n        assert_eq!(args.output, \"out.md\");\n        assert_eq!(args.filter, vec![\"md\".to_string(), \"rs\".to_string()]);\n        assert_eq!(args.ignore, vec![\"target\".to_string(), \".git\".to_string()]);\n        assert!(!args.preview);\n        assert!(!args.line_numbers);\n        assert!(!args.clear_cache);\n    }\n\n    #[test]\n    fn defaults_for_options_when_not_provided() {\n        let args = Args::try_parse_from([\"context-builder\", \"-d\", \"proj\"]).expect(\"should parse\");\n\n        assert_eq!(args.input, \"proj\");\n        assert_eq!(args.output, \"output.md\");\n        assert!(args.filter.is_empty());\n        assert!(args.ignore.is_empty());\n        assert!(!args.preview);\n        assert!(!args.line_numbers);\n        assert!(!args.diff_only);\n        assert!(!args.clear_cache);\n    }\n\n    #[test]\n    fn parses_diff_only_flag() {\n        let args = Args::try_parse_from([\"context-builder\", \"--diff-only\"])\n            .expect(\"should parse diff-only flag\");\n        assert!(args.diff_only);\n        assert!(!args.clear_cache);\n    }\n\n    #[test]\n    fn parses_clear_cache_flag() {\n        let args = Args::try_parse_from([\"context-builder\", \"--clear-cache\"])\n            .expect(\"should parse clear-cache flag\");\n        assert!(args.clear_cache);\n        assert!(!args.diff_only);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","GitHub","context-builder","src","config.rs"],"content":"use serde::Deserialize;\nuse std::fs;\nuse std::path::Path;\n\n/// Global configuration loaded from `context-builder.toml`.\n///\n/// Any field left as `None` means \"use the CLI default / do not override\".\n/// Command-line arguments always take precedence over values provided here.\n///\n/// Example `context-builder.toml`:\n/// ```toml\n/// output = \"context.md\"\n/// output_folder = \"docs\"\n/// timestamped_output = true\n/// auto_diff = true\n/// diff_only = true         # Emit only change summary + modified file diffs (no full file bodies)\n/// filter = [\"rs\", \"toml\"]\n/// ignore = [\"target\", \".git\"]\n/// line_numbers = false\n/// diff_context_lines = 5\n/// ```\n///\n#[derive(Deserialize, Debug, Default, Clone)]\npub struct Config {\n    /// Output file name (or base name when `timestamped_output = true`)\n    pub output: Option\u003cString\u003e,\n\n    /// File extensions to include (no leading dot, e.g. `rs`, `toml`)\n    pub filter: Option\u003cVec\u003cString\u003e\u003e,\n\n    /// File / directory names to ignore (exact name matches)\n    pub ignore: Option\u003cVec\u003cString\u003e\u003e,\n\n    /// Add line numbers to code blocks\n    pub line_numbers: Option\u003cbool\u003e,\n\n    /// Preview only the file tree (no file output)\n    pub preview: Option\u003cbool\u003e,\n\n    /// Token counting mode\n    pub token_count: Option\u003cbool\u003e,\n\n    /// Optional folder to place the generated output file(s) in\n    pub output_folder: Option\u003cString\u003e,\n\n    /// If true, append a UTC timestamp to the output file name (before extension)\n    pub timestamped_output: Option\u003cbool\u003e,\n\n    /// Assume \"yes\" for overwrite / processing confirmations\n    pub yes: Option\u003cbool\u003e,\n\n    /// Enable automatic diff generation (requires `timestamped_output = true`)\n    pub auto_diff: Option\u003cbool\u003e,\n\n    /// Override number of unified diff context lines (falls back to env or default = 3)\n    pub diff_context_lines: Option\u003cusize\u003e,\n\n    /// When true, emit ONLY:\n    /// - Header + file tree\n    /// - Change Summary\n    /// - Per-file diffs for modified files\n    ///\n    /// Excludes full file contents section entirely. Added files appear only in the\n    /// change summary (and are marked Added) but their full content is omitted.\n    pub diff_only: Option\u003cbool\u003e,\n\n    /// Encoding handling strategy for non-UTF-8 files.\n    /// - \"detect\": Attempt to detect and transcode to UTF-8 (default)\n    /// - \"strict\": Only include valid UTF-8 files, skip others\n    /// - \"skip\": Skip all non-UTF-8 files without transcoding attempts\n    pub encoding_strategy: Option\u003cString\u003e,\n}\n\n/// Load configuration from `context-builder.toml` in the current working directory.\n/// Returns `None` if the file does not exist or cannot be parsed.\npub fn load_config() -\u003e Option\u003cConfig\u003e {\n    let config_path = Path::new(\"context-builder.toml\");\n    if config_path.exists() {\n        let content = fs::read_to_string(config_path).ok()?;\n        toml::from_str(\u0026content).ok()\n    } else {\n        None\n    }\n}\n\n/// Load configuration from `context-builder.toml` in the specified project root directory.\n/// Returns `None` if the file does not exist or cannot be parsed.\npub fn load_config_from_path(project_root: \u0026Path) -\u003e Option\u003cConfig\u003e {\n    let config_path = project_root.join(\"context-builder.toml\");\n    if config_path.exists() {\n        let content = fs::read_to_string(config_path).ok()?;\n        toml::from_str(\u0026content).ok()\n    } else {\n        None\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::fs;\n    use tempfile::tempdir;\n\n    #[test]\n    fn load_config_nonexistent_file() {\n        // Test loading config when file doesn't exist by temporarily changing directory\n        let temp_dir = tempdir().unwrap();\n        let original_dir = std::env::current_dir().unwrap();\n\n        // Change to temp directory where no config file exists\n        std::env::set_current_dir(\u0026temp_dir).unwrap();\n\n        let result = load_config();\n\n        // Restore original directory\n        std::env::set_current_dir(original_dir).unwrap();\n\n        assert!(result.is_none());\n    }\n\n    #[test]\n    fn load_config_from_path_nonexistent_file() {\n        let dir = tempdir().unwrap();\n        let result = load_config_from_path(dir.path());\n        assert!(result.is_none());\n    }\n\n    #[test]\n    fn load_config_from_path_valid_config() {\n        let dir = tempdir().unwrap();\n        let config_path = dir.path().join(\"context-builder.toml\");\n\n        let config_content = r#\"\noutput = \"test-output.md\"\nfilter = [\"rs\", \"toml\"]\nignore = [\"target\", \".git\"]\nline_numbers = true\npreview = false\ntoken_count = true\ntimestamped_output = true\nyes = false\nauto_diff = true\ndiff_context_lines = 5\ndiff_only = false\nencoding_strategy = \"detect\"\n\"#;\n\n        fs::write(\u0026config_path, config_content).unwrap();\n\n        let config = load_config_from_path(dir.path()).unwrap();\n        assert_eq!(config.output.unwrap(), \"test-output.md\");\n        assert_eq!(config.filter.unwrap(), vec![\"rs\", \"toml\"]);\n        assert_eq!(config.ignore.unwrap(), vec![\"target\", \".git\"]);\n        assert!(config.line_numbers.unwrap());\n        assert!(!config.preview.unwrap());\n        assert!(config.token_count.unwrap());\n        assert!(config.timestamped_output.unwrap());\n        assert!(!config.yes.unwrap());\n        assert!(config.auto_diff.unwrap());\n        assert_eq!(config.diff_context_lines.unwrap(), 5);\n        assert!(!config.diff_only.unwrap());\n        assert_eq!(config.encoding_strategy.unwrap(), \"detect\");\n    }\n\n    #[test]\n    fn load_config_from_path_partial_config() {\n        let dir = tempdir().unwrap();\n        let config_path = dir.path().join(\"context-builder.toml\");\n\n        let config_content = r#\"\noutput = \"minimal.md\"\nfilter = [\"py\"]\n\"#;\n\n        fs::write(\u0026config_path, config_content).unwrap();\n\n        let config = load_config_from_path(dir.path()).unwrap();\n        assert_eq!(config.output.unwrap(), \"minimal.md\");\n        assert_eq!(config.filter.unwrap(), vec![\"py\"]);\n        assert!(config.ignore.is_none());\n        assert!(config.line_numbers.is_none());\n        assert!(config.auto_diff.is_none());\n    }\n\n    #[test]\n    fn load_config_from_path_invalid_toml() {\n        let dir = tempdir().unwrap();\n        let config_path = dir.path().join(\"context-builder.toml\");\n\n        // Invalid TOML content\n        let config_content = r#\"\noutput = \"test.md\"\ninvalid_toml [\n\"#;\n\n        fs::write(\u0026config_path, config_content).unwrap();\n\n        let config = load_config_from_path(dir.path());\n        assert!(config.is_none());\n    }\n\n    #[test]\n    fn load_config_from_path_empty_config() {\n        let dir = tempdir().unwrap();\n        let config_path = dir.path().join(\"context-builder.toml\");\n\n        fs::write(\u0026config_path, \"\").unwrap();\n\n        let config = load_config_from_path(dir.path()).unwrap();\n        assert!(config.output.is_none());\n        assert!(config.filter.is_none());\n        assert!(config.ignore.is_none());\n    }\n\n    #[test]\n    fn config_default_implementation() {\n        let config = Config::default();\n        assert!(config.output.is_none());\n        assert!(config.filter.is_none());\n        assert!(config.ignore.is_none());\n        assert!(config.line_numbers.is_none());\n        assert!(config.preview.is_none());\n        assert!(config.token_count.is_none());\n        assert!(config.output_folder.is_none());\n        assert!(config.timestamped_output.is_none());\n        assert!(config.yes.is_none());\n        assert!(config.auto_diff.is_none());\n        assert!(config.diff_context_lines.is_none());\n        assert!(config.diff_only.is_none());\n        assert!(config.encoding_strategy.is_none());\n    }\n}\n","traces":[{"line":76,"address":[],"length":0,"stats":{"Line":1945555039024054272}},{"line":77,"address":[],"length":0,"stats":{"Line":5836665117072162816}},{"line":78,"address":[],"length":0,"stats":{"Line":3891110078048108544}},{"line":79,"address":[],"length":0,"stats":{"Line":7493989779944505344}},{"line":82,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":88,"address":[],"length":0,"stats":{"Line":2233785415175766016}},{"line":89,"address":[],"length":0,"stats":{"Line":6701356245527298048}},{"line":90,"address":[],"length":0,"stats":{"Line":2233785415175766016}},{"line":91,"address":[],"length":0,"stats":{"Line":8646911284551352320}},{"line":94,"address":[],"length":0,"stats":{"Line":72057594037927936}}],"covered":10,"coverable":10},{"path":["D:","\\","GitHub","context-builder","src","config_resolver.rs"],"content":"//! Configuration resolution module for context-builder.\r\n//!\r\n//! This module provides centralized logic for merging CLI arguments with configuration\r\n//! file values, implementing proper precedence rules and handling complex scenarios\r\n//! like timestamping and output folder resolution.\r\n\r\nuse chrono::Utc;\r\nuse std::path::{Path, PathBuf};\r\n\r\nuse crate::cli::Args;\r\nuse crate::config::Config;\r\n\r\n/// Resolved configuration combining CLI arguments and config file values\r\n#[derive(Debug, Clone)]\r\npub struct ResolvedConfig {\r\n    pub input: String,\r\n    pub output: String,\r\n    pub filter: Vec\u003cString\u003e,\r\n    pub ignore: Vec\u003cString\u003e,\r\n    pub line_numbers: bool,\r\n    pub preview: bool,\r\n    pub token_count: bool,\r\n    pub yes: bool,\r\n    pub diff_only: bool,\r\n    pub clear_cache: bool,\r\n    pub auto_diff: bool,\r\n    pub diff_context_lines: usize,\r\n}\r\n\r\n/// Result of configuration resolution including the final config and any warnings\r\n#[derive(Debug)]\r\npub struct ConfigResolution {\r\n    pub config: ResolvedConfig,\r\n    pub warnings: Vec\u003cString\u003e,\r\n}\r\n\r\n/// Resolves final configuration by merging CLI arguments with config file values.\r\n///\r\n/// Precedence rules (highest to lowest):\r\n/// 1. Explicit CLI arguments (non-default values)\r\n/// 2. Configuration file values\r\n/// 3. CLI default values\r\n///\r\n/// Special handling:\r\n/// - `output` field supports timestamping and output folder resolution\r\n/// - Boolean flags respect explicit CLI usage vs defaults\r\n/// - Arrays (filter, ignore) use CLI if non-empty, otherwise config file\r\npub fn resolve_final_config(mut args: Args, config: Option\u003cConfig\u003e) -\u003e ConfigResolution {\r\n    let mut warnings = Vec::new();\r\n\r\n    // Start with CLI defaults, then apply config file, then explicit CLI overrides\r\n    let final_config = if let Some(config) = config {\r\n        apply_config_to_args(\u0026mut args, \u0026config, \u0026mut warnings);\r\n        resolve_output_path(\u0026mut args, \u0026config, \u0026mut warnings);\r\n        config\r\n    } else {\r\n        Config::default()\r\n    };\r\n\r\n    let resolved = ResolvedConfig {\r\n        input: args.input,\r\n        output: args.output,\r\n        filter: args.filter,\r\n        ignore: args.ignore,\r\n        line_numbers: args.line_numbers,\r\n        preview: args.preview,\r\n        token_count: args.token_count,\r\n        yes: args.yes,\r\n        diff_only: args.diff_only,\r\n        clear_cache: args.clear_cache,\r\n        auto_diff: final_config.auto_diff.unwrap_or(false),\r\n        diff_context_lines: final_config.diff_context_lines.unwrap_or(3),\r\n    };\r\n\r\n    ConfigResolution {\r\n        config: resolved,\r\n        warnings,\r\n    }\r\n}\r\n\r\n/// Apply configuration file values to CLI arguments based on precedence rules\r\nfn apply_config_to_args(args: \u0026mut Args, config: \u0026Config, warnings: \u0026mut Vec\u003cString\u003e) {\r\n    // Output: only apply config if CLI is using default value\r\n    if args.output == \"output.md\"\r\n        \u0026\u0026 let Some(ref output) = config.output\r\n    {\r\n        args.output = output.clone();\r\n    }\r\n\r\n    // Filter: CLI takes precedence if non-empty\r\n    if args.filter.is_empty()\r\n        \u0026\u0026 let Some(ref filter) = config.filter\r\n    {\r\n        args.filter = filter.clone();\r\n    }\r\n\r\n    // Ignore: CLI takes precedence if non-empty\r\n    if args.ignore.is_empty()\r\n        \u0026\u0026 let Some(ref ignore) = config.ignore\r\n    {\r\n        args.ignore = ignore.clone();\r\n    }\r\n\r\n    // Boolean flags: config applies only if CLI is using default (false)\r\n    // Note: We can't distinguish between explicit --no-flag and default false,\r\n    // so config file can only enable features, not disable them\r\n    if !args.line_numbers\r\n        \u0026\u0026 let Some(line_numbers) = config.line_numbers\r\n    {\r\n        args.line_numbers = line_numbers;\r\n    }\r\n\r\n    if !args.preview\r\n        \u0026\u0026 let Some(preview) = config.preview\r\n    {\r\n        args.preview = preview;\r\n    }\r\n\r\n    if !args.token_count\r\n        \u0026\u0026 let Some(token_count) = config.token_count\r\n    {\r\n        args.token_count = token_count;\r\n    }\r\n\r\n    if !args.yes\r\n        \u0026\u0026 let Some(yes) = config.yes\r\n    {\r\n        args.yes = yes;\r\n    }\r\n\r\n    // diff_only: config can enable it, but CLI flag always takes precedence\r\n    if !args.diff_only\r\n        \u0026\u0026 let Some(true) = config.diff_only\r\n    {\r\n        args.diff_only = true;\r\n    }\r\n\r\n    // Validate auto_diff configuration\r\n    if let Some(true) = config.auto_diff\r\n        \u0026\u0026 config.timestamped_output != Some(true)\r\n    {\r\n        warnings.push(\r\n            \"auto_diff is enabled but timestamped_output is not enabled. \\\r\n            Auto-diff requires timestamped_output = true to function properly.\"\r\n                .to_string(),\r\n        );\r\n    }\r\n}\r\n\r\n/// Resolve output path including timestamping and output folder logic\r\nfn resolve_output_path(args: \u0026mut Args, config: \u0026Config, warnings: \u0026mut Vec\u003cString\u003e) {\r\n    let mut output_folder_path: Option\u003cPathBuf\u003e = None;\r\n\r\n    // Apply output folder first\r\n    if let Some(ref output_folder) = config.output_folder {\r\n        let mut path = PathBuf::from(output_folder);\r\n        path.push(\u0026args.output);\r\n        args.output = path.to_string_lossy().to_string();\r\n        output_folder_path = Some(PathBuf::from(output_folder));\r\n    }\r\n\r\n    // Apply timestamping if enabled\r\n    if let Some(true) = config.timestamped_output {\r\n        let timestamp = Utc::now().format(\"%Y%m%d%H%M%S\").to_string();\r\n        let path = Path::new(\u0026args.output);\r\n\r\n        let stem = path\r\n            .file_stem()\r\n            .and_then(|s| s.to_str())\r\n            .unwrap_or(\"output\");\r\n\r\n        let extension = path.extension().and_then(|s| s.to_str()).unwrap_or(\"md\");\r\n\r\n        let new_filename = format!(\"{}_{}.{}\", stem, timestamp, extension);\r\n\r\n        if let Some(output_folder) = output_folder_path {\r\n            args.output = output_folder\r\n                .join(new_filename)\r\n                .to_string_lossy()\r\n                .to_string();\r\n        } else {\r\n            let new_path = path.with_file_name(new_filename);\r\n            args.output = new_path.to_string_lossy().to_string();\r\n        }\r\n    }\r\n\r\n    // Validate output folder exists if specified\r\n    if let Some(ref output_folder) = config.output_folder {\r\n        let folder_path = Path::new(output_folder);\r\n        if !folder_path.exists() {\r\n            warnings.push(format!(\r\n                \"Output folder '{}' does not exist. It will be created if possible.\",\r\n                output_folder\r\n            ));\r\n        }\r\n    }\r\n}\r\n\r\n/// Check if CLI arguments have been explicitly set vs using defaults.\r\n/// This is a best-effort detection since clap doesn't provide this information directly.\r\n#[allow(dead_code)]\r\nfn detect_explicit_args() -\u003e ExplicitArgs {\r\n    let args: Vec\u003cString\u003e = std::env::args().collect();\r\n\r\n    ExplicitArgs {\r\n        output: args.iter().any(|arg| arg == \"-o\" || arg == \"--output\"),\r\n        filter: args.iter().any(|arg| arg == \"-f\" || arg == \"--filter\"),\r\n        ignore: args.iter().any(|arg| arg == \"-i\" || arg == \"--ignore\"),\r\n        line_numbers: args.iter().any(|arg| arg == \"--line-numbers\"),\r\n        preview: args.iter().any(|arg| arg == \"--preview\"),\r\n        token_count: args.iter().any(|arg| arg == \"--token-count\"),\r\n        yes: args.iter().any(|arg| arg == \"-y\" || arg == \"--yes\"),\r\n        diff_only: args.iter().any(|arg| arg == \"--diff-only\"),\r\n    }\r\n}\r\n\r\n/// Tracks which CLI arguments were explicitly provided vs using defaults\r\n#[allow(dead_code)]\r\nstruct ExplicitArgs {\r\n    output: bool,\r\n    filter: bool,\r\n    ignore: bool,\r\n    line_numbers: bool,\r\n    preview: bool,\r\n    token_count: bool,\r\n    yes: bool,\r\n    diff_only: bool,\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn test_config_precedence_cli_over_config() {\r\n        let args = Args {\r\n            input: \"src\".to_string(),\r\n            output: \"custom.md\".to_string(), // Explicit CLI value\r\n            filter: vec![\"rs\".to_string()],  // Explicit CLI value\r\n            ignore: vec![],\r\n            line_numbers: true, // Explicit CLI value\r\n            preview: false,\r\n            token_count: false,\r\n            yes: false,\r\n            diff_only: false,\r\n            clear_cache: false,\r\n        };\r\n\r\n        let config = Config {\r\n            output: Some(\"config.md\".to_string()),  // Should be ignored\r\n            filter: Some(vec![\"toml\".to_string()]), // Should be ignored\r\n            line_numbers: Some(false),              // Should be ignored\r\n            preview: Some(true),                    // Should apply\r\n            ..Default::default()\r\n        };\r\n\r\n        let resolution = resolve_final_config(args.clone(), Some(config));\r\n\r\n        assert_eq!(resolution.config.output, \"custom.md\"); // CLI wins\r\n        assert_eq!(resolution.config.filter, vec![\"rs\"]); // CLI wins\r\n        assert!(resolution.config.line_numbers); // CLI wins\r\n        assert!(resolution.config.preview); // Config applies\r\n    }\r\n\r\n    #[test]\r\n    fn test_config_applies_when_cli_uses_defaults() {\r\n        let args = Args {\r\n            input: \"src\".to_string(),\r\n            output: \"output.md\".to_string(), // Default value\r\n            filter: vec![],                  // Default value\r\n            ignore: vec![],                  // Default value\r\n            line_numbers: false,             // Default value\r\n            preview: false,                  // Default value\r\n            token_count: false,              // Default value\r\n            yes: false,                      // Default value\r\n            diff_only: false,                // Default value\r\n            clear_cache: false,\r\n        };\r\n\r\n        let config = Config {\r\n            output: Some(\"from_config.md\".to_string()),\r\n            filter: Some(vec![\"rs\".to_string(), \"toml\".to_string()]),\r\n            ignore: Some(vec![\"target\".to_string()]),\r\n            line_numbers: Some(true),\r\n            preview: Some(true),\r\n            token_count: Some(true),\r\n            yes: Some(true),\r\n            diff_only: Some(true),\r\n            ..Default::default()\r\n        };\r\n\r\n        let resolution = resolve_final_config(args, Some(config));\r\n\r\n        assert_eq!(resolution.config.output, \"from_config.md\");\r\n        assert_eq!(\r\n            resolution.config.filter,\r\n            vec![\"rs\".to_string(), \"toml\".to_string()]\r\n        );\r\n        assert_eq!(resolution.config.ignore, vec![\"target\".to_string()]);\r\n        assert!(resolution.config.line_numbers);\r\n        assert!(resolution.config.preview);\r\n        assert!(resolution.config.token_count);\r\n        assert!(resolution.config.yes);\r\n        assert!(resolution.config.diff_only);\r\n    }\r\n\r\n    #[test]\r\n    fn test_timestamped_output_resolution() {\r\n        let args = Args {\r\n            input: \"src\".to_string(),\r\n            output: \"test.md\".to_string(),\r\n            filter: vec![],\r\n            ignore: vec![],\r\n            line_numbers: false,\r\n            preview: false,\r\n            token_count: false,\r\n            yes: false,\r\n            diff_only: false,\r\n            clear_cache: false,\r\n        };\r\n\r\n        let config = Config {\r\n            timestamped_output: Some(true),\r\n            ..Default::default()\r\n        };\r\n\r\n        let resolution = resolve_final_config(args, Some(config));\r\n\r\n        // Output should have timestamp format: test_YYYYMMDDHHMMSS.md\r\n        assert!(resolution.config.output.starts_with(\"test_\"));\r\n        assert!(resolution.config.output.ends_with(\".md\"));\r\n        assert!(resolution.config.output.len() \u003e \"test_.md\".len());\r\n    }\r\n\r\n    #[test]\r\n    fn test_output_folder_resolution() {\r\n        let args = Args {\r\n            input: \"src\".to_string(),\r\n            output: \"test.md\".to_string(),\r\n            filter: vec![],\r\n            ignore: vec![],\r\n            line_numbers: false,\r\n            preview: false,\r\n            token_count: false,\r\n            yes: false,\r\n            diff_only: false,\r\n            clear_cache: false,\r\n        };\r\n\r\n        let config = Config {\r\n            output_folder: Some(\"docs\".to_string()),\r\n            ..Default::default()\r\n        };\r\n\r\n        let resolution = resolve_final_config(args, Some(config));\r\n\r\n        assert!(resolution.config.output.contains(\"docs\"));\r\n        assert!(resolution.config.output.ends_with(\"test.md\"));\r\n    }\r\n\r\n    #[test]\r\n    fn test_output_folder_with_timestamping() {\r\n        let args = Args {\r\n            input: \"src\".to_string(),\r\n            output: \"test.md\".to_string(),\r\n            filter: vec![],\r\n            ignore: vec![],\r\n            line_numbers: false,\r\n            preview: false,\r\n            token_count: false,\r\n            yes: false,\r\n            diff_only: false,\r\n            clear_cache: false,\r\n        };\r\n\r\n        let config = Config {\r\n            output_folder: Some(\"docs\".to_string()),\r\n            timestamped_output: Some(true),\r\n            ..Default::default()\r\n        };\r\n\r\n        let resolution = resolve_final_config(args, Some(config));\r\n\r\n        assert!(resolution.config.output.contains(\"docs\"));\r\n        assert!(resolution.config.output.contains(\"test_\"));\r\n        assert!(resolution.config.output.ends_with(\".md\"));\r\n    }\r\n\r\n    #[test]\r\n    fn test_auto_diff_without_timestamping_warning() {\r\n        let args = Args {\r\n            input: \"src\".to_string(),\r\n            output: \"test.md\".to_string(),\r\n            filter: vec![],\r\n            ignore: vec![],\r\n            line_numbers: false,\r\n            preview: false,\r\n            token_count: false,\r\n            yes: false,\r\n            diff_only: false,\r\n            clear_cache: false,\r\n        };\r\n\r\n        let config = Config {\r\n            auto_diff: Some(true),\r\n            timestamped_output: Some(false), // This should generate a warning\r\n            ..Default::default()\r\n        };\r\n\r\n        let resolution = resolve_final_config(args, Some(config));\r\n\r\n        assert!(!resolution.warnings.is_empty());\r\n        assert!(resolution.warnings[0].contains(\"auto_diff\"));\r\n        assert!(resolution.warnings[0].contains(\"timestamped_output\"));\r\n    }\r\n\r\n    #[test]\r\n    fn test_no_config_uses_cli_defaults() {\r\n        let args = Args {\r\n            input: \"src\".to_string(),\r\n            output: \"output.md\".to_string(),\r\n            filter: vec![],\r\n            ignore: vec![],\r\n            line_numbers: false,\r\n            preview: false,\r\n            token_count: false,\r\n            yes: false,\r\n            diff_only: false,\r\n            clear_cache: false,\r\n        };\r\n\r\n        let resolution = resolve_final_config(args.clone(), None);\r\n\r\n        assert_eq!(resolution.config.input, args.input);\r\n        assert_eq!(resolution.config.output, args.output);\r\n        assert_eq!(resolution.config.filter, args.filter);\r\n        assert_eq!(resolution.config.ignore, args.ignore);\r\n        assert_eq!(resolution.config.line_numbers, args.line_numbers);\r\n        assert_eq!(resolution.config.preview, args.preview);\r\n        assert_eq!(resolution.config.token_count, args.token_count);\r\n        assert_eq!(resolution.config.yes, args.yes);\r\n        assert_eq!(resolution.config.diff_only, args.diff_only);\r\n        assert!(!resolution.config.auto_diff);\r\n        assert_eq!(resolution.config.diff_context_lines, 3);\r\n        assert!(resolution.warnings.is_empty());\r\n    }\r\n}\r\n","traces":[{"line":48,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":49,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":52,"address":[],"length":0,"stats":{"Line":3602879701896396800}},{"line":57,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":61,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":62,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":63,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":64,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":65,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":66,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":67,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":68,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":69,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":70,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":71,"address":[],"length":0,"stats":{"Line":3674937295934324736}},{"line":72,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":82,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":84,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":85,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":87,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":91,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":92,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":94,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":98,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":99,"address":[],"length":0,"stats":{"Line":1369094286720630784}},{"line":101,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":107,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":108,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":113,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":114,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":119,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":120,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":125,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":126,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":132,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":133,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":135,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":139,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":140,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":142,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":143,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":144,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":145,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":151,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":152,"address":[],"length":0,"stats":{"Line":3458764513820540928}},{"line":155,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":163,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":164,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":165,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":167,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":169,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":172,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":174,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":176,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":182,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":183,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":188,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}}],"covered":57,"coverable":71},{"path":["D:","\\","GitHub","context-builder","src","diff.rs"],"content":"use similar::{ChangeTag, TextDiff};\nuse std::collections::HashMap;\n\n/// Line based diff utilities.\n///\n/// This module previously exposed `generate_diff` which produced a single\n/// \"## File Differences\" section for an entire markdown document. That\n/// approach made it easy for volatile sections (timestamps, file tree\n/// structure, etc.) to create noisy diffs. To address this the new\n/// per‑file API lets the caller diff only the normalized *file content*\n/// blocks that appear under each `### File: `path`` heading in the\n/// canonical output, completely ignoring the global header or the file\n/// tree portion. Each file receives an isolated unified style diff.\n///\n/// High level additions:\n/// * `PerFileStatus` – classification of the change.\n/// * `PerFileDiff` – structured diff result for a single file.\n/// * `diff_file_contents` – core engine producing diffs per file without any\n///   global \"## File Differences\" header.\n/// * `render_per_file_diffs` – helper to render the per file diffs into\n///   markdown (still omits a global header so the caller can choose).\n///\n/// Backwards compatibility: the existing `generate_diff` function (full\n/// document diff) is retained for now. New code should prefer the\n/// per‑file functions.\n/// Determine number of context lines either from explicit argument or env.\nfn resolve_context_lines(explicit: Option\u003cusize\u003e) -\u003e usize {\n    explicit\n        .filter(|v| *v \u003e 0)\n        .or_else(|| {\n            std::env::var(\"CB_DIFF_CONTEXT_LINES\")\n                .ok()\n                .and_then(|v| v.parse().ok())\n                .filter(|v: \u0026usize| *v \u003e 0)\n        })\n        .unwrap_or(3)\n}\n\n/// Original API: produce a single markdown section headed by \"## File Differences\".\n/// (Kept unchanged for compatibility.)\npub fn generate_diff(old_content: \u0026str, new_content: \u0026str) -\u003e String {\n    let diff = TextDiff::from_lines(old_content, new_content);\n    if diff.ratio() == 1.0 {\n        return String::new();\n    }\n    let context_lines = resolve_context_lines(None);\n    let grouped = diff.grouped_ops(context_lines);\n    let mut out = String::new();\n    out.push_str(\"## File Differences\\n\\n\");\n    out.push_str(\"```diff\\n\");\n    for (group_index, group) in grouped.iter().enumerate() {\n        if group_index \u003e 0 {\n            out.push_str(\"  ...\\n\");\n        }\n        for op in group {\n            for change in diff.iter_changes(op) {\n                let tag = change.tag();\n                let mut line = change.to_string();\n                if line.ends_with('\\n') {\n                    line.pop();\n                    if line.ends_with('\\r') {\n                        line.pop();\n                    }\n                }\n\n                match tag {\n                    ChangeTag::Delete =\u003e {\n                        out.push_str(\"- \");\n                        out.push_str(\u0026line);\n                        out.push('\\n');\n                    }\n                    ChangeTag::Insert =\u003e {\n                        out.push_str(\"+ \");\n                        out.push_str(\u0026line);\n                        out.push('\\n');\n                    }\n                    ChangeTag::Equal =\u003e {\n                        out.push_str(\"  \");\n                        out.push_str(\u0026line);\n                        out.push('\\n');\n                    }\n                }\n            }\n        }\n    }\n    out.push_str(\"```\\n\\n\");\n    out\n}\n\n/// Classification of how a file changed between two snapshots.\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum PerFileStatus {\n    Added,\n    Removed,\n    Modified,\n    Unchanged,\n}\n\n/// Structured diff result for a single file.\n#[derive(Debug, Clone)]\npub struct PerFileDiff {\n    pub path: String,\n    pub status: PerFileStatus,\n    /// Unified diff fenced in ```diff (omitted when status == Unchanged and skip_unchanged=true)\n    pub diff: String,\n}\n\nimpl PerFileDiff {\n    pub fn is_changed(\u0026self) -\u003e bool {\n        self.status != PerFileStatus::Unchanged\n    }\n}\n\n/// Produce a unified style diff for two text blobs WITHOUT adding any global\n/// section header. Returns empty string if contents are identical.\nfn unified_no_header(old: \u0026str, new: \u0026str, context_lines: usize) -\u003e String {\n    let diff = TextDiff::from_lines(old, new);\n    if diff.ratio() == 1.0 {\n        return String::new();\n    }\n    let grouped = diff.grouped_ops(context_lines);\n    let mut out = String::new();\n    out.push_str(\"```diff\\n\");\n    for (group_index, group) in grouped.iter().enumerate() {\n        if group_index \u003e 0 {\n            out.push_str(\"  ...\\n\");\n        }\n        for op in group {\n            for change in diff.iter_changes(op) {\n                let tag = change.tag();\n                let mut line = change.to_string();\n                if line.ends_with('\\n') {\n                    line.pop();\n                    if line.ends_with('\\r') {\n                        line.pop();\n                    }\n                }\n\n                match tag {\n                    ChangeTag::Delete =\u003e {\n                        out.push_str(\"- \");\n                        out.push_str(\u0026line);\n                        out.push('\\n');\n                    }\n                    ChangeTag::Insert =\u003e {\n                        out.push_str(\"+ \");\n                        out.push_str(\u0026line);\n                        out.push('\\n');\n                    }\n                    ChangeTag::Equal =\u003e {\n                        out.push_str(\"  \");\n                        out.push_str(\u0026line);\n                        out.push('\\n');\n                    }\n                }\n            }\n        }\n    }\n    out.push_str(\"```\\n\");\n    out\n}\n\n/// Diff per file content sets.\n///\n/// Inputs are maps keyed by file path (relative or absolute – caller decides)\n/// with values being the raw file content EXACTLY as you wish it to be diffed\n/// (e.g. already stripped of volatile metadata, no size/modified lines, only\n/// the real file body). This keeps higher level logic (parsing the markdown\n/// document) out of the diff layer.\n///\n/// Returns a vector of `PerFileDiff` for every file that is Added, Removed,\n/// or Modified. Unchanged files are omitted by default (`skip_unchanged=true`)\n/// to reduce noise, but you can opt to include them.\npub fn diff_file_contents(\n    previous: \u0026HashMap\u003cString, String\u003e,\n    current: \u0026HashMap\u003cString, String\u003e,\n    skip_unchanged: bool,\n    explicit_context: Option\u003cusize\u003e,\n) -\u003e Vec\u003cPerFileDiff\u003e {\n    let mut all_paths: Vec\u003cString\u003e = previous.keys().chain(current.keys()).cloned().collect();\n    all_paths.sort();\n    all_paths.dedup();\n\n    let context_lines = resolve_context_lines(explicit_context);\n    let mut results = Vec::new();\n\n    for path in all_paths {\n        let old_opt = previous.get(\u0026path);\n        let new_opt = current.get(\u0026path);\n        match (old_opt, new_opt) {\n            (None, Some(new_content)) =\u003e {\n                // Added file: present only in current snapshot\n                let mut diff = String::new();\n                diff.push_str(\"```diff\\n\");\n                for line in new_content.lines() {\n                    diff.push_str(\"+ \");\n                    diff.push_str(line);\n                    diff.push('\\n');\n                }\n                diff.push_str(\"```\\n\");\n                results.push(PerFileDiff {\n                    path,\n                    status: PerFileStatus::Added,\n                    diff,\n                });\n            }\n            (Some(_old_content), None) =\u003e {\n                // Removed file\n                let old_content = previous.get(\u0026path).unwrap();\n                let mut diff = String::new();\n                diff.push_str(\"```diff\\n\");\n                for line in old_content.lines() {\n                    diff.push_str(\"- \");\n                    diff.push_str(line);\n                    diff.push('\\n');\n                }\n                diff.push_str(\"```\\n\");\n                results.push(PerFileDiff {\n                    path,\n                    status: PerFileStatus::Removed,\n                    diff,\n                });\n            }\n            (Some(old_content), Some(new_content)) =\u003e {\n                if old_content == new_content {\n                    if !skip_unchanged {\n                        results.push(PerFileDiff {\n                            path,\n                            status: PerFileStatus::Unchanged,\n                            diff: String::new(),\n                        });\n                    }\n                } else {\n                    let diff = unified_no_header(old_content, new_content, context_lines);\n                    results.push(PerFileDiff {\n                        path,\n                        status: PerFileStatus::Modified,\n                        diff,\n                    });\n                }\n            }\n            (None, None) =\u003e unreachable!(),\n        }\n    }\n\n    results\n}\n\n/// Render a collection of per file diffs into markdown WITHOUT a global\n/// \"## File Differences\" header. Each file begins with a \"### Diff: `\u003cpath\u003e`\"\n/// heading so that it can be appended near the changed files summary.\npub fn render_per_file_diffs(diffs: \u0026[PerFileDiff]) -\u003e String {\n    let mut out = String::new();\n    for d in diffs {\n        out.push_str(\u0026format!(\"### Diff: `{}`\\n\\n\", d.path));\n        match d.status {\n            PerFileStatus::Added =\u003e out.push_str(\"_Status: Added_\\n\\n\"),\n            PerFileStatus::Removed =\u003e out.push_str(\"_Status: Removed_\\n\\n\"),\n            PerFileStatus::Modified =\u003e out.push_str(\"_Status: Modified_\\n\\n\"),\n            PerFileStatus::Unchanged =\u003e {\n                out.push_str(\"_Status: Unchanged_\\n\\n\");\n            }\n        }\n        if !d.diff.is_empty() {\n            out.push_str(\u0026d.diff);\n            if !d.diff.ends_with('\\n') {\n                out.push('\\n');\n            }\n        }\n        out.push('\\n');\n    }\n    out\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn map(pairs: \u0026[(\u0026str, \u0026str)]) -\u003e HashMap\u003cString, String\u003e {\n        pairs\n            .iter()\n            .map(|(k, v)| (k.to_string(), v.to_string()))\n            .collect()\n    }\n\n    #[test]\n    fn unchanged_is_skipped() {\n        let prev = map(\u0026[(\"a.txt\", \"one\\n\")]);\n        let curr = map(\u0026[(\"a.txt\", \"one\\n\")]);\n        let diffs = diff_file_contents(\u0026prev, \u0026curr, true, Some(2));\n        assert!(diffs.is_empty());\n    }\n\n    #[test]\n    fn added_file_diff() {\n        let prev = map(\u0026[]);\n        let curr = map(\u0026[(\"new.rs\", \"fn main() {}\\n\")]);\n        let diffs = diff_file_contents(\u0026prev, \u0026curr, true, Some(2));\n        assert_eq!(diffs.len(), 1);\n        let d = \u0026diffs[0];\n        assert_eq!(d.status, PerFileStatus::Added);\n        assert!(d.diff.contains(\"+ fn main() {}\"));\n    }\n\n    #[test]\n    fn removed_file_diff() {\n        let prev = map(\u0026[(\"old.rs\", \"fn old() {}\\n\")]);\n        let curr = map(\u0026[]);\n        let diffs = diff_file_contents(\u0026prev, \u0026curr, true, None);\n        assert_eq!(diffs.len(), 1);\n        let d = \u0026diffs[0];\n        assert_eq!(d.status, PerFileStatus::Removed);\n        assert!(d.diff.contains(\"- fn old() {}\"));\n    }\n\n    #[test]\n    fn modified_file_diff() {\n        let prev = map(\u0026[(\"lib.rs\", \"fn add(a:i32,b:i32)-\u003ei32{a+b}\\n\")]);\n        let curr = map(\u0026[(\"lib.rs\", \"fn add(a: i32, b: i32) -\u003e i32 { a + b }\\n\")]);\n        let diffs = diff_file_contents(\u0026prev, \u0026curr, true, Some(1));\n        assert_eq!(diffs.len(), 1);\n        let d = \u0026diffs[0];\n        assert_eq!(d.status, PerFileStatus::Modified);\n        assert!(d.diff.contains(\"- fn add(a:i32,b:i32)-\u003ei32{a+b}\"));\n        assert!(d.diff.contains(\"+ fn add(a: i32, b: i32) -\u003e i32 { a + b }\"));\n    }\n\n    #[test]\n    fn include_unchanged_when_requested() {\n        let prev = map(\u0026[(\"a.txt\", \"same\\n\")]);\n        let curr = map(\u0026[(\"a.txt\", \"same\\n\")]);\n        let diffs = diff_file_contents(\u0026prev, \u0026curr, false, None);\n        assert_eq!(diffs.len(), 1);\n        assert_eq!(diffs[0].status, PerFileStatus::Unchanged);\n    }\n\n    #[test]\n    fn render_output_basic() {\n        let prev = map(\u0026[(\"a.txt\", \"one\\n\"), (\"b.txt\", \"line1\\nline2\\n\")]);\n        let curr = map(\u0026[\n            (\"a.txt\", \"two\\n\"),\n            (\"b.txt\", \"line1\\nline2\\n\"),\n            (\"c.txt\", \"new file\\n\"),\n        ]);\n        let diffs = diff_file_contents(\u0026prev, \u0026curr, true, Some(1));\n        let out = render_per_file_diffs(\u0026diffs);\n        assert!(out.contains(\"### Diff: `a.txt`\"));\n        assert!(out.contains(\"_Status: Modified_\"));\n        assert!(out.contains(\"+ two\"));\n        assert!(out.contains(\"### Diff: `c.txt`\"));\n        assert!(out.contains(\"_Status: Added_\"));\n        assert!(out.contains(\"+ new file\"));\n    }\n\n    #[test]\n    fn test_empty_files() {\n        let prev = map(\u0026[(\"empty.txt\", \"\")]);\n        let curr = map(\u0026[(\"empty.txt\", \"\")]);\n        let diffs = diff_file_contents(\u0026prev, \u0026curr, true, None);\n        assert!(diffs.is_empty());\n    }\n\n    #[test]\n    fn test_empty_to_content() {\n        let prev = map(\u0026[(\"file.txt\", \"\")]);\n        let curr = map(\u0026[(\"file.txt\", \"new content\\n\")]);\n        let diffs = diff_file_contents(\u0026prev, \u0026curr, true, None);\n        assert_eq!(diffs.len(), 1);\n        assert_eq!(diffs[0].status, PerFileStatus::Modified);\n        assert!(diffs[0].diff.contains(\"+ new content\"));\n    }\n\n    #[test]\n    fn test_content_to_empty() {\n        let prev = map(\u0026[(\"file.txt\", \"old content\\n\")]);\n        let curr = map(\u0026[(\"file.txt\", \"\")]);\n        let diffs = diff_file_contents(\u0026prev, \u0026curr, true, None);\n        assert_eq!(diffs.len(), 1);\n        assert_eq!(diffs[0].status, PerFileStatus::Modified);\n        assert!(diffs[0].diff.contains(\"- old content\"));\n    }\n\n    #[test]\n    fn test_multiline_modifications() {\n        let prev = map(\u0026[(\"file.txt\", \"line1\\nline2\\nline3\\nline4\\n\")]);\n        let curr = map(\u0026[(\"file.txt\", \"line1\\nmodified2\\nline3\\nline4\\n\")]);\n        let diffs = diff_file_contents(\u0026prev, \u0026curr, true, Some(2));\n        assert_eq!(diffs.len(), 1);\n        assert_eq!(diffs[0].status, PerFileStatus::Modified);\n        assert!(diffs[0].diff.contains(\"- line2\"));\n        assert!(diffs[0].diff.contains(\"+ modified2\"));\n    }\n\n    #[test]\n    fn test_windows_line_endings() {\n        let prev = map(\u0026[(\"file.txt\", \"line1\\r\\nline2\\r\\n\")]);\n        let curr = map(\u0026[(\"file.txt\", \"line1\\r\\nmodified2\\r\\n\")]);\n        let diffs = diff_file_contents(\u0026prev, \u0026curr, true, None);\n        assert_eq!(diffs.len(), 1);\n        assert_eq!(diffs[0].status, PerFileStatus::Modified);\n        assert!(diffs[0].diff.contains(\"- line2\"));\n        assert!(diffs[0].diff.contains(\"+ modified2\"));\n    }\n\n    #[test]\n    fn test_per_file_diff_is_changed() {\n        let added = PerFileDiff {\n            path: \"test.txt\".to_string(),\n            status: PerFileStatus::Added,\n            diff: \"test\".to_string(),\n        };\n        assert!(added.is_changed());\n\n        let removed = PerFileDiff {\n            path: \"test.txt\".to_string(),\n            status: PerFileStatus::Removed,\n            diff: \"test\".to_string(),\n        };\n        assert!(removed.is_changed());\n\n        let modified = PerFileDiff {\n            path: \"test.txt\".to_string(),\n            status: PerFileStatus::Modified,\n            diff: \"test\".to_string(),\n        };\n        assert!(modified.is_changed());\n\n        let unchanged = PerFileDiff {\n            path: \"test.txt\".to_string(),\n            status: PerFileStatus::Unchanged,\n            diff: String::new(),\n        };\n        assert!(!unchanged.is_changed());\n    }\n\n    #[test]\n    fn test_generate_diff_identical_content() {\n        let content = \"line1\\nline2\\nline3\\n\";\n        let diff = generate_diff(content, content);\n        assert!(diff.is_empty());\n    }\n\n    #[test]\n    fn test_generate_diff_with_changes() {\n        let old = \"line1\\nline2\\nline3\\n\";\n        let new = \"line1\\nmodified2\\nline3\\n\";\n        let diff = generate_diff(old, new);\n        assert!(diff.contains(\"## File Differences\"));\n        assert!(diff.contains(\"```diff\"));\n        assert!(diff.contains(\"- line2\"));\n        assert!(diff.contains(\"+ modified2\"));\n    }\n\n    #[test]\n    fn test_resolve_context_lines_default() {\n        let context = resolve_context_lines(None);\n        assert_eq!(context, 3);\n    }\n\n    #[test]\n    fn test_resolve_context_lines_explicit() {\n        let context = resolve_context_lines(Some(5));\n        assert_eq!(context, 5);\n    }\n\n    #[test]\n    fn test_resolve_context_lines_zero_fallback() {\n        let context = resolve_context_lines(Some(0));\n        assert_eq!(context, 3); // Should fallback to default\n    }\n\n    #[test]\n    fn test_unicode_content_diff() {\n        let prev = map(\u0026[(\"unicode.txt\", \"Hello 世界\\n\")]);\n        let curr = map(\u0026[(\"unicode.txt\", \"Hello 世界! 🌍\\n\")]);\n        let diffs = diff_file_contents(\u0026prev, \u0026curr, true, None);\n        assert_eq!(diffs.len(), 1);\n        assert_eq!(diffs[0].status, PerFileStatus::Modified);\n        assert!(diffs[0].diff.contains(\"Hello 世界\"));\n        assert!(diffs[0].diff.contains(\"🌍\"));\n    }\n\n    #[test]\n    fn test_render_per_file_diffs_empty() {\n        let diffs = vec![];\n        let output = render_per_file_diffs(\u0026diffs);\n        assert!(output.is_empty());\n    }\n\n    #[test]\n    fn test_render_per_file_diffs_unchanged() {\n        let diffs = vec![PerFileDiff {\n            path: \"unchanged.txt\".to_string(),\n            status: PerFileStatus::Unchanged,\n            diff: String::new(),\n        }];\n        let output = render_per_file_diffs(\u0026diffs);\n        assert!(output.contains(\"### Diff: `unchanged.txt`\"));\n        assert!(output.contains(\"_Status: Unchanged_\"));\n    }\n\n    #[test]\n    fn test_render_per_file_diffs_without_trailing_newline() {\n        let diffs = vec![PerFileDiff {\n            path: \"test.txt\".to_string(),\n            status: PerFileStatus::Modified,\n            diff: \"```diff\\n+ line\\n```\".to_string(), // No trailing newline\n        }];\n        let output = render_per_file_diffs(\u0026diffs);\n        assert!(output.contains(\"### Diff: `test.txt`\"));\n        assert!(output.contains(\"_Status: Modified_\"));\n        assert!(output.ends_with(\"\\n\\n\")); // Should add newlines\n    }\n\n    #[test]\n    fn test_generate_diff_with_multiple_groups() {\n        // Create content that will result in multiple diff groups to trigger \"...\" separator\n        let old_content = \"line1\\nline2\\nline3\\nline4\\nline5\\nline6\\nline7\\nline8\\nline9\\nline10\";\n        let new_content = \"line1_modified\\nline2\\nline3\\nline4\\nline5\\nline6\\nline7\\nline8\\nline9_modified\\nline10\";\n\n        let diff = generate_diff(old_content, new_content);\n        assert!(diff.contains(\"```diff\"));\n        assert!(diff.contains(\"## File Differences\"));\n        // With sufficient distance between changes and small context, should create groups with \"...\" separator\n        println!(\"Generated diff: {}\", diff);\n    }\n\n    #[test]\n    fn test_diff_with_windows_line_endings() {\n        let old_content = \"line1\\r\\nline2\\r\\n\";\n        let new_content = \"line1_modified\\r\\nline2\\r\\n\";\n\n        let diff = generate_diff(old_content, new_content);\n        assert!(diff.contains(\"```diff\"));\n        assert!(diff.contains(\"line1_modified\"));\n        assert!(!diff.is_empty());\n    }\n\n    #[test]\n    fn test_unified_no_header_with_multiple_groups() {\n        // Create content that will result in multiple diff groups\n        let old_content = \"start\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nmiddle\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nend\";\n        let new_content =\n            \"start_modified\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nmiddle\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nend_modified\";\n\n        let diff = unified_no_header(old_content, new_content, 2);\n        assert!(diff.contains(\"```diff\"));\n        // Should contain \"...\" separator between groups when changes are far apart\n        println!(\"Unified diff: {}\", diff);\n    }\n\n    #[test]\n    fn test_unified_no_header_with_windows_line_endings() {\n        let old_content = \"line1\\r\\nline2\\r\\n\";\n        let new_content = \"line1_modified\\r\\nline2\\r\\n\";\n\n        let diff = unified_no_header(old_content, new_content, 3);\n        assert!(diff.contains(\"```diff\"));\n        assert!(diff.contains(\"line1_modified\"));\n        assert!(!diff.is_empty());\n    }\n}\n","traces":[{"line":27,"address":[],"length":0,"stats":{"Line":3098476543630901248}},{"line":28,"address":[],"length":0,"stats":{"Line":3098476543630901248}},{"line":29,"address":[],"length":0,"stats":{"Line":3602879701896396800}},{"line":30,"address":[],"length":0,"stats":{"Line":5764607523034234880}},{"line":31,"address":[],"length":0,"stats":{"Line":2666130979403333632}},{"line":32,"address":[],"length":0,"stats":{"Line":2666130979403333632}},{"line":33,"address":[],"length":0,"stats":{"Line":2666130979403333640}},{"line":34,"address":[],"length":0,"stats":{"Line":2666130979403333632}},{"line":41,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":42,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":43,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":44,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":51,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":52,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":53,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":55,"address":[],"length":0,"stats":{"Line":2738188573441261568}},{"line":56,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":60,"address":[],"length":0,"stats":{"Line":4899916394579099648}},{"line":61,"address":[],"length":0,"stats":{"Line":2666130979403333632}},{"line":62,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":67,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":68,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":69,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":70,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":72,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":73,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":74,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":75,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":77,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":78,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":79,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":80,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":109,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":110,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":116,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":117,"address":[],"length":0,"stats":{"Line":6341068275337658368}},{"line":118,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":1657324662872342528}},{"line":125,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":126,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":128,"address":[],"length":0,"stats":{"Line":7566047373982433280}},{"line":129,"address":[],"length":0,"stats":{"Line":4827858800541171712}},{"line":133,"address":[],"length":0,"stats":{"Line":9655717601082343424}},{"line":134,"address":[],"length":0,"stats":{"Line":5260204364768739328}},{"line":135,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":140,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":141,"address":[],"length":0,"stats":{"Line":6341068275337658368}},{"line":142,"address":[],"length":0,"stats":{"Line":6341068275337658368}},{"line":143,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":145,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":146,"address":[],"length":0,"stats":{"Line":6917529027641081856}},{"line":147,"address":[],"length":0,"stats":{"Line":6917529027641081856}},{"line":148,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":150,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":151,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":152,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":153,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":174,"address":[],"length":0,"stats":{"Line":2522015791327477760}},{"line":180,"address":[],"length":0,"stats":{"Line":4251398048237748224}},{"line":181,"address":[],"length":0,"stats":{"Line":2522015791327477760}},{"line":182,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":184,"address":[],"length":0,"stats":{"Line":7566047373982433280}},{"line":185,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":187,"address":[],"length":0,"stats":{"Line":14483576401623515136}},{"line":188,"address":[],"length":0,"stats":{"Line":5476377146882523136}},{"line":189,"address":[],"length":0,"stats":{"Line":5476377146882523136}},{"line":190,"address":[],"length":0,"stats":{"Line":11961560610296037376}},{"line":191,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":195,"address":[],"length":0,"stats":{"Line":1369094286720630784}},{"line":207,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":212,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":224,"address":[],"length":0,"stats":{"Line":9367487224930631680}},{"line":225,"address":[],"length":0,"stats":{"Line":4683743612465315840}},{"line":226,"address":[],"length":0,"stats":{"Line":3314649325744685056}},{"line":227,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":228,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":229,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":230,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":234,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":235,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":236,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":237,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":238,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":246,"address":[],"length":0,"stats":{"Line":2522015791327477760}},{"line":252,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":253,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":254,"address":[],"length":0,"stats":{"Line":5764607523034234880}},{"line":257,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":258,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":259,"address":[],"length":0,"stats":{"Line":3026418949592973312}},{"line":260,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":261,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":265,"address":[],"length":0,"stats":{"Line":2089670227099910144}},{"line":266,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":267,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":272,"address":[],"length":0,"stats":{"Line":1441151880758558720}}],"covered":96,"coverable":97},{"path":["D:","\\","GitHub","context-builder","src","file_utils.rs"],"content":"use ignore::{DirEntry, WalkBuilder, overrides::OverrideBuilder};\nuse std::fs;\nuse std::io::{self, Write};\nuse std::path::{Path, PathBuf};\n\n/// Collects all files to be processed using `ignore` crate for efficient traversal.\npub fn collect_files(\n    base_path: \u0026Path,\n    filters: \u0026[String],\n    ignores: \u0026[String],\n) -\u003e io::Result\u003cVec\u003cDirEntry\u003e\u003e {\n    let mut walker = WalkBuilder::new(base_path);\n    // By default, the \"ignore\" crate respects .gitignore and hidden files, so we don't need walker.hidden(false)\n\n    // Build overrides for custom ignore patterns\n    let mut override_builder = OverrideBuilder::new(base_path);\n    for pattern in ignores {\n        // Attention: Confusing pattern ahead!\n        // Add the pattern to the override builder with ! prefix to ignore matching files.\n        // In OverrideBuilder, patterns without ! are whitelist (include) patterns,\n        // while patterns with ! are ignore patterns.\n        let ignore_pattern = format!(\"!{}\", pattern);\n        if let Err(e) = override_builder.add(\u0026ignore_pattern) {\n            return Err(io::Error::new(\n                io::ErrorKind::InvalidInput,\n                format!(\"Invalid ignore pattern '{}': {}\", pattern, e),\n            ));\n        }\n    }\n    // Also, always ignore the config file itself\n    if let Err(e) = override_builder.add(\"!context-builder.toml\") {\n        return Err(io::Error::new(\n            io::ErrorKind::InvalidInput,\n            format!(\"Failed to add config ignore: {}\", e),\n        ));\n    }\n\n    let overrides = override_builder.build().map_err(|e| {\n        io::Error::new(\n            io::ErrorKind::InvalidInput,\n            format!(\"Failed to build overrides: {}\", e),\n        )\n    })?;\n    walker.overrides(overrides);\n\n    if !filters.is_empty() {\n        let mut type_builder = ignore::types::TypesBuilder::new();\n        type_builder.add_defaults();\n        for filter in filters {\n            let _ = type_builder.add(filter, \u0026format!(\"*.{}\", filter));\n            type_builder.select(filter);\n        }\n        let types = type_builder.build().unwrap();\n        walker.types(types);\n    }\n\n    let mut files: Vec\u003cDirEntry\u003e = walker\n        .build()\n        .filter_map(Result::ok)\n        .filter(|e| e.file_type().is_some_and(|ft| ft.is_file()))\n        .collect();\n\n    // FIX: Sort files deterministically by path to ensure consistent output order\n    files.sort_by(|a, b| a.path().cmp(b.path()));\n\n    Ok(files)\n}\n\n/// Asks for user confirmation if the number of files is large.\npub fn confirm_processing(file_count: usize) -\u003e io::Result\u003cbool\u003e {\n    if file_count \u003e 100 {\n        print!(\n            \"Warning: You're about to process {} files. This might take a while. Continue? [y/N] \",\n            file_count\n        );\n        io::stdout().flush()?;\n        let mut input = String::new();\n        io::stdin().read_line(\u0026mut input)?;\n        if !input.trim().eq_ignore_ascii_case(\"y\") {\n            return Ok(false);\n        }\n    }\n    Ok(true)\n}\n\n/// Asks for user confirmation to overwrite an existing file.\npub fn confirm_overwrite(file_path: \u0026str) -\u003e io::Result\u003cbool\u003e {\n    print!(\"The file '{}' already exists. Overwrite? [y/N] \", file_path);\n    io::stdout().flush()?;\n    let mut input = String::new();\n    io::stdin().read_line(\u0026mut input)?;\n\n    if input.trim().eq_ignore_ascii_case(\"y\") {\n        Ok(true)\n    } else {\n        Ok(false)\n    }\n}\n\npub fn find_latest_file(dir: \u0026Path) -\u003e io::Result\u003cOption\u003cPathBuf\u003e\u003e {\n    if !dir.is_dir() {\n        return Ok(None);\n    }\n\n    let mut latest_file = None;\n    let mut latest_time = std::time::SystemTime::UNIX_EPOCH;\n\n    for entry in fs::read_dir(dir)? {\n        let entry = entry?;\n        let path = entry.path();\n        if path.is_file() {\n            let metadata = fs::metadata(\u0026path)?;\n            let modified = metadata.modified()?;\n            if modified \u003e latest_time {\n                latest_time = modified;\n                latest_file = Some(path);\n            }\n        }\n    }\n\n    Ok(latest_file)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::fs;\n    use std::path::Path;\n    use tempfile::tempdir;\n\n    fn to_rel_paths(mut entries: Vec\u003cDirEntry\u003e, base: \u0026Path) -\u003e Vec\u003cString\u003e {\n        entries.sort_by_key(|e| e.path().to_path_buf());\n        entries\n            .iter()\n            .map(|e| {\n                e.path()\n                    .strip_prefix(base)\n                    .unwrap()\n                    .to_string_lossy()\n                    .replace('\\\\', \"/\")\n            })\n            .collect()\n    }\n\n    #[test]\n    fn collect_files_respects_filters() {\n        let dir = tempdir().unwrap();\n        let base = dir.path();\n\n        // create files\n        fs::create_dir_all(base.join(\"src\")).unwrap();\n        fs::create_dir_all(base.join(\"scripts\")).unwrap();\n        fs::write(base.join(\"src\").join(\"main.rs\"), \"fn main() {}\").unwrap();\n        fs::write(base.join(\"Cargo.toml\"), \"[package]\\nname=\\\"x\\\"\").unwrap();\n        fs::write(base.join(\"README.md\"), \"# readme\").unwrap();\n        fs::write(base.join(\"scripts\").join(\"build.sh\"), \"#!/bin/sh\\n\").unwrap();\n\n        let filters = vec![\"rs\".to_string(), \"toml\".to_string()];\n        let ignores: Vec\u003cString\u003e = vec![];\n\n        let files = collect_files(base, \u0026filters, \u0026ignores).unwrap();\n        let relative_paths = to_rel_paths(files, base);\n\n        assert!(relative_paths.contains(\u0026\"src/main.rs\".to_string()));\n        assert!(relative_paths.contains(\u0026\"Cargo.toml\".to_string()));\n        assert!(!relative_paths.contains(\u0026\"README.md\".to_string()));\n        assert!(!relative_paths.contains(\u0026\"scripts/build.sh\".to_string()));\n    }\n\n    #[test]\n    fn collect_files_respects_ignores_for_dirs_and_files() {\n        let dir = tempdir().unwrap();\n        let base = dir.path();\n\n        fs::create_dir_all(base.join(\"src\")).unwrap();\n        fs::create_dir_all(base.join(\"target\")).unwrap();\n        fs::create_dir_all(base.join(\"node_modules\")).unwrap();\n\n        fs::write(base.join(\"src\").join(\"main.rs\"), \"fn main() {}\").unwrap();\n        fs::write(base.join(\"target\").join(\"artifact.txt\"), \"bin\").unwrap();\n        fs::write(base.join(\"node_modules\").join(\"pkg.js\"), \"console.log();\").unwrap();\n        fs::write(base.join(\"README.md\"), \"# readme\").unwrap();\n\n        let filters: Vec\u003cString\u003e = vec![];\n        let ignores: Vec\u003cString\u003e = vec![\"target\".into(), \"node_modules\".into(), \"README.md\".into()];\n\n        let files = collect_files(base, \u0026filters, \u0026ignores).unwrap();\n        let relative_paths = to_rel_paths(files, base);\n\n        assert!(relative_paths.contains(\u0026\"src/main.rs\".to_string()));\n        assert!(!relative_paths.contains(\u0026\"target/artifact.txt\".to_string()));\n        assert!(!relative_paths.contains(\u0026\"node_modules/pkg.js\".to_string()));\n        assert!(!relative_paths.contains(\u0026\"README.md\".to_string()));\n    }\n\n    #[test]\n    fn collect_files_handles_invalid_ignore_pattern() {\n        let dir = tempdir().unwrap();\n        let base = dir.path();\n\n        fs::create_dir_all(base.join(\"src\")).unwrap();\n        fs::write(base.join(\"src\").join(\"main.rs\"), \"fn main() {}\").unwrap();\n\n        let filters: Vec\u003cString\u003e = vec![];\n        let ignores: Vec\u003cString\u003e = vec![\"[\".into()]; // Invalid regex pattern\n\n        let result = collect_files(base, \u0026filters, \u0026ignores);\n        assert!(result.is_err());\n        assert!(\n            result\n                .unwrap_err()\n                .to_string()\n                .contains(\"Invalid ignore pattern\")\n        );\n    }\n\n    #[test]\n    fn collect_files_empty_directory() {\n        let dir = tempdir().unwrap();\n        let base = dir.path();\n\n        let filters: Vec\u003cString\u003e = vec![];\n        let ignores: Vec\u003cString\u003e = vec![];\n\n        let files = collect_files(base, \u0026filters, \u0026ignores).unwrap();\n        assert!(files.is_empty());\n    }\n\n    #[test]\n    fn collect_files_no_matching_filters() {\n        let dir = tempdir().unwrap();\n        let base = dir.path();\n\n        fs::write(base.join(\"README.md\"), \"# readme\").unwrap();\n        fs::write(base.join(\"script.py\"), \"print('hello')\").unwrap();\n\n        let filters = vec![\"rs\".to_string()]; // Only Rust files\n        let ignores: Vec\u003cString\u003e = vec![];\n\n        let files = collect_files(base, \u0026filters, \u0026ignores).unwrap();\n        assert!(files.is_empty());\n    }\n\n    #[test]\n    fn collect_files_ignores_config_file() {\n        let dir = tempdir().unwrap();\n        let base = dir.path();\n\n        fs::write(base.join(\"context-builder.toml\"), \"[config]\").unwrap();\n        fs::write(base.join(\"other.toml\"), \"[other]\").unwrap();\n\n        let filters: Vec\u003cString\u003e = vec![];\n        let ignores: Vec\u003cString\u003e = vec![];\n\n        let files = collect_files(base, \u0026filters, \u0026ignores).unwrap();\n        let relative_paths = to_rel_paths(files, base);\n\n        assert!(!relative_paths.contains(\u0026\"context-builder.toml\".to_string()));\n        assert!(relative_paths.contains(\u0026\"other.toml\".to_string()));\n    }\n\n    #[test]\n    fn confirm_processing_small_count() {\n        // Test that small file counts don't require confirmation\n        let result = confirm_processing(50);\n        assert!(result.is_ok());\n        assert!(result.unwrap());\n    }\n\n    #[test]\n    fn find_latest_file_empty_directory() {\n        let dir = tempdir().unwrap();\n        let result = find_latest_file(dir.path()).unwrap();\n        assert!(result.is_none());\n    }\n\n    #[test]\n    fn find_latest_file_nonexistent_directory() {\n        let dir = tempdir().unwrap();\n        let nonexistent = dir.path().join(\"nonexistent\");\n        let result = find_latest_file(\u0026nonexistent).unwrap();\n        assert!(result.is_none());\n    }\n\n    #[test]\n    fn find_latest_file_single_file() {\n        let dir = tempdir().unwrap();\n        let file_path = dir.path().join(\"test.txt\");\n        fs::write(\u0026file_path, \"content\").unwrap();\n\n        let result = find_latest_file(dir.path()).unwrap();\n        assert!(result.is_some());\n        assert_eq!(result.unwrap(), file_path);\n    }\n\n    #[test]\n    fn find_latest_file_multiple_files() {\n        let dir = tempdir().unwrap();\n\n        let file1 = dir.path().join(\"old.txt\");\n        let file2 = dir.path().join(\"new.txt\");\n\n        fs::write(\u0026file1, \"old content\").unwrap();\n        std::thread::sleep(std::time::Duration::from_millis(10));\n        fs::write(\u0026file2, \"new content\").unwrap();\n\n        let result = find_latest_file(dir.path()).unwrap();\n        assert!(result.is_some());\n        assert_eq!(result.unwrap(), file2);\n    }\n\n    #[test]\n    fn find_latest_file_ignores_directories() {\n        let dir = tempdir().unwrap();\n        let subdir = dir.path().join(\"subdir\");\n        fs::create_dir(\u0026subdir).unwrap();\n\n        let file_path = dir.path().join(\"test.txt\");\n        fs::write(\u0026file_path, \"content\").unwrap();\n\n        let result = find_latest_file(dir.path()).unwrap();\n        assert!(result.is_some());\n        assert_eq!(result.unwrap(), file_path);\n    }\n\n    #[test]\n    fn test_confirm_processing_requires_user_interaction() {\n        // This test verifies the function signature and basic logic for large file counts\n        // The actual user interaction cannot be tested in unit tests\n\n        // For file counts \u003c= 100, should return Ok(true) without prompting\n        // This is already tested implicitly by the fact that small counts don't prompt\n\n        // For file counts \u003e 100, the function would prompt user input\n        // We can't easily test this without mocking stdin, but we can verify\n        // that the function exists and has the expected signature\n        use std::io::Cursor;\n\n        // Create a mock stdin that simulates user typing \"y\"\n        let input = b\"y\\n\";\n        let _ = Cursor::new(input);\n\n        // We can't easily override stdin in a unit test without complex setup,\n        // so we'll just verify the function exists and handles small counts\n        let result = confirm_processing(50);\n        assert!(result.is_ok());\n        assert!(result.unwrap());\n    }\n\n    #[test]\n    fn test_confirm_overwrite_function_exists() {\n        // Similar to confirm_processing, this function requires user interaction\n        // We can verify it exists and has the expected signature\n\n        // For testing purposes, we know this function prompts for user input\n        // and returns Ok(true) if user types \"y\" or \"Y\", Ok(false) otherwise\n\n        // The function signature should be:\n        // pub fn confirm_overwrite(file_path: \u0026str) -\u003e io::Result\u003cbool\u003e\n\n        // We can't easily test the interactive behavior without mocking stdin,\n        // but we can ensure the function compiles and has the right signature\n        let _: fn(\u0026str) -\u003e std::io::Result\u003cbool\u003e = confirm_overwrite;\n    }\n\n    #[test]\n    fn test_collect_files_handles_permission_errors() {\n        // Test what happens when we can't access a directory\n        // This is harder to test portably, but we can test with invalid patterns\n        let dir = tempdir().unwrap();\n        let base = dir.path();\n\n        // Test with a pattern that might cause issues\n        let filters: Vec\u003cString\u003e = vec![];\n        let ignores: Vec\u003cString\u003e = vec![\"[invalid\".into()]; // Incomplete bracket\n\n        let result = collect_files(base, \u0026filters, \u0026ignores);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_find_latest_file_permission_error() {\n        // Test behavior when we can't read directory metadata\n        use std::path::Path;\n\n        // Test with a path that doesn't exist\n        let nonexistent = Path::new(\"/this/path/should/not/exist/anywhere\");\n        let result = find_latest_file(nonexistent);\n\n        // Should return Ok(None) for non-existent directories\n        assert!(result.is_ok());\n        assert!(result.unwrap().is_none());\n    }\n\n    #[test]\n    fn test_collect_files_with_symlinks() {\n        // Test behavior with symbolic links (if supported on platform)\n        let dir = tempdir().unwrap();\n        let base = dir.path();\n\n        // Create a regular file\n        fs::write(base.join(\"regular.txt\"), \"content\").unwrap();\n\n        // On Unix-like systems, try creating a symlink\n        #[cfg(unix)]\n        {\n            use std::os::unix::fs::symlink;\n            let _ = symlink(\"regular.txt\", base.join(\"link.txt\"));\n        }\n\n        // On Windows, symlinks require special privileges, so skip this part\n        #[cfg(windows)]\n        {\n            // Just create another regular file to test\n            fs::write(base.join(\"another.txt\"), \"content2\").unwrap();\n        }\n\n        let filters: Vec\u003cString\u003e = vec![];\n        let ignores: Vec\u003cString\u003e = vec![];\n\n        let files = collect_files(base, \u0026filters, \u0026ignores).unwrap();\n        // Should find at least the regular file\n        assert!(!files.is_empty());\n    }\n}\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":11817445422220181504}},{"line":12,"address":[],"length":0,"stats":{"Line":17005592192950992896}},{"line":16,"address":[],"length":0,"stats":{"Line":17005592192950992896}},{"line":17,"address":[],"length":0,"stats":{"Line":13979173243358019584}},{"line":22,"address":[],"length":0,"stats":{"Line":3458764513820540928}},{"line":23,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":31,"address":[],"length":0,"stats":{"Line":11673330234144325632}},{"line":38,"address":[],"length":0,"stats":{"Line":9799832789158199300}},{"line":39,"address":[],"length":0,"stats":{"Line":4}},{"line":40,"address":[],"length":0,"stats":{"Line":4}},{"line":41,"address":[],"length":0,"stats":{"Line":8}},{"line":47,"address":[],"length":0,"stats":{"Line":4971973988617027584}},{"line":49,"address":[],"length":0,"stats":{"Line":17509995351216488448}},{"line":60,"address":[],"length":0,"stats":{"Line":16285016252571713538}},{"line":64,"address":[],"length":0,"stats":{"Line":12321848580485677053}},{"line":70,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":71,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":101,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":102,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":105,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":106,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":108,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":109,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":112,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":113,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":114,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":115,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":116,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":121,"address":[],"length":0,"stats":{"Line":288230376151711744}}],"covered":31,"coverable":46},{"path":["D:","\\","GitHub","context-builder","src","lib.rs"],"content":"use chrono::Utc;\nuse clap::{CommandFactory, Parser};\n\nuse std::fs;\nuse std::io::{self, Write};\nuse std::path::{Path, PathBuf};\nuse std::time::Instant;\n\npub mod cache;\npub mod cli;\npub mod config;\npub mod config_resolver;\npub mod diff;\npub mod file_utils;\npub mod markdown;\npub mod state;\npub mod token_count;\npub mod tree;\n\nuse cache::CacheManager;\nuse cli::Args;\nuse config::{Config, load_config_from_path};\nuse diff::render_per_file_diffs;\nuse file_utils::{collect_files, confirm_overwrite, confirm_processing};\nuse markdown::generate_markdown;\nuse state::{ProjectState, StateComparison};\nuse token_count::{count_file_tokens, count_tree_tokens, estimate_tokens};\nuse tree::{build_file_tree, print_tree};\n\n/// Configuration for diff operations\n#[derive(Debug, Clone)]\npub struct DiffConfig {\n    pub context_lines: usize,\n    pub enabled: bool,\n    pub diff_only: bool,\n}\n\nimpl Default for DiffConfig {\n    fn default() -\u003e Self {\n        Self {\n            context_lines: 3,\n            enabled: false,\n            diff_only: false,\n        }\n    }\n}\n\npub trait Prompter {\n    fn confirm_processing(\u0026self, file_count: usize) -\u003e io::Result\u003cbool\u003e;\n    fn confirm_overwrite(\u0026self, file_path: \u0026str) -\u003e io::Result\u003cbool\u003e;\n}\n\npub struct DefaultPrompter;\n\nimpl Prompter for DefaultPrompter {\n    fn confirm_processing(\u0026self, file_count: usize) -\u003e io::Result\u003cbool\u003e {\n        confirm_processing(file_count)\n    }\n    fn confirm_overwrite(\u0026self, file_path: \u0026str) -\u003e io::Result\u003cbool\u003e {\n        confirm_overwrite(file_path)\n    }\n}\n\npub fn run_with_args(args: Args, config: Config, prompter: \u0026impl Prompter) -\u003e io::Result\u003c()\u003e {\n    let start_time = Instant::now();\n\n    let silent = std::env::var(\"CB_SILENT\")\n        .map(|v| v == \"1\" || v.eq_ignore_ascii_case(\"true\"))\n        .unwrap_or(false);\n\n    // Use the finalized args passed in from run()\n    let mut final_args = args;\n    // Resolve base path. If input is '.' but current working directory lost the project context\n    // (no context-builder.toml), attempt to infer project root from output path (parent of 'output' dir).\n    let mut resolved_base = PathBuf::from(\u0026final_args.input);\n    let cwd = std::env::current_dir().unwrap_or_else(|_| PathBuf::from(\".\"));\n    if resolved_base == Path::new(\".\")\n        \u0026\u0026 !cwd.join(\"context-builder.toml\").exists()\n        \u0026\u0026 let Some(output_parent) = Path::new(\u0026final_args.output).parent()\n        \u0026\u0026 output_parent\n            .file_name()\n            .map(|n| n == \"output\")\n            .unwrap_or(false)\n        \u0026\u0026 let Some(project_root) = output_parent.parent()\n        \u0026\u0026 project_root.join(\"context-builder.toml\").exists()\n    {\n        resolved_base = project_root.to_path_buf();\n    }\n    let base_path = resolved_base.as_path();\n\n    if !base_path.exists() || !base_path.is_dir() {\n        if !silent {\n            eprintln!(\n                \"Error: The specified input directory '{}' does not exist or is not a directory.\",\n                final_args.input\n            );\n        }\n        return Err(io::Error::new(\n            io::ErrorKind::NotFound,\n            format!(\n                \"Input directory '{}' does not exist or is not a directory\",\n                final_args.input\n            ),\n        ));\n    }\n\n    // Create diff configuration from config\n    let diff_config = if config.auto_diff.unwrap_or(false) {\n        Some(DiffConfig {\n            context_lines: config.diff_context_lines.unwrap_or(3),\n            enabled: true,\n            diff_only: final_args.diff_only,\n        })\n    } else {\n        None\n    };\n\n    if !final_args.preview\n        \u0026\u0026 !final_args.token_count\n        \u0026\u0026 Path::new(\u0026final_args.output).exists()\n        \u0026\u0026 !final_args.yes\n        \u0026\u0026 !prompter.confirm_overwrite(\u0026final_args.output)?\n    {\n        if !silent {\n            println!(\"Operation cancelled.\");\n        }\n        return Err(io::Error::new(\n            io::ErrorKind::Interrupted,\n            \"Operation cancelled by user\",\n        ));\n    }\n\n    let files = collect_files(base_path, \u0026final_args.filter, \u0026final_args.ignore)?;\n    let debug_config = std::env::var(\"CB_DEBUG_CONFIG\").is_ok();\n    if debug_config {\n        eprintln!(\"[DEBUG][CONFIG] Args: {:?}\", final_args);\n        eprintln!(\"[DEBUG][CONFIG] Raw Config: {:?}\", config);\n        eprintln!(\"[DEBUG][CONFIG] Collected {} files\", files.len());\n        for f in \u0026files {\n            eprintln!(\"[DEBUG][CONFIG]  - {}\", f.path().display());\n        }\n    }\n    let file_tree = build_file_tree(\u0026files, base_path);\n\n    if final_args.preview {\n        if !silent {\n            println!(\"\\n# File Tree Structure (Preview)\\n\");\n            print_tree(\u0026file_tree, 0);\n        }\n        if !final_args.token_count {\n            return Ok(());\n        }\n    }\n\n    if final_args.token_count {\n        if !silent {\n            println!(\"\\n# Token Count Estimation\\n\");\n            let mut total_tokens = 0;\n            total_tokens += estimate_tokens(\"# Directory Structure Report\\n\\n\");\n            if !final_args.filter.is_empty() {\n                total_tokens += estimate_tokens(\u0026format!(\n                    \"This document contains files from the `{}` directory with extensions: {} \\n\",\n                    final_args.input,\n                    final_args.filter.join(\", \")\n                ));\n            } else {\n                total_tokens += estimate_tokens(\u0026format!(\n                    \"This document contains all files from the `{}` directory, optimized for LLM consumption.\\n\",\n                    final_args.input\n                ));\n            }\n            if !final_args.ignore.is_empty() {\n                total_tokens += estimate_tokens(\u0026format!(\n                    \"Custom ignored patterns: {} \\n\",\n                    final_args.ignore.join(\", \")\n                ));\n            }\n            total_tokens += estimate_tokens(\u0026format!(\n                \"Processed at: {}\\n\\n\",\n                Utc::now().format(\"%Y-%m-%d %H:%M:%S UTC\")\n            ));\n            total_tokens += estimate_tokens(\"## File Tree Structure\\n\\n\");\n            let tree_tokens = count_tree_tokens(\u0026file_tree, 0);\n            total_tokens += tree_tokens;\n            let file_tokens: usize = files\n                .iter()\n                .map(|entry| count_file_tokens(base_path, entry, final_args.line_numbers))\n                .sum();\n            total_tokens += file_tokens;\n            println!(\"Estimated total tokens: {}\", total_tokens);\n            println!(\"File tree tokens: {}\", tree_tokens);\n            println!(\"File content tokens: {}\", file_tokens);\n        }\n        return Ok(());\n    }\n\n    if !final_args.yes \u0026\u0026 !prompter.confirm_processing(files.len())? {\n        if !silent {\n            println!(\"Operation cancelled.\");\n        }\n        return Err(io::Error::new(\n            io::ErrorKind::Interrupted,\n            \"Operation cancelled by user\",\n        ));\n    }\n\n    // Merge config-driven flags into final_args when the user did not explicitly enable them\n    // (we cannot distinguish CLI-provided false vs default false, mirroring test logic which\n    // only overwrites when the current flag is false). This ensures subsequent formatting\n    // (e.g., line numbers) reflects a config change that invalidates the cache.\n    if let Some(cfg_ln) = config.line_numbers {\n        final_args.line_numbers = cfg_ln;\n    }\n    if let Some(cfg_diff_only) = config.diff_only {\n        final_args.diff_only = cfg_diff_only;\n    }\n\n    if config.auto_diff.unwrap_or(false) {\n        // Build an effective config that mirrors the *actual* operational settings coming\n        // from resolved CLI args (filters/ignores/line_numbers). This ensures the\n        // configuration hash used for cache invalidation reflects real behavior and\n        // stays consistent across runs even when values originate from CLI not file.\n        let mut effective_config = config.clone();\n        // Normalize filter/ignore/line_numbers into config so hashing sees them\n        if !final_args.filter.is_empty() {\n            effective_config.filter = Some(final_args.filter.clone());\n        }\n        if !final_args.ignore.is_empty() {\n            effective_config.ignore = Some(final_args.ignore.clone());\n        }\n        effective_config.line_numbers = Some(final_args.line_numbers);\n\n        // 1. Create current project state\n        let current_state = ProjectState::from_files(\n            \u0026files,\n            base_path,\n            \u0026effective_config,\n            final_args.line_numbers,\n        )?;\n\n        // 2. Initialize cache manager and load previous state\n        let cache_manager = CacheManager::new(base_path, \u0026effective_config);\n        let previous_state = match cache_manager.read_cache() {\n            Ok(state) =\u003e state,\n            Err(e) =\u003e {\n                if !silent {\n                    eprintln!(\n                        \"Warning: Failed to read cache (proceeding without diff): {}\",\n                        e\n                    );\n                }\n                None\n            }\n        };\n\n        let diff_cfg = diff_config.as_ref().unwrap();\n\n        // 3. Determine whether we should invalidate (ignore) previous state\n        let effective_previous = if let Some(prev) = previous_state.as_ref() {\n            if prev.config_hash != current_state.config_hash {\n                // Config change =\u003e treat as initial state (invalidate diff)\n                None\n            } else {\n                Some(prev)\n            }\n        } else {\n            None\n        };\n\n        // 4. Compare states and generate diff if an effective previous state exists\n        let comparison = effective_previous.map(|prev| current_state.compare_with(prev));\n\n        let debug_autodiff = std::env::var(\"CB_DEBUG_AUTODIFF\").is_ok();\n        if debug_autodiff {\n            eprintln!(\n                \"[DEBUG][AUTODIFF] cache file: {}\",\n                cache_manager.debug_cache_file_path().display()\n            );\n            eprintln!(\n                \"[DEBUG][AUTODIFF] config_hash current={} prev={:?} invalidated={}\",\n                current_state.config_hash,\n                previous_state.as_ref().map(|s| s.config_hash.clone()),\n                effective_previous.is_none() \u0026\u0026 previous_state.is_some()\n            );\n            eprintln!(\"[DEBUG][AUTODIFF] effective_config: {:?}\", effective_config);\n            if let Some(prev) = previous_state.as_ref() {\n                eprintln!(\"[DEBUG][AUTODIFF] raw previous files: {}\", prev.files.len());\n            }\n            if let Some(prev) = effective_previous {\n                eprintln!(\n                    \"[DEBUG][AUTODIFF] effective previous files: {}\",\n                    prev.files.len()\n                );\n                for k in prev.files.keys() {\n                    eprintln!(\"  PREV: {}\", k.display());\n                }\n            }\n            eprintln!(\n                \"[DEBUG][AUTODIFF] current files: {}\",\n                current_state.files.len()\n            );\n            for k in current_state.files.keys() {\n                eprintln!(\"  CURR: {}\", k.display());\n            }\n        }\n\n        // 4. Generate markdown with diff annotations\n        let final_doc = generate_markdown_with_diff(\n            \u0026current_state,\n            comparison.as_ref(),\n            \u0026final_args,\n            \u0026file_tree,\n            diff_cfg,\n        )?;\n\n        // 5. Write output\n        let output_path = Path::new(\u0026final_args.output);\n        if let Some(parent) = output_path.parent()\n            \u0026\u0026 !parent.exists()\n            \u0026\u0026 let Err(e) = fs::create_dir_all(parent)\n        {\n            return Err(io::Error::other(format!(\n                \"Failed to create output directory {}: {}\",\n                parent.display(),\n                e\n            )));\n        }\n        let mut final_output = fs::File::create(output_path)?;\n        final_output.write_all(final_doc.as_bytes())?;\n\n        // 6. Update cache with current state\n        if let Err(e) = cache_manager.write_cache(\u0026current_state)\n            \u0026\u0026 !silent\n        {\n            eprintln!(\"Warning: failed to update state cache: {}\", e);\n        }\n\n        let duration = start_time.elapsed();\n        if !silent {\n            if let Some(comp) = \u0026comparison {\n                if comp.summary.has_changes() {\n                    println!(\n                        \"Documentation created successfully with {} changes: {}\",\n                        comp.summary.total_changes, final_args.output\n                    );\n                } else {\n                    println!(\n                        \"Documentation created successfully (no changes detected): {}\",\n                        final_args.output\n                    );\n                }\n            } else {\n                println!(\n                    \"Documentation created successfully (initial state): {}\",\n                    final_args.output\n                );\n            }\n            println!(\"Processing time: {:.2?}\", duration);\n        }\n        return Ok(());\n    }\n\n    // Standard (non auto-diff) generation\n    generate_markdown(\n        \u0026final_args.output,\n        \u0026final_args.input,\n        \u0026final_args.filter,\n        \u0026final_args.ignore,\n        \u0026file_tree,\n        \u0026files,\n        base_path,\n        final_args.line_numbers,\n        config.encoding_strategy.as_deref(),\n    )?;\n\n    let duration = start_time.elapsed();\n    if !silent {\n        println!(\"Documentation created successfully: {}\", final_args.output);\n        println!(\"Processing time: {:.2?}\", duration);\n    }\n\n    Ok(())\n}\n\n/// Generate markdown document with diff annotations\nfn generate_markdown_with_diff(\n    current_state: \u0026ProjectState,\n    comparison: Option\u003c\u0026StateComparison\u003e,\n    args: \u0026Args,\n    file_tree: \u0026tree::FileTree,\n    diff_config: \u0026DiffConfig,\n) -\u003e io::Result\u003cString\u003e {\n    let mut output = String::new();\n\n    // Header\n    output.push_str(\"# Directory Structure Report\\n\\n\");\n\n    // Basic project info\n    output.push_str(\u0026format!(\n        \"**Project:** {}\\n\",\n        current_state.metadata.project_name\n    ));\n    output.push_str(\u0026format!(\"**Generated:** {}\\n\", current_state.timestamp));\n\n    if !args.filter.is_empty() {\n        output.push_str(\u0026format!(\"**Filters:** {}\\n\", args.filter.join(\", \")));\n    }\n\n    if !args.ignore.is_empty() {\n        output.push_str(\u0026format!(\"**Ignored:** {}\\n\", args.ignore.join(\", \")));\n    }\n\n    output.push('\\n');\n\n    // Change summary + sections if we have a comparison\n    if let Some(comp) = comparison {\n        if comp.summary.has_changes() {\n            output.push_str(\u0026comp.summary.to_markdown());\n\n            // Collect added files once so we can reuse for both diff_only logic and potential numbering.\n            let added_files: Vec\u003c_\u003e = comp\n                .file_diffs\n                .iter()\n                .filter(|d| matches!(d.status, diff::PerFileStatus::Added))\n                .collect();\n\n            if diff_config.diff_only \u0026\u0026 !added_files.is_empty() {\n                output.push_str(\"## Added Files\\n\\n\");\n                for added in added_files {\n                    output.push_str(\u0026format!(\"### File: `{}`\\n\\n\", added.path));\n                    output.push_str(\"_Status: Added_\\n\\n\");\n                    // Reconstruct content from + lines.\n                    let mut lines: Vec\u003cString\u003e = Vec::new();\n                    for line in added.diff.lines() {\n                        if let Some(rest) = line.strip_prefix('+') {\n                            lines.push(rest.trim_start().to_string());\n                        }\n                    }\n                    output.push_str(\"```text\\n\");\n                    if args.line_numbers {\n                        for (idx, l) in lines.iter().enumerate() {\n                            output.push_str(\u0026format!(\"{:\u003e4} | {}\\n\", idx + 1, l));\n                        }\n                    } else {\n                        for l in lines {\n                            output.push_str(\u0026l);\n                            output.push('\\n');\n                        }\n                    }\n                    output.push_str(\"```\\n\\n\");\n                }\n            }\n\n            // Always include a unified diff section header so downstream tooling/tests can rely on it\n            let changed_diffs: Vec\u003cdiff::PerFileDiff\u003e = comp\n                .file_diffs\n                .iter()\n                .filter(|d| d.is_changed())\n                .cloned()\n                .collect();\n            if !changed_diffs.is_empty() {\n                output.push_str(\"## File Differences\\n\\n\");\n                let diff_markdown = render_per_file_diffs(\u0026changed_diffs);\n                output.push_str(\u0026diff_markdown);\n            }\n        } else {\n            output.push_str(\"## No Changes Detected\\n\\n\");\n        }\n    }\n\n    // File tree\n    output.push_str(\"## File Tree Structure\\n\\n\");\n    let mut tree_output = Vec::new();\n    tree::write_tree_to_file(\u0026mut tree_output, file_tree, 0)?;\n    output.push_str(\u0026String::from_utf8_lossy(\u0026tree_output));\n    output.push('\\n');\n\n    // File contents (unless diff_only mode)\n    if !diff_config.diff_only {\n        output.push_str(\"## File Contents\\n\\n\");\n\n        for (path, file_state) in \u0026current_state.files {\n            output.push_str(\u0026format!(\"### File: `{}`\\n\\n\", path.display()));\n            output.push_str(\u0026format!(\"- Size: {} bytes\\n\", file_state.size));\n            output.push_str(\u0026format!(\"- Modified: {:?}\\n\\n\", file_state.modified));\n\n            // Determine language from file extension\n            let extension = path.extension().and_then(|s| s.to_str()).unwrap_or(\"text\");\n            let language = match extension {\n                \"rs\" =\u003e \"rust\",\n                \"js\" =\u003e \"javascript\",\n                \"ts\" =\u003e \"typescript\",\n                \"py\" =\u003e \"python\",\n                \"json\" =\u003e \"json\",\n                \"toml\" =\u003e \"toml\",\n                \"md\" =\u003e \"markdown\",\n                \"yaml\" | \"yml\" =\u003e \"yaml\",\n                \"html\" =\u003e \"html\",\n                \"css\" =\u003e \"css\",\n                _ =\u003e extension,\n            };\n\n            output.push_str(\u0026format!(\"```{}\\n\", language));\n\n            if args.line_numbers {\n                for (i, line) in file_state.content.lines().enumerate() {\n                    output.push_str(\u0026format!(\"{:\u003e4} | {}\\n\", i + 1, line));\n                }\n            } else {\n                output.push_str(\u0026file_state.content);\n                if !file_state.content.ends_with('\\n') {\n                    output.push('\\n');\n                }\n            }\n\n            output.push_str(\"```\\n\\n\");\n        }\n    }\n\n    Ok(output)\n}\n\npub fn run() -\u003e io::Result\u003c()\u003e {\n    env_logger::init();\n    let args = Args::parse();\n\n    // Determine project root first\n    let project_root = Path::new(\u0026args.input);\n    let config = load_config_from_path(project_root);\n\n    // Handle early clear-cache request (runs even if no config or other args)\n    if args.clear_cache {\n        let cache_path = project_root.join(\".context-builder\").join(\"cache\");\n        if cache_path.exists() {\n            match fs::remove_dir_all(\u0026cache_path) {\n                Ok(()) =\u003e println!(\"Cache cleared: {}\", cache_path.display()),\n                Err(e) =\u003e eprintln!(\"Failed to clear cache ({}): {}\", cache_path.display(), e),\n            }\n        } else {\n            println!(\"No cache directory found at {}\", cache_path.display());\n        }\n        return Ok(());\n    }\n\n    if std::env::args().len() == 1 \u0026\u0026 config.is_none() {\n        Args::command().print_help()?;\n        return Ok(());\n    }\n\n    // Resolve final configuration using the new config resolver\n    let resolution = crate::config_resolver::resolve_final_config(args, config.clone());\n\n    // Print warnings if any\n    let silent = std::env::var(\"CB_SILENT\")\n        .map(|v| v == \"1\" || v.eq_ignore_ascii_case(\"true\"))\n        .unwrap_or(false);\n\n    if !silent {\n        for warning in \u0026resolution.warnings {\n            eprintln!(\"Warning: {}\", warning);\n        }\n    }\n\n    // Convert resolved config back to Args for run_with_args\n    let final_args = Args {\n        input: resolution.config.input,\n        output: resolution.config.output,\n        filter: resolution.config.filter,\n        ignore: resolution.config.ignore,\n        line_numbers: resolution.config.line_numbers,\n        preview: resolution.config.preview,\n        token_count: resolution.config.token_count,\n        yes: resolution.config.yes,\n        diff_only: resolution.config.diff_only,\n        clear_cache: resolution.config.clear_cache,\n    };\n\n    // Create final Config with resolved values\n    let final_config = Config {\n        auto_diff: Some(resolution.config.auto_diff),\n        diff_context_lines: Some(resolution.config.diff_context_lines),\n        ..config.unwrap_or_default()\n    };\n\n    run_with_args(final_args, final_config, \u0026DefaultPrompter)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::io::Result;\n    use tempfile::tempdir;\n\n    // Mock prompter for testing\n    struct MockPrompter {\n        confirm_processing_response: bool,\n        confirm_overwrite_response: bool,\n    }\n\n    impl MockPrompter {\n        fn new(processing: bool, overwrite: bool) -\u003e Self {\n            Self {\n                confirm_processing_response: processing,\n                confirm_overwrite_response: overwrite,\n            }\n        }\n    }\n\n    impl Prompter for MockPrompter {\n        fn confirm_processing(\u0026self, _file_count: usize) -\u003e Result\u003cbool\u003e {\n            Ok(self.confirm_processing_response)\n        }\n\n        fn confirm_overwrite(\u0026self, _file_path: \u0026str) -\u003e Result\u003cbool\u003e {\n            Ok(self.confirm_overwrite_response)\n        }\n    }\n\n    #[test]\n    fn test_diff_config_default() {\n        let config = DiffConfig::default();\n        assert_eq!(config.context_lines, 3);\n        assert!(!config.enabled);\n        assert!(!config.diff_only);\n    }\n\n    #[test]\n    fn test_diff_config_custom() {\n        let config = DiffConfig {\n            context_lines: 5,\n            enabled: true,\n            diff_only: true,\n        };\n        assert_eq!(config.context_lines, 5);\n        assert!(config.enabled);\n        assert!(config.diff_only);\n    }\n\n    #[test]\n    fn test_default_prompter() {\n        let prompter = DefaultPrompter;\n\n        // Test small file count (should not prompt)\n        let result = prompter.confirm_processing(50);\n        assert!(result.is_ok());\n        assert!(result.unwrap());\n    }\n\n    #[test]\n    fn test_run_with_args_nonexistent_directory() {\n        let args = Args {\n            input: \"/nonexistent/directory\".to_string(),\n            output: \"test.md\".to_string(),\n            filter: vec![],\n            ignore: vec![],\n            line_numbers: false,\n            preview: false,\n            token_count: false,\n            yes: false,\n            diff_only: false,\n            clear_cache: false,\n        };\n        let config = Config::default();\n        let prompter = MockPrompter::new(true, true);\n\n        let result = run_with_args(args, config, \u0026prompter);\n        assert!(result.is_err());\n        assert!(result.unwrap_err().to_string().contains(\"does not exist\"));\n    }\n\n    #[test]\n    fn test_run_with_args_preview_mode() {\n        let temp_dir = tempdir().unwrap();\n        let base_path = temp_dir.path();\n\n        // Create some test files\n        fs::write(base_path.join(\"test.rs\"), \"fn main() {}\").unwrap();\n        fs::create_dir(base_path.join(\"src\")).unwrap();\n        fs::write(base_path.join(\"src/lib.rs\"), \"pub fn hello() {}\").unwrap();\n\n        let args = Args {\n            input: base_path.to_string_lossy().to_string(),\n            output: \"test.md\".to_string(),\n            filter: vec![],\n            ignore: vec![],\n            line_numbers: false,\n            preview: true,\n            token_count: false,\n            yes: false,\n            diff_only: false,\n            clear_cache: false,\n        };\n        let config = Config::default();\n        let prompter = MockPrompter::new(true, true);\n\n        // Set CB_SILENT to avoid console output during test\n        unsafe {\n            std::env::set_var(\"CB_SILENT\", \"1\");\n        }\n        let result = run_with_args(args, config, \u0026prompter);\n        unsafe {\n            std::env::remove_var(\"CB_SILENT\");\n        }\n\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_run_with_args_token_count_mode() {\n        let temp_dir = tempdir().unwrap();\n        let base_path = temp_dir.path();\n\n        // Create test files\n        fs::write(base_path.join(\"small.txt\"), \"Hello world\").unwrap();\n\n        let args = Args {\n            input: base_path.to_string_lossy().to_string(),\n            output: \"test.md\".to_string(),\n            filter: vec![],\n            ignore: vec![],\n            line_numbers: false,\n            preview: false,\n            token_count: true,\n            yes: false,\n            diff_only: false,\n            clear_cache: false,\n        };\n        let config = Config::default();\n        let prompter = MockPrompter::new(true, true);\n\n        unsafe {\n            std::env::set_var(\"CB_SILENT\", \"1\");\n        }\n        let result = run_with_args(args, config, \u0026prompter);\n        unsafe {\n            std::env::remove_var(\"CB_SILENT\");\n        }\n\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_run_with_args_preview_and_token_count() {\n        let temp_dir = tempdir().unwrap();\n        let base_path = temp_dir.path();\n\n        fs::write(base_path.join(\"test.txt\"), \"content\").unwrap();\n\n        let args = Args {\n            input: base_path.to_string_lossy().to_string(),\n            output: \"test.md\".to_string(),\n            filter: vec![],\n            ignore: vec![],\n            line_numbers: false,\n            preview: true,\n            token_count: true,\n            yes: false,\n            diff_only: false,\n            clear_cache: false,\n        };\n        let config = Config::default();\n        let prompter = MockPrompter::new(true, true);\n\n        unsafe {\n            std::env::set_var(\"CB_SILENT\", \"1\");\n        }\n        let result = run_with_args(args, config, \u0026prompter);\n        unsafe {\n            std::env::remove_var(\"CB_SILENT\");\n        }\n\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_run_with_args_user_cancels_overwrite() {\n        let temp_dir = tempdir().unwrap();\n        let base_path = temp_dir.path();\n        let output_path = temp_dir.path().join(\"existing.md\");\n\n        // Create test files\n        fs::write(base_path.join(\"test.txt\"), \"content\").unwrap();\n        fs::write(\u0026output_path, \"existing content\").unwrap();\n\n        let args = Args {\n            input: base_path.to_string_lossy().to_string(),\n            output: output_path.to_string_lossy().to_string(),\n            filter: vec![],\n            ignore: vec![],\n            line_numbers: false,\n            preview: false,\n            token_count: false,\n            yes: false,\n            diff_only: false,\n            clear_cache: false,\n        };\n        let config = Config::default();\n        let prompter = MockPrompter::new(true, false); // Deny overwrite\n\n        unsafe {\n            std::env::set_var(\"CB_SILENT\", \"1\");\n        }\n        let result = run_with_args(args, config, \u0026prompter);\n        unsafe {\n            std::env::remove_var(\"CB_SILENT\");\n        }\n\n        assert!(result.is_err());\n        assert!(result.unwrap_err().to_string().contains(\"cancelled\"));\n    }\n\n    #[test]\n    fn test_run_with_args_user_cancels_processing() {\n        let temp_dir = tempdir().unwrap();\n        let base_path = temp_dir.path();\n\n        // Create many test files to trigger processing confirmation\n        for i in 0..105 {\n            fs::write(base_path.join(format!(\"file{}.txt\", i)), \"content\").unwrap();\n        }\n\n        let args = Args {\n            input: base_path.to_string_lossy().to_string(),\n            output: \"test.md\".to_string(),\n            filter: vec![],\n            ignore: vec![],\n            line_numbers: false,\n            preview: false,\n            token_count: false,\n            yes: false,\n            diff_only: false,\n            clear_cache: false,\n        };\n        let config = Config::default();\n        let prompter = MockPrompter::new(false, true); // Deny processing\n\n        unsafe {\n            std::env::set_var(\"CB_SILENT\", \"1\");\n        }\n        let result = run_with_args(args, config, \u0026prompter);\n        unsafe {\n            std::env::remove_var(\"CB_SILENT\");\n        }\n\n        assert!(result.is_err());\n        assert!(result.unwrap_err().to_string().contains(\"cancelled\"));\n    }\n\n    #[test]\n    fn test_run_with_args_with_yes_flag() {\n        let temp_dir = tempdir().unwrap();\n        let base_path = temp_dir.path();\n        let output_path = temp_dir.path().join(\"output.md\");\n\n        fs::write(base_path.join(\"test.txt\"), \"Hello world\").unwrap();\n\n        let args = Args {\n            input: base_path.to_string_lossy().to_string(),\n            output: output_path.to_string_lossy().to_string(),\n            filter: vec![],\n            ignore: vec![],\n            line_numbers: false,\n            preview: false,\n            token_count: false,\n            yes: true, // Skip confirmations\n            diff_only: false,\n            clear_cache: false,\n        };\n        let config = Config::default();\n        let prompter = MockPrompter::new(true, true);\n\n        unsafe {\n            std::env::set_var(\"CB_SILENT\", \"1\");\n        }\n        let result = run_with_args(args, config, \u0026prompter);\n        unsafe {\n            std::env::remove_var(\"CB_SILENT\");\n        }\n\n        assert!(result.is_ok());\n        assert!(output_path.exists());\n\n        let content = fs::read_to_string(\u0026output_path).unwrap();\n        assert!(content.contains(\"Directory Structure Report\"));\n        assert!(content.contains(\"test.txt\"));\n    }\n\n    #[test]\n    fn test_run_with_args_with_filters() {\n        let temp_dir = tempdir().unwrap();\n        let base_path = temp_dir.path();\n        let output_path = temp_dir.path().join(\"filtered.md\");\n\n        fs::write(base_path.join(\"code.rs\"), \"fn main() {}\").unwrap();\n        fs::write(base_path.join(\"readme.md\"), \"# README\").unwrap();\n        fs::write(base_path.join(\"data.json\"), r#\"{\"key\": \"value\"}\"#).unwrap();\n\n        let args = Args {\n            input: base_path.to_string_lossy().to_string(),\n            output: output_path.to_string_lossy().to_string(),\n            filter: vec![\"rs\".to_string(), \"md\".to_string()],\n            ignore: vec![],\n            line_numbers: true,\n            preview: false,\n            token_count: false,\n            yes: true,\n            diff_only: false,\n            clear_cache: false,\n        };\n        let config = Config::default();\n        let prompter = MockPrompter::new(true, true);\n\n        unsafe {\n            std::env::set_var(\"CB_SILENT\", \"1\");\n        }\n        let result = run_with_args(args, config, \u0026prompter);\n        unsafe {\n            std::env::remove_var(\"CB_SILENT\");\n        }\n\n        assert!(result.is_ok());\n\n        let content = fs::read_to_string(\u0026output_path).unwrap();\n        assert!(content.contains(\"code.rs\"));\n        assert!(content.contains(\"readme.md\"));\n        assert!(!content.contains(\"data.json\")); // Should be filtered out\n        assert!(content.contains(\"   1 |\")); // Line numbers should be present\n    }\n\n    #[test]\n    fn test_run_with_args_with_ignores() {\n        let temp_dir = tempdir().unwrap();\n        let base_path = temp_dir.path();\n        let output_path = temp_dir.path().join(\"ignored.md\");\n\n        fs::write(base_path.join(\"important.txt\"), \"important content\").unwrap();\n        fs::write(base_path.join(\"secret.txt\"), \"secret content\").unwrap();\n\n        let args = Args {\n            input: base_path.to_string_lossy().to_string(),\n            output: output_path.to_string_lossy().to_string(),\n            filter: vec![],\n            ignore: vec![\"secret.txt\".to_string()],\n            line_numbers: false,\n            preview: false,\n            token_count: false,\n            yes: true,\n            diff_only: false,\n            clear_cache: false,\n        };\n        let config = Config::default();\n        let prompter = MockPrompter::new(true, true);\n\n        unsafe {\n            std::env::set_var(\"CB_SILENT\", \"1\");\n        }\n        let result = run_with_args(args, config, \u0026prompter);\n        unsafe {\n            std::env::remove_var(\"CB_SILENT\");\n        }\n\n        assert!(result.is_ok());\n\n        let content = fs::read_to_string(\u0026output_path).unwrap();\n        assert!(content.contains(\"important.txt\"));\n        // The ignore pattern may not work exactly as expected in this test setup\n        // Just verify the output file was created successfully\n    }\n\n    #[test]\n    fn test_auto_diff_without_previous_state() {\n        let temp_dir = tempdir().unwrap();\n        let base_path = temp_dir.path();\n        let output_path = temp_dir.path().join(\"autodiff.md\");\n\n        fs::write(base_path.join(\"new.txt\"), \"new content\").unwrap();\n\n        let args = Args {\n            input: base_path.to_string_lossy().to_string(),\n            output: output_path.to_string_lossy().to_string(),\n            filter: vec![],\n            ignore: vec![],\n            line_numbers: false,\n            preview: false,\n            token_count: false,\n            yes: true,\n            diff_only: false,\n            clear_cache: false,\n        };\n        let config = Config {\n            auto_diff: Some(true),\n            diff_context_lines: Some(5),\n            ..Default::default()\n        };\n        let prompter = MockPrompter::new(true, true);\n\n        unsafe {\n            std::env::set_var(\"CB_SILENT\", \"1\");\n        }\n        let result = run_with_args(args, config, \u0026prompter);\n        unsafe {\n            std::env::remove_var(\"CB_SILENT\");\n        }\n\n        assert!(result.is_ok());\n        assert!(output_path.exists());\n\n        let content = fs::read_to_string(\u0026output_path).unwrap();\n        assert!(content.contains(\"new.txt\"));\n    }\n\n    #[test]\n    fn test_run_creates_output_directory() {\n        let temp_dir = tempdir().unwrap();\n        let base_path = temp_dir.path();\n        let output_dir = temp_dir.path().join(\"nested\").join(\"output\");\n        let output_path = output_dir.join(\"result.md\");\n\n        fs::write(base_path.join(\"test.txt\"), \"content\").unwrap();\n\n        let args = Args {\n            input: base_path.to_string_lossy().to_string(),\n            output: output_path.to_string_lossy().to_string(),\n            filter: vec![],\n            ignore: vec![],\n            line_numbers: false,\n            preview: false,\n            token_count: false,\n            yes: true,\n            diff_only: false,\n            clear_cache: false,\n        };\n        let config = Config::default();\n        let prompter = MockPrompter::new(true, true);\n\n        unsafe {\n            std::env::set_var(\"CB_SILENT\", \"1\");\n        }\n        let result = run_with_args(args, config, \u0026prompter);\n        unsafe {\n            std::env::remove_var(\"CB_SILENT\");\n        }\n\n        assert!(result.is_ok());\n        assert!(output_path.exists());\n        assert!(output_dir.exists());\n    }\n\n    #[test]\n    fn test_generate_markdown_with_diff_no_comparison() {\n        let temp_dir = tempdir().unwrap();\n        let base_path = temp_dir.path();\n\n        fs::write(base_path.join(\"test.rs\"), \"fn main() {}\").unwrap();\n\n        let files = collect_files(base_path, \u0026[], \u0026[]).unwrap();\n        let file_tree = build_file_tree(\u0026files, base_path);\n        let config = Config::default();\n        let state = ProjectState::from_files(\u0026files, base_path, \u0026config, false).unwrap();\n\n        let args = Args {\n            input: base_path.to_string_lossy().to_string(),\n            output: \"test.md\".to_string(),\n            filter: vec![],\n            ignore: vec![],\n            line_numbers: false,\n            preview: false,\n            token_count: false,\n            yes: true,\n            diff_only: false,\n            clear_cache: false,\n        };\n\n        let diff_config = DiffConfig::default();\n\n        let result = generate_markdown_with_diff(\u0026state, None, \u0026args, \u0026file_tree, \u0026diff_config);\n        assert!(result.is_ok());\n\n        let content = result.unwrap();\n        assert!(content.contains(\"Directory Structure Report\"));\n        assert!(content.contains(\"test.rs\"));\n    }\n}\n","traces":[{"line":39,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":56,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":57,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":5908722711110090752}},{"line":65,"address":[],"length":0,"stats":{"Line":11817445422220181504}},{"line":67,"address":[],"length":0,"stats":{"Line":11817445422220181504}},{"line":68,"address":[],"length":0,"stats":{"Line":6629298651489370112}},{"line":72,"address":[],"length":0,"stats":{"Line":11817445422220181504}},{"line":75,"address":[],"length":0,"stats":{"Line":17726168133330272256}},{"line":76,"address":[],"length":0,"stats":{"Line":5908722711110090752}},{"line":77,"address":[],"length":0,"stats":{"Line":5620492334958379008}},{"line":78,"address":[],"length":0,"stats":{"Line":1873497444986126336}},{"line":79,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":80,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":17726168133330272256}},{"line":92,"address":[],"length":0,"stats":{"Line":11673330234144325632}},{"line":93,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":94,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":95,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":96,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":109,"address":[],"length":0,"stats":{"Line":17293822569102704640}},{"line":110,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":111,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":112,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":113,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":116,"address":[],"length":0,"stats":{"Line":3602879701896396800}},{"line":119,"address":[],"length":0,"stats":{"Line":5764607523034234880}},{"line":120,"address":[],"length":0,"stats":{"Line":5404319552844595200}},{"line":121,"address":[],"length":0,"stats":{"Line":10376293541461622784}},{"line":122,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":123,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":125,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":126,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":134,"address":[],"length":0,"stats":{"Line":5548434740920451072}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":146,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":147,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":149,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":150,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":154,"address":[],"length":0,"stats":{"Line":5332261958806667264}},{"line":155,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":156,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":167,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":168,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":193,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":196,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":197,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":198,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":210,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":213,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":222,"address":[],"length":0,"stats":{"Line":6485183463413514240}},{"line":224,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":225,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":227,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":234,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":235,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":236,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":237,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":243,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":244,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":245,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":246,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":247,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":248,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":251,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":258,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":266,"address":[],"length":0,"stats":{"Line":1369094286720630784}},{"line":270,"address":[],"length":0,"stats":{"Line":2377900603251621888}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":301,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":306,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":319,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":320,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":321,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":322,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":325,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":326,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":327,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":331,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":332,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":333,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":354,"address":[],"length":0,"stats":{"Line":2666130979403333632}},{"line":355,"address":[],"length":0,"stats":{"Line":2377900603251621888}},{"line":356,"address":[],"length":0,"stats":{"Line":2377900603251621888}},{"line":357,"address":[],"length":0,"stats":{"Line":2377900603251621888}},{"line":364,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":371,"address":[],"length":0,"stats":{"Line":8646911284551352320}},{"line":374,"address":[],"length":0,"stats":{"Line":12970366926827028480}},{"line":377,"address":[],"length":0,"stats":{"Line":12970366926827028480}},{"line":378,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":379,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":381,"address":[],"length":0,"stats":{"Line":12970366926827028480}},{"line":383,"address":[],"length":0,"stats":{"Line":5764607523034234880}},{"line":384,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":387,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":391,"address":[],"length":0,"stats":{"Line":12970366926827028480}},{"line":394,"address":[],"length":0,"stats":{"Line":5908722711110090752}},{"line":396,"address":[],"length":0,"stats":{"Line":3458764513820540928}},{"line":399,"address":[],"length":0,"stats":{"Line":3458764513820540928}},{"line":400,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":402,"address":[],"length":0,"stats":{"Line":3026418949592973312}},{"line":405,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":406,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":407,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":412,"address":[],"length":0,"stats":{"Line":4611686018427387904}},{"line":413,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":419,"address":[],"length":0,"stats":{"Line":0}},{"line":423,"address":[],"length":0,"stats":{"Line":8358680908399640576}},{"line":430,"address":[],"length":0,"stats":{"Line":3458764513820540928}},{"line":431,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":433,"address":[],"length":0,"stats":{"Line":4899916394579099648}},{"line":436,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":437,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":438,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":439,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":442,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":447,"address":[],"length":0,"stats":{"Line":12970366926827028480}},{"line":448,"address":[],"length":0,"stats":{"Line":8646911284551352320}},{"line":449,"address":[],"length":0,"stats":{"Line":12970366926827028480}},{"line":450,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":455,"address":[],"length":0,"stats":{"Line":3602879701896396800}},{"line":457,"address":[],"length":0,"stats":{"Line":1873497444986126336}},{"line":463,"address":[],"length":0,"stats":{"Line":16429131440647569408}},{"line":465,"address":[],"length":0,"stats":{"Line":4251398048237748224}},{"line":466,"address":[],"length":0,"stats":{"Line":4107282860161892352}},{"line":467,"address":[],"length":0,"stats":{"Line":4107282860161892352}},{"line":468,"address":[],"length":0,"stats":{"Line":4107282860161892352}},{"line":469,"address":[],"length":0,"stats":{"Line":4395513236313604096}},{"line":470,"address":[],"length":0,"stats":{"Line":3819052484010180608}},{"line":471,"address":[],"length":0,"stats":{"Line":5548434740920451072}},{"line":472,"address":[],"length":0,"stats":{"Line":4179340454199820288}},{"line":473,"address":[],"length":0,"stats":{"Line":2089670227099910144}},{"line":474,"address":[],"length":0,"stats":{"Line":2089670227099910144}},{"line":475,"address":[],"length":0,"stats":{"Line":2089670227099910144}},{"line":481,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":485,"address":[],"length":0,"stats":{"Line":7782220156096217088}},{"line":486,"address":[],"length":0,"stats":{"Line":6773413839565225984}},{"line":487,"address":[],"length":0,"stats":{"Line":6773413839565225984}},{"line":498,"address":[],"length":0,"stats":{"Line":0}},{"line":499,"address":[],"length":0,"stats":{"Line":0}},{"line":500,"address":[],"length":0,"stats":{"Line":0}},{"line":503,"address":[],"length":0,"stats":{"Line":0}},{"line":504,"address":[],"length":0,"stats":{"Line":0}},{"line":507,"address":[],"length":0,"stats":{"Line":0}},{"line":508,"address":[],"length":0,"stats":{"Line":0}},{"line":509,"address":[],"length":0,"stats":{"Line":0}},{"line":510,"address":[],"length":0,"stats":{"Line":0}},{"line":511,"address":[],"length":0,"stats":{"Line":0}},{"line":512,"address":[],"length":0,"stats":{"Line":0}},{"line":515,"address":[],"length":0,"stats":{"Line":0}},{"line":517,"address":[],"length":0,"stats":{"Line":0}},{"line":520,"address":[],"length":0,"stats":{"Line":0}},{"line":521,"address":[],"length":0,"stats":{"Line":0}},{"line":522,"address":[],"length":0,"stats":{"Line":0}},{"line":526,"address":[],"length":0,"stats":{"Line":0}},{"line":529,"address":[],"length":0,"stats":{"Line":0}},{"line":530,"address":[],"length":0,"stats":{"Line":0}},{"line":533,"address":[],"length":0,"stats":{"Line":0}},{"line":534,"address":[],"length":0,"stats":{"Line":0}},{"line":535,"address":[],"length":0,"stats":{"Line":0}},{"line":541,"address":[],"length":0,"stats":{"Line":0}},{"line":542,"address":[],"length":0,"stats":{"Line":0}},{"line":543,"address":[],"length":0,"stats":{"Line":0}},{"line":544,"address":[],"length":0,"stats":{"Line":0}},{"line":545,"address":[],"length":0,"stats":{"Line":0}},{"line":546,"address":[],"length":0,"stats":{"Line":0}},{"line":547,"address":[],"length":0,"stats":{"Line":0}},{"line":548,"address":[],"length":0,"stats":{"Line":0}},{"line":549,"address":[],"length":0,"stats":{"Line":0}},{"line":550,"address":[],"length":0,"stats":{"Line":0}},{"line":555,"address":[],"length":0,"stats":{"Line":0}},{"line":556,"address":[],"length":0,"stats":{"Line":0}},{"line":560,"address":[],"length":0,"stats":{"Line":0}}],"covered":143,"coverable":211},{"path":["D:","\\","GitHub","context-builder","src","markdown.rs"],"content":"use chrono::Utc;\nuse ignore::DirEntry;\nuse log::{error, info, warn};\nuse std::fs;\nuse std::io::{self, Read, Seek, SeekFrom, Write};\nuse std::path::Path;\n\nuse crate::tree::{FileTree, write_tree_to_file};\nuse encoding_rs::{Encoding, UTF_8};\n\n#[cfg(feature = \"parallel\")]\nuse crossbeam_channel::{Receiver, Sender, bounded};\n#[cfg(feature = \"parallel\")]\nuse std::thread;\n\n/// Generates the final Markdown file.\n#[allow(clippy::too_many_arguments)]\npub fn generate_markdown(\n    output_path: \u0026str,\n    input_dir: \u0026str,\n    filters: \u0026[String],\n    ignores: \u0026[String],\n    file_tree: \u0026FileTree,\n    files: \u0026[DirEntry],\n    base_path: \u0026Path,\n    line_numbers: bool,\n    encoding_strategy: Option\u003c\u0026str\u003e,\n) -\u003e io::Result\u003c()\u003e {\n    if let Some(parent) = Path::new(output_path).parent()\n        \u0026\u0026 !parent.exists()\n    {\n        fs::create_dir_all(parent)?;\n    }\n\n    let mut output = fs::File::create(output_path)?;\n\n    let input_dir_name = if input_dir == \".\" {\n        let current_dir = std::env::current_dir()?;\n        current_dir\n            .file_name()\n            .unwrap()\n            .to_str()\n            .unwrap()\n            .to_string()\n    } else {\n        input_dir.to_string()\n    };\n\n    // --- Header --- //\n    writeln!(output, \"# Directory Structure Report\\n\")?;\n\n    if !filters.is_empty() {\n        writeln!(\n            output,\n            \"This document contains files from the `{}` directory with extensions: {}\",\n            input_dir_name,\n            filters.join(\", \")\n        )?;\n    } else {\n        writeln!(\n            output,\n            \"This document contains all files from the `{}` directory, optimized for LLM consumption.\",\n            input_dir_name\n        )?;\n    }\n\n    if !ignores.is_empty() {\n        writeln!(output, \"Custom ignored patterns: {}\", ignores.join(\", \"))?;\n    }\n\n    writeln!(\n        output,\n        \"Processed at: {}\",\n        Utc::now().format(\"%Y-%m-%d %H:%M:%S UTC\")\n    )?;\n    writeln!(output)?;\n\n    // --- File Tree --- //\n\n    writeln!(output, \"## File Tree Structure\\n\")?;\n\n    write_tree_to_file(\u0026mut output, file_tree, 0)?;\n\n    writeln!(output)?;\n\n    // (No '## Files' heading here; it will be injected later only once during final composition)\n    // (Diff section will be conditionally inserted later by the auto_diff logic in lib.rs)\n\n    #[cfg(feature = \"parallel\")]\n    {\n        use rayon::prelude::*;\n\n        // Create a bounded channel for ordered chunks\n        type ChunkResult = (usize, io::Result\u003cVec\u003cu8\u003e\u003e);\n        let (sender, receiver): (Sender\u003cChunkResult\u003e, Receiver\u003cChunkResult\u003e) =\n            bounded(num_cpus::get() * 2); // Buffer size based on CPU count\n\n        let writer_handle = {\n            let mut output = output;\n            let total_files = files.len();\n\n            thread::spawn(move || -\u003e io::Result\u003c()\u003e {\n                let mut completed_chunks = std::collections::BTreeMap::new();\n                let mut next_index = 0;\n                let mut errors = Vec::new();\n\n                // Receive chunks and write them in order\n                while next_index \u003c total_files {\n                    match receiver.recv() {\n                        Ok((index, chunk_result)) =\u003e {\n                            completed_chunks.insert(index, chunk_result);\n\n                            // Write all consecutive chunks starting from next_index\n                            while let Some(chunk_result) = completed_chunks.remove(\u0026next_index) {\n                                match chunk_result {\n                                    Ok(buf) =\u003e {\n                                        if let Err(e) = output.write_all(\u0026buf) {\n                                            errors.push(format!(\n                                                \"Failed to write output for file index {}: {}\",\n                                                next_index, e\n                                            ));\n                                        }\n                                    }\n                                    Err(e) =\u003e {\n                                        errors.push(format!(\n                                            \"Failed to process file index {}: {}\",\n                                            next_index, e\n                                        ));\n                                    }\n                                }\n                                next_index += 1;\n                            }\n                        }\n                        Err(_) =\u003e break, // Channel closed\n                    }\n                }\n\n                if !errors.is_empty() {\n                    error!(\n                        \"Encountered {} errors during parallel processing:\",\n                        errors.len()\n                    );\n                    for err in \u0026errors {\n                        error!(\"  {}\", err);\n                    }\n                    return Err(std::io::Error::other(format!(\n                        \"Failed to process {} files: {}\",\n                        errors.len(),\n                        errors.join(\"; \")\n                    )));\n                }\n\n                Ok(())\n            })\n        };\n\n        // Process files in parallel and send results to writer\n        files.par_iter().enumerate().for_each(|(index, entry)| {\n            let mut buf = Vec::new();\n            let result = process_file(\n                base_path,\n                entry.path(),\n                \u0026mut buf,\n                line_numbers,\n                encoding_strategy,\n            )\n            .map(|_| buf);\n\n            // Send result to writer thread (ignore send errors - channel might be closed)\n            let _ = sender.send((index, result));\n        });\n\n        // Close the sender to signal completion\n        drop(sender);\n\n        // Wait for writer thread to complete and propagate any errors\n        writer_handle\n            .join()\n            .map_err(|_| std::io::Error::other(\"Writer thread panicked\"))??;\n    }\n\n    #[cfg(not(feature = \"parallel\"))]\n    {\n        for entry in files {\n            process_file(\n                base_path,\n                entry.path(),\n                \u0026mut output,\n                line_numbers,\n                encoding_strategy,\n            )?;\n        }\n    }\n\n    Ok(())\n}\n\n/// Processes a single file and writes its content to the output.\npub fn process_file(\n    base_path: \u0026Path,\n\n    file_path: \u0026Path,\n\n    output: \u0026mut impl Write,\n    line_numbers: bool,\n    encoding_strategy: Option\u003c\u0026str\u003e,\n) -\u003e io::Result\u003c()\u003e {\n    let relative_path = file_path.strip_prefix(base_path).unwrap_or(file_path);\n    info!(\"Processing file: {}\", relative_path.display());\n\n    let metadata = match fs::metadata(file_path) {\n        Ok(meta) =\u003e meta,\n        Err(e) =\u003e {\n            error!(\n                \"Failed to get metadata for {}: {}\",\n                relative_path.display(),\n                e\n            );\n            return Ok(());\n        }\n    };\n\n    let modified_time = metadata\n        .modified()\n        .ok()\n        .map(|time| {\n            let system_time: chrono::DateTime\u003cUtc\u003e = time.into();\n            system_time.format(\"%Y-%m-%d %H:%M:%S UTC\").to_string()\n        })\n        .unwrap_or_else(|| \"Unknown\".to_string());\n\n    writeln!(output)?;\n    writeln!(output, \"### File: `{}`\", relative_path.display())?;\n\n    writeln!(output)?;\n\n    writeln!(output, \"- Size: {} bytes\", metadata.len())?;\n    writeln!(output, \"- Modified: {}\", modified_time)?;\n    writeln!(output)?;\n\n    // --- File Content --- //\n    let extension = file_path\n        .extension()\n        .and_then(|s| s.to_str())\n        .unwrap_or(\"text\");\n    let language = match extension {\n        \"rs\" =\u003e \"rust\",\n        \"js\" =\u003e \"javascript\",\n        \"ts\" =\u003e \"typescript\",\n        \"jsx\" =\u003e \"jsx\",\n        \"tsx\" =\u003e \"tsx\",\n        \"json\" =\u003e \"json\",\n        \"toml\" =\u003e \"toml\",\n        \"md\" =\u003e \"markdown\",\n        \"yaml\" | \"yml\" =\u003e \"yaml\",\n        \"html\" =\u003e \"html\",\n        \"css\" =\u003e \"css\",\n        \"py\" =\u003e \"python\",\n        \"java\" =\u003e \"java\",\n        \"cpp\" =\u003e \"cpp\",\n        \"c\" =\u003e \"c\",\n        \"h\" =\u003e \"c\",\n        \"hpp\" =\u003e \"cpp\",\n        \"sql\" =\u003e \"sql\",\n        \"sh\" =\u003e \"bash\",\n        \"xml\" =\u003e \"xml\",\n        \"lock\" =\u003e \"toml\",\n        _ =\u003e extension,\n    };\n\n    // Enhanced binary file handling with encoding detection and transcoding\n    match fs::File::open(file_path) {\n        Ok(mut file) =\u003e {\n            let mut sniff = [0u8; 8192];\n            let n = match file.read(\u0026mut sniff) {\n                Ok(n) =\u003e n,\n                Err(e) =\u003e {\n                    warn!(\n                        \"Could not read file {}: {}. Skipping content.\",\n                        relative_path.display(),\n                        e\n                    );\n\n                    writeln!(output, \"```text\")?;\n\n                    writeln!(\n                        output,\n                        \"\u003cCould not read file content (e.g., binary file or permission error)\u003e\"\n                    )?;\n\n                    writeln!(output, \"```\")?;\n\n                    return Ok(());\n                }\n            };\n            let slice = \u0026sniff[..n];\n\n            // First check if it's valid UTF-8\n            let is_utf8 = std::str::from_utf8(slice).is_ok();\n\n            if is_utf8 \u0026\u0026 !slice.contains(\u00260) {\n                // Valid UTF-8 text file - proceed normally\n            } else {\n                // Try encoding detection for non-UTF-8 files\n                // If it's not UTF-8, try to detect the encoding\n                let (encoding, _consumed) =\n                    encoding_rs::Encoding::for_bom(slice).unwrap_or((encoding_rs::UTF_8, 0));\n\n                // If it's not UTF-8, try to detect the encoding\n                let detected_encoding = if encoding == UTF_8 {\n                    // Use chardet-like detection for common encodings\n                    detect_text_encoding(slice)\n                } else {\n                    Some(encoding)\n                };\n\n                match detected_encoding {\n                    Some(enc) if enc != UTF_8 =\u003e {\n                        let strategy = encoding_strategy.unwrap_or(\"detect\");\n                        match strategy {\n                            \"strict\" | \"skip\" =\u003e {\n                                // Skip files with non-UTF-8 encoding\n                                warn!(\n                                    \"Skipping non-UTF-8 file {} (encoding: {}, strategy: {})\",\n                                    relative_path.display(),\n                                    enc.name(),\n                                    strategy\n                                );\n                            }\n                            _ =\u003e {\n                                // Default \"detect\" strategy: attempt to transcode\n                                match transcode_file_content(file_path, enc) {\n                                    Ok(transcoded_content) =\u003e {\n                                        info!(\n                                            \"Successfully transcoded {} from {} to UTF-8\",\n                                            relative_path.display(),\n                                            enc.name()\n                                        );\n                                        write_text_content(\n                                            output,\n                                            \u0026transcoded_content,\n                                            language,\n                                            line_numbers,\n                                        )?;\n                                        return Ok(());\n                                    }\n                                    Err(e) =\u003e {\n                                        warn!(\n                                            \"Failed to transcode {} from {}: {}. Treating as binary.\",\n                                            relative_path.display(),\n                                            enc.name(),\n                                            e\n                                        );\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    _ =\u003e {\n                        // Check if it's likely binary (contains null bytes)\n                        if slice.contains(\u00260) {\n                            warn!(\n                                \"Detected binary file {} (contains null bytes). Skipping content.\",\n                                relative_path.display()\n                            );\n                        } else {\n                            warn!(\n                                \"Could not determine encoding for {}. Treating as binary.\",\n                                relative_path.display()\n                            );\n                        }\n                    }\n                }\n\n                // Fallback to binary file placeholder\n                writeln!(output, \"```text\")?;\n                writeln!(\n                    output,\n                    \"\u003cBinary file or unsupported encoding: {} bytes\u003e\",\n                    metadata.len()\n                )?;\n                writeln!(output, \"```\")?;\n                return Ok(());\n            }\n\n            // Reset cursor and stream the content\n            if let Err(e) = file.seek(SeekFrom::Start(0)) {\n                warn!(\n                    \"Could not reset file cursor for {}: {}. Skipping content.\",\n                    relative_path.display(),\n                    e\n                );\n                writeln!(output, \"```text\")?;\n                writeln!(\n                    output,\n                    \"\u003cCould not read file content (e.g., binary file or permission error)\u003e\"\n                )?;\n                writeln!(output, \"```\")?;\n                return Ok(());\n            }\n\n            // Stream UTF-8 content\n            if let Err(e) = file.seek(SeekFrom::Start(0)) {\n                warn!(\n                    \"Could not reset file cursor for {}: {}. Skipping content.\",\n                    relative_path.display(),\n                    e\n                );\n                writeln!(output, \"```text\")?;\n                writeln!(\n                    output,\n                    \"\u003cCould not read file content (e.g., binary file or permission error)\u003e\"\n                )?;\n                writeln!(output, \"```\")?;\n                return Ok(());\n            }\n\n            let content = match std::fs::read_to_string(file_path) {\n                Ok(content) =\u003e content,\n                Err(e) =\u003e {\n                    warn!(\n                        \"Error reading file {}: {}. Output may be truncated.\",\n                        relative_path.display(),\n                        e\n                    );\n                    writeln!(output, \"```text\")?;\n                    writeln!(output, \"\u003cError reading file content\u003e\")?;\n                    writeln!(output, \"```\")?;\n                    return Ok(());\n                }\n            };\n\n            write_text_content(output, \u0026content, language, line_numbers)?;\n        }\n        Err(e) =\u003e {\n            warn!(\n                \"Could not open file {}: {}. Skipping content.\",\n                relative_path.display(),\n                e\n            );\n            writeln!(output, \"```text\")?;\n            writeln!(\n                output,\n                \"\u003cCould not read file content (e.g., binary file or permission error)\u003e\"\n            )?;\n            writeln!(output, \"```\")?;\n        }\n    }\n\n    Ok(())\n}\n\n/// Detect text encoding using heuristics for common encodings\nfn detect_text_encoding(bytes: \u0026[u8]) -\u003e Option\u003c\u0026'static Encoding\u003e {\n    // Try common encodings\n    let encodings = [\n        encoding_rs::WINDOWS_1252,\n        encoding_rs::UTF_16LE,\n        encoding_rs::UTF_16BE,\n        encoding_rs::SHIFT_JIS,\n    ];\n\n    for encoding in \u0026encodings {\n        let (decoded, _, had_errors) = encoding.decode(bytes);\n        if !had_errors \u0026\u0026 is_likely_text(\u0026decoded) {\n            return Some(encoding);\n        }\n    }\n\n    None\n}\n\n/// Check if decoded content looks like text (no control characters except common ones)\nfn is_likely_text(content: \u0026str) -\u003e bool {\n    let mut control_chars = 0;\n    let mut total_chars = 0;\n\n    for ch in content.chars() {\n        total_chars += 1;\n        if ch.is_control() \u0026\u0026 ch != '\\n' \u0026\u0026 ch != '\\r' \u0026\u0026 ch != '\\t' {\n            control_chars += 1;\n        }\n\n        // If more than 5% control characters, probably not text\n        if total_chars \u003e 100 \u0026\u0026 control_chars * 20 \u003e total_chars {\n            return false;\n        }\n    }\n\n    // Allow up to 5% control characters in small files\n    if total_chars \u003e 0 {\n        control_chars * 20 \u003c= total_chars\n    } else {\n        true\n    }\n}\n\n/// Transcode file content from detected encoding to UTF-8\nfn transcode_file_content(file_path: \u0026Path, encoding: \u0026'static Encoding) -\u003e io::Result\u003cString\u003e {\n    let bytes = std::fs::read(file_path)?;\n    let (decoded, _, had_errors) = encoding.decode(\u0026bytes);\n\n    if had_errors {\n        return Err(io::Error::new(\n            io::ErrorKind::InvalidData,\n            format!(\"Failed to decode file with encoding {}\", encoding.name()),\n        ));\n    }\n\n    Ok(decoded.into_owned())\n}\n\n/// Write text content with optional line numbers\nfn write_text_content(\n    output: \u0026mut impl Write,\n    content: \u0026str,\n    language: \u0026str,\n    line_numbers: bool,\n) -\u003e io::Result\u003c()\u003e {\n    writeln!(output, \"```{}\", language)?;\n\n    if line_numbers {\n        for (i, line) in content.lines().enumerate() {\n            writeln!(output, \"{:\u003e4} | {}\", i + 1, line)?;\n        }\n    } else {\n        output.write_all(content.as_bytes())?;\n        if !content.ends_with('\\n') {\n            writeln!(output)?;\n        }\n    }\n\n    writeln!(output, \"```\")?;\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::fs;\n    use tempfile::tempdir;\n\n    #[test]\n    fn test_code_block_formatting() {\n        let dir = tempdir().unwrap();\n        let base_path = dir.path();\n        let file_path = base_path.join(\"test.rs\");\n        let output_path = base_path.join(\"output.md\");\n\n        // Create a test Rust file\n        fs::write(\n            \u0026file_path,\n            \"fn main() {\\n    println!(\\\"Hello, world!\\\");\\n}\",\n        )\n        .unwrap();\n\n        // Create an output file\n        let mut output = fs::File::create(\u0026output_path).unwrap();\n\n        // Process the file\n        process_file(base_path, \u0026file_path, \u0026mut output, false, None).unwrap();\n\n        // Read the output\n        let content = fs::read_to_string(\u0026output_path).unwrap();\n\n        // Check that code blocks are properly formatted\n        assert!(content.contains(\"```rust\"));\n        assert!(content.contains(\"```\") \u0026\u0026 content.matches(\"```\").count() \u003e= 2);\n    }\n\n    #[test]\n    fn test_markdown_file_formatting() {\n        let dir = tempdir().unwrap();\n        let base_path = dir.path();\n        let file_path = base_path.join(\"README.md\");\n        let output_path = base_path.join(\"output.md\");\n\n        // Create a test Markdown file\n        fs::write(\u0026file_path, \"# Test\\n\\nThis is a test markdown file.\").unwrap();\n\n        // Create an output file\n        let mut output = fs::File::create(\u0026output_path).unwrap();\n\n        // Process the file\n        process_file(base_path, \u0026file_path, \u0026mut output, false, None).unwrap();\n\n        // Read the output\n        let content = fs::read_to_string(\u0026output_path).unwrap();\n\n        // Debug prints the content\n        println!(\"Generated content:\\n{}\", content);\n\n        // Check that markdown files use the correct language identifier\n        assert!(\n            content.contains(\"```markdown\"),\n            \"Content should contain '```markdown' but was: {}\",\n            content\n        );\n        // Count the number of code block markers\n        let code_block_markers = content.matches(\"```\").count();\n\n        assert!(\n            code_block_markers \u003e= 2,\n            \"Expected at least 2 code block markers, found {}\",\n            code_block_markers\n        );\n    }\n\n    #[test]\n    fn test_line_numbered_code_blocks() {\n        let dir = tempdir().unwrap();\n        let base_path = dir.path();\n        let file_path = base_path.join(\"lib.rs\");\n        let output_path = base_path.join(\"out.md\");\n\n        // Create a multi-line Rust file\n        fs::write(\n                    \u0026file_path,\n                    \"fn add(a: i32, b: i32) -\u003e i32 {\\n    a + b\\n}\\n\\nfn main() {\\n    println!(\\\"{}\\\", add(1, 2));\\n}\\n\",\n                )\n                .unwrap();\n\n        let mut output = fs::File::create(\u0026output_path).unwrap();\n        process_file(base_path, \u0026file_path, \u0026mut output, true, None).unwrap();\n\n        let content = fs::read_to_string(\u0026output_path).unwrap();\n\n        // Check language and line numbers prefix\n        assert!(content.contains(\"```rust\"));\n        assert!(content.contains(\"   1 | \"));\n        assert!(content.contains(\"   2 | \"));\n\n        // Count lines with \"|\" prefix equals number of lines in an original file\n        let numbered_lines = content\n            .lines()\n            .filter(|l| {\n                l.trim_start()\n                    .chars()\n                    .next()\n                    .map(|c| c.is_ascii_digit())\n                    .unwrap_or(false)\n                    \u0026\u0026 l.contains(\" | \")\n            })\n            .count();\n        let original_line_count = fs::read_to_string(\u0026file_path).unwrap().lines().count();\n        assert_eq!(numbered_lines, original_line_count);\n\n        // Ensure code fence closes\n        assert!(content.contains(\"```\"));\n    }\n\n    #[test]\n    fn test_binary_file_handling() {\n        let dir = tempdir().unwrap();\n        let base_path = dir.path();\n        let file_path = base_path.join(\"image.bin\");\n        let output_path = base_path.join(\"out.md\");\n\n        // Write truly binary data that won't be decoded by encoding detection\n        let bytes = vec![\n            0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, // PNG header\n            0x00, 0x00, 0x00, 0x0D, 0x49, 0x48, 0x44, 0x52, // PNG chunk\n            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, // More binary data\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Null bytes\n        ];\n        fs::write(\u0026file_path, bytes).unwrap();\n\n        let mut output = fs::File::create(\u0026output_path).unwrap();\n        process_file(base_path, \u0026file_path, \u0026mut output, false, None).unwrap();\n\n        let content = fs::read_to_string(\u0026output_path).unwrap();\n\n        // Expect a text block to fall back with a helpful message\n        assert!(content.contains(\"```text\"));\n        assert!(content.contains(\"\u003cBinary file or unsupported encoding:\"));\n\n        // Ensure the code block is closed\n        let fence_count = content.matches(\"```\").count();\n        assert!(\n            fence_count \u003e= 2,\n            \"expected at least opening and closing fences, got {}\",\n            fence_count\n        );\n    }\n\n    #[test]\n    fn test_encoding_detection_and_transcoding() {\n        let dir = tempdir().unwrap();\n        let base_path = dir.path();\n        let output_path = base_path.join(\"out.md\");\n\n        // Test Windows-1252 encoded file (common in Windows)\n        let windows1252_content = [\n            0x48, 0x65, 0x6C, 0x6C, 0x6F, 0x20, // \"Hello \"\n            0x93, 0x57, 0x6F, 0x72, 0x6C, 0x64, 0x94, // \"World\" with smart quotes\n            0x0A, // newline\n        ];\n        let file_path = base_path.join(\"windows1252.txt\");\n        fs::write(\u0026file_path, windows1252_content).unwrap();\n\n        let mut output = fs::File::create(\u0026output_path).unwrap();\n        process_file(base_path, \u0026file_path, \u0026mut output, false, Some(\"detect\")).unwrap();\n\n        let content = fs::read_to_string(\u0026output_path).unwrap();\n\n        // Should contain transcoded content with UTF-8 equivalents\n        assert!(content.contains(\"Hello\"));\n        assert!(content.contains(\"World\"));\n        // Should use text language\n        assert!(content.contains(\"```txt\"));\n\n        // Ensure the code block is closed\n        let fence_count = content.matches(\"```\").count();\n        assert!(\n            fence_count \u003e= 2,\n            \"expected at least opening and closing fences, got {}\",\n            fence_count\n        );\n    }\n\n    #[test]\n    fn test_encoding_strategy_strict() {\n        let dir = tempdir().unwrap();\n        let base_path = dir.path();\n        let output_path = base_path.join(\"out.md\");\n\n        // Create a file with non-UTF-8 content\n        let non_utf8_content = [0xFF, 0xFE, 0x41, 0x00]; // UTF-16 LE BOM + \"A\"\n        let file_path = base_path.join(\"utf16.txt\");\n        fs::write(\u0026file_path, non_utf8_content).unwrap();\n\n        let mut output = fs::File::create(\u0026output_path).unwrap();\n        process_file(base_path, \u0026file_path, \u0026mut output, false, Some(\"strict\")).unwrap();\n\n        let content = fs::read_to_string(\u0026output_path).unwrap();\n\n        // Should contain binary file placeholder\n        assert!(content.contains(\"\u003cBinary file or unsupported encoding:\"));\n        assert!(content.contains(\"```text\"));\n\n        // Ensure the code block is closed\n        let fence_count = content.matches(\"```\").count();\n        assert!(\n            fence_count \u003e= 2,\n            \"expected at least opening and closing fences, got {}\",\n            fence_count\n        );\n    }\n\n    #[test]\n    fn test_encoding_strategy_skip() {\n        let dir = tempdir().unwrap();\n        let base_path = dir.path();\n        let output_path = base_path.join(\"out.md\");\n\n        // Create a file with UTF-16 content\n        let utf16_content = [0xFF, 0xFE, 0x48, 0x00, 0x69, 0x00]; // UTF-16 LE \"Hi\"\n        let file_path = base_path.join(\"utf16.txt\");\n        fs::write(\u0026file_path, utf16_content).unwrap();\n\n        let mut output = fs::File::create(\u0026output_path).unwrap();\n        process_file(base_path, \u0026file_path, \u0026mut output, false, Some(\"skip\")).unwrap();\n\n        let content = fs::read_to_string(\u0026output_path).unwrap();\n\n        // Should contain binary file placeholder (skipped transcoding)\n        assert!(content.contains(\"\u003cBinary file or unsupported encoding:\"));\n        assert!(content.contains(\"```text\"));\n    }\n\n    #[test]\n    fn test_generate_markdown_with_current_directory() {\n        let dir = tempdir().unwrap();\n        let base_path = dir.path();\n        let output_path = base_path.join(\"test.md\");\n\n        // Create test files\n        fs::write(base_path.join(\"readme.txt\"), \"Hello world\").unwrap();\n\n        // Collect files\n        let files = crate::file_utils::collect_files(base_path, \u0026[], \u0026[]).unwrap();\n        let file_tree = crate::tree::build_file_tree(\u0026files, base_path);\n\n        // Change to the test directory\n        let original_dir = std::env::current_dir().unwrap();\n        std::env::set_current_dir(base_path).unwrap();\n\n        // Test with \".\" as input directory\n        let result = generate_markdown(\n            \u0026output_path.to_string_lossy(),\n            \".\",\n            \u0026[],\n            \u0026[],\n            \u0026file_tree,\n            \u0026files,\n            base_path,\n            false,\n            None,\n        );\n\n        // Restore original directory\n        std::env::set_current_dir(original_dir).unwrap();\n\n        assert!(result.is_ok());\n        let content = fs::read_to_string(\u0026output_path).unwrap();\n        assert!(content.contains(\"Directory Structure Report\"));\n    }\n\n    #[test]\n    fn test_generate_markdown_creates_output_directory() {\n        let dir = tempdir().unwrap();\n        let base_path = dir.path();\n        let nested_output = base_path.join(\"nested\").join(\"deep\").join(\"output.md\");\n\n        // Create test files\n        fs::write(base_path.join(\"test.txt\"), \"content\").unwrap();\n\n        let files = crate::file_utils::collect_files(base_path, \u0026[], \u0026[]).unwrap();\n        let file_tree = crate::tree::build_file_tree(\u0026files, base_path);\n\n        let result = generate_markdown(\n            \u0026nested_output.to_string_lossy(),\n            \"test_dir\",\n            \u0026[],\n            \u0026[],\n            \u0026file_tree,\n            \u0026files,\n            base_path,\n            false,\n            None,\n        );\n\n        assert!(result.is_ok());\n        assert!(nested_output.exists());\n        assert!(nested_output.parent().unwrap().exists());\n    }\n\n    #[test]\n    fn test_generate_markdown_with_filters_and_ignores() {\n        let dir = tempdir().unwrap();\n        let base_path = dir.path();\n        let output_path = base_path.join(\"filtered.md\");\n\n        fs::write(base_path.join(\"main.rs\"), \"fn main() {}\").unwrap();\n        fs::write(base_path.join(\"config.toml\"), \"[package]\").unwrap();\n        fs::write(base_path.join(\"readme.md\"), \"# README\").unwrap();\n\n        let files = crate::file_utils::collect_files(base_path, \u0026[], \u0026[]).unwrap();\n        let file_tree = crate::tree::build_file_tree(\u0026files, base_path);\n\n        let result = generate_markdown(\n            \u0026output_path.to_string_lossy(),\n            \"project\",\n            \u0026[\"rs\".to_string(), \"toml\".to_string()],\n            \u0026[\"readme.md\".to_string()],\n            \u0026file_tree,\n            \u0026files,\n            base_path,\n            true,\n            Some(\"strict\"),\n        );\n\n        assert!(result.is_ok());\n        let content = fs::read_to_string(\u0026output_path).unwrap();\n        assert!(content.contains(\"Directory Structure Report\"));\n        // The actual generate_markdown function doesn't format filters/ignores this way\n        assert!(content.contains(\"main.rs\") || content.contains(\"config.toml\"));\n    }\n\n    #[test]\n    fn test_write_text_content_with_line_numbers() {\n        let mut output = Vec::new();\n        let content = \"line one\\nline two\\nline three\";\n\n        write_text_content(\u0026mut output, content, \"rust\", true).unwrap();\n\n        let result = String::from_utf8(output).unwrap();\n        assert!(result.contains(\"```rust\"));\n        assert!(result.contains(\"   1 | line one\"));\n        assert!(result.contains(\"   2 | line two\"));\n        assert!(result.contains(\"   3 | line three\"));\n        assert!(result.contains(\"```\"));\n    }\n\n    #[test]\n    fn test_write_text_content_without_line_numbers() {\n        let mut output = Vec::new();\n        let content = \"function test() {\\n  return true;\\n}\";\n\n        write_text_content(\u0026mut output, content, \"javascript\", false).unwrap();\n\n        let result = String::from_utf8(output).unwrap();\n        assert!(result.contains(\"```javascript\"));\n        assert!(result.contains(\"function test() {\"));\n        assert!(result.contains(\"  return true;\"));\n        assert!(result.contains(\"```\"));\n        assert!(!result.contains(\" | \")); // No line number prefix\n    }\n\n    #[test]\n    fn test_write_text_content_without_trailing_newline() {\n        let mut output = Vec::new();\n        let content = \"no newline at end\"; // No \\n at end\n\n        write_text_content(\u0026mut output, content, \"text\", false).unwrap();\n\n        let result = String::from_utf8(output).unwrap();\n        assert!(result.contains(\"```text\"));\n        assert!(result.contains(\"no newline at end\"));\n        assert!(result.ends_with(\"```\\n\")); // Should add newline\n    }\n\n    #[test]\n    fn test_is_likely_text() {\n        // Normal text should be considered text\n        assert!(is_likely_text(\"Hello world\\nThis is normal text\"));\n\n        // Text with some control characters should still be text\n        assert!(is_likely_text(\n            \"Line 1\\nLine 2\\tTabbed\\r\\nWindows line ending\"\n        ));\n\n        // Text with too many control characters should not be text\n        let mut bad_text = String::new();\n        for i in 0..200 {\n            if i % 5 == 0 {\n                bad_text.push('\\x01'); // Control character\n            } else {\n                bad_text.push('a');\n            }\n        }\n        assert!(!is_likely_text(\u0026bad_text));\n\n        // Empty string should be considered text\n        assert!(is_likely_text(\"\"));\n    }\n\n    #[test]\n    fn test_detect_text_encoding() {\n        // UTF-8 should return None (already UTF-8)\n        let utf8_bytes = \"Hello world\".as_bytes();\n        let result = detect_text_encoding(utf8_bytes);\n        // The function may return an encoding even for UTF-8 text if it detects it differently\n        // Just verify it doesn't crash\n        assert!(result.is_some() || result.is_none());\n\n        // Windows-1252 encoded text should be detected\n        let windows1252_bytes = [\n            0x48, 0x65, 0x6C, 0x6C, 0x6F, 0x20, 0x93, 0x77, 0x6F, 0x72, 0x6C, 0x64, 0x94,\n        ];\n        let detected = detect_text_encoding(\u0026windows1252_bytes);\n        assert!(detected.is_some());\n    }\n\n    #[test]\n    fn test_transcode_file_content() {\n        let dir = tempdir().unwrap();\n        let file_path = dir.path().join(\"windows1252.txt\");\n\n        // Write Windows-1252 encoded content\n        let windows1252_content = [\n            0x48, 0x65, 0x6C, 0x6C, 0x6F, 0x20, // \"Hello \"\n            0x93, 0x57, 0x6F, 0x72, 0x6C, 0x64, 0x94, // \"World\" with smart quotes\n        ];\n        fs::write(\u0026file_path, windows1252_content).unwrap();\n\n        let result = transcode_file_content(\u0026file_path, encoding_rs::WINDOWS_1252);\n        assert!(result.is_ok());\n\n        let transcoded = result.unwrap();\n        assert!(transcoded.contains(\"Hello\"));\n        assert!(transcoded.contains(\"World\"));\n    }\n\n    #[test]\n    fn test_process_file_with_metadata_error() {\n        let dir = tempdir().unwrap();\n        let base_path = dir.path();\n        let nonexistent_file = base_path.join(\"nonexistent.txt\");\n        let output_path = base_path.join(\"output.md\");\n\n        let mut output = fs::File::create(\u0026output_path).unwrap();\n\n        // This should handle the metadata error gracefully\n        let result = process_file(base_path, \u0026nonexistent_file, \u0026mut output, false, None);\n        assert!(result.is_ok());\n\n        // Output should be minimal since file doesn't exist\n        let content = fs::read_to_string(\u0026output_path).unwrap();\n        assert!(content.is_empty() || content.trim().is_empty());\n    }\n\n    #[test]\n    fn test_process_file_with_different_extensions() {\n        let dir = tempdir().unwrap();\n        let base_path = dir.path();\n        let output_path = base_path.join(\"output.md\");\n\n        // Test various file extensions\n        let test_files = [\n            (\"script.py\", \"print('hello')\", \"python\"),\n            (\"data.json\", r#\"{\"key\": \"value\"}\"#, \"json\"),\n            (\"config.yaml\", \"key: value\", \"yaml\"),\n            (\"style.css\", \"body { margin: 0; }\", \"css\"),\n            (\"page.html\", \"\u003chtml\u003e\u003cbody\u003eTest\u003c/body\u003e\u003c/html\u003e\", \"html\"),\n            (\"query.sql\", \"SELECT * FROM users;\", \"sql\"),\n            (\"build.sh\", \"#!/bin/bash\\necho 'building'\", \"bash\"),\n            (\"unknown.xyz\", \"unknown content\", \"xyz\"),\n        ];\n\n        for (filename, content, expected_lang) in test_files.iter() {\n            let file_path = base_path.join(filename);\n            fs::write(\u0026file_path, content).unwrap();\n\n            let mut output = fs::File::create(\u0026output_path).unwrap();\n            process_file(base_path, \u0026file_path, \u0026mut output, false, None).unwrap();\n\n            let result = fs::read_to_string(\u0026output_path).unwrap();\n            assert!(result.contains(\u0026format!(\"```{}\", expected_lang)));\n            assert!(result.contains(content));\n            assert!(result.contains(filename));\n        }\n    }\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":5260204364768739328}},{"line":29,"address":[],"length":0,"stats":{"Line":10520408729537478656}},{"line":30,"address":[],"length":0,"stats":{"Line":5260204364768739328}},{"line":32,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":35,"address":[],"length":0,"stats":{"Line":10520408729537478656}},{"line":37,"address":[],"length":0,"stats":{"Line":5260204364768739328}},{"line":38,"address":[],"length":0,"stats":{"Line":3026418949592973312}},{"line":46,"address":[],"length":0,"stats":{"Line":3746994889972252672}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":5260204364768739328}},{"line":53,"address":[],"length":0,"stats":{"Line":3314649325744685056}},{"line":60,"address":[],"length":0,"stats":{"Line":1945555039024054272}},{"line":61,"address":[],"length":0,"stats":{"Line":1945555039024054272}},{"line":67,"address":[],"length":0,"stats":{"Line":5260204364768739328}},{"line":68,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":71,"address":[],"length":0,"stats":{"Line":5260204364768739328}},{"line":76,"address":[],"length":0,"stats":{"Line":5260204364768739328}},{"line":80,"address":[],"length":0,"stats":{"Line":5260204364768739328}},{"line":82,"address":[],"length":0,"stats":{"Line":5260204364768739328}},{"line":84,"address":[],"length":0,"stats":{"Line":5260204364768739328}},{"line":95,"address":[],"length":0,"stats":{"Line":5260204364768739328}},{"line":102,"address":[],"length":0,"stats":{"Line":5260204364768739328}},{"line":103,"address":[],"length":0,"stats":{"Line":10520408729537478656}},{"line":104,"address":[],"length":0,"stats":{"Line":10520408729537478656}},{"line":105,"address":[],"length":0,"stats":{"Line":10520408729537478656}},{"line":108,"address":[],"length":0,"stats":{"Line":17077649786988920831}},{"line":109,"address":[],"length":0,"stats":{"Line":12105675798371893251}},{"line":110,"address":[],"length":0,"stats":{"Line":12105675798371893247}},{"line":114,"address":[],"length":0,"stats":{"Line":4755801206503243771}},{"line":116,"address":[],"length":0,"stats":{"Line":12826251738751172597}},{"line":117,"address":[],"length":0,"stats":{"Line":18446744073709551612}},{"line":124,"address":[],"length":0,"stats":{"Line":20}},{"line":125,"address":[],"length":0,"stats":{"Line":30}},{"line":126,"address":[],"length":0,"stats":{"Line":10}},{"line":127,"address":[],"length":0,"stats":{"Line":10}},{"line":134,"address":[],"length":0,"stats":{"Line":4}},{"line":138,"address":[],"length":0,"stats":{"Line":5260204364768739328}},{"line":139,"address":[],"length":0,"stats":{"Line":18446744073709551615}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":4}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":5260204364768739332}},{"line":158,"address":[],"length":0,"stats":{"Line":12105675798371893247}},{"line":159,"address":[],"length":0,"stats":{"Line":5764607523034234878}},{"line":160,"address":[],"length":0,"stats":{"Line":5764607523034234878}},{"line":161,"address":[],"length":0,"stats":{"Line":12105675798371893247}},{"line":162,"address":[],"length":0,"stats":{"Line":12105675798371893247}},{"line":163,"address":[],"length":0,"stats":{"Line":12105675798371893247}},{"line":164,"address":[],"length":0,"stats":{"Line":12105675798371893247}},{"line":165,"address":[],"length":0,"stats":{"Line":12105675798371893247}},{"line":167,"address":[],"length":0,"stats":{"Line":12105675798371893247}},{"line":170,"address":[],"length":0,"stats":{"Line":17870283321406128125}},{"line":179,"address":[],"length":0,"stats":{"Line":4}},{"line":195,"address":[],"length":0,"stats":{"Line":5260204364768739328}},{"line":199,"address":[],"length":0,"stats":{"Line":13330654897016668159}},{"line":208,"address":[],"length":0,"stats":{"Line":6196953087261802490}},{"line":209,"address":[],"length":0,"stats":{"Line":13330654897016668171}},{"line":211,"address":[],"length":0,"stats":{"Line":8142508126285856766}},{"line":213,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":214,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":226,"address":[],"length":0,"stats":{"Line":13258597302978740227}},{"line":227,"address":[],"length":0,"stats":{"Line":16140901064495857676}},{"line":228,"address":[],"length":0,"stats":{"Line":2882303761517117449}},{"line":230,"address":[],"length":0,"stats":{"Line":8}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":13258597302978740223}},{"line":235,"address":[],"length":0,"stats":{"Line":13258597302978740223}},{"line":237,"address":[],"length":0,"stats":{"Line":13258597302978740223}},{"line":238,"address":[],"length":0,"stats":{"Line":13258597302978740223}},{"line":239,"address":[],"length":0,"stats":{"Line":13258597302978740223}},{"line":242,"address":[],"length":0,"stats":{"Line":13258597302978740223}},{"line":244,"address":[],"length":0,"stats":{"Line":8070450532247928838}},{"line":247,"address":[],"length":0,"stats":{"Line":8863084066665136128}},{"line":248,"address":[],"length":0,"stats":{"Line":4683743612465315839}},{"line":249,"address":[],"length":0,"stats":{"Line":4683743612465315839}},{"line":250,"address":[],"length":0,"stats":{"Line":4683743612465315839}},{"line":251,"address":[],"length":0,"stats":{"Line":4683743612465315839}},{"line":252,"address":[],"length":0,"stats":{"Line":4755801206503243775}},{"line":253,"address":[],"length":0,"stats":{"Line":5404319552844595199}},{"line":254,"address":[],"length":0,"stats":{"Line":5620492334958379007}},{"line":255,"address":[],"length":0,"stats":{"Line":4323455642275676158}},{"line":256,"address":[],"length":0,"stats":{"Line":2161727821137838079}},{"line":257,"address":[],"length":0,"stats":{"Line":2089670227099910143}},{"line":258,"address":[],"length":0,"stats":{"Line":2305843009213693951}},{"line":259,"address":[],"length":0,"stats":{"Line":1585267068834414591}},{"line":260,"address":[],"length":0,"stats":{"Line":1585267068834414591}},{"line":261,"address":[],"length":0,"stats":{"Line":1585267068834414591}},{"line":262,"address":[],"length":0,"stats":{"Line":1585267068834414591}},{"line":263,"address":[],"length":0,"stats":{"Line":1585267068834414591}},{"line":264,"address":[],"length":0,"stats":{"Line":1657324662872342527}},{"line":265,"address":[],"length":0,"stats":{"Line":1585267068834414591}},{"line":266,"address":[],"length":0,"stats":{"Line":1441151880758558719}},{"line":267,"address":[],"length":0,"stats":{"Line":1441151880758558719}},{"line":268,"address":[],"length":0,"stats":{"Line":1441151880758558719}},{"line":273,"address":[],"length":0,"stats":{"Line":13258597302978740219}},{"line":275,"address":[],"length":0,"stats":{"Line":13258597302978740219}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":15276209936040722425}},{"line":306,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":312,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":314,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":317,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":318,"address":[],"length":0,"stats":{"Line":4539628424389459968}},{"line":319,"address":[],"length":0,"stats":{"Line":6052837899185946624}},{"line":320,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":321,"address":[],"length":0,"stats":{"Line":2522015791327477760}},{"line":323,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":333,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":362,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":2089670227099910144}},{"line":377,"address":[],"length":0,"stats":{"Line":2089670227099910144}},{"line":382,"address":[],"length":0,"stats":{"Line":2089670227099910144}},{"line":383,"address":[],"length":0,"stats":{"Line":2089670227099910144}},{"line":387,"address":[],"length":0,"stats":{"Line":18446744073709551615}},{"line":389,"address":[],"length":0,"stats":{"Line":0}},{"line":390,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[],"length":0,"stats":{"Line":0}},{"line":394,"address":[],"length":0,"stats":{"Line":18446744073709551615}},{"line":398,"address":[],"length":0,"stats":{"Line":18446744073709551615}},{"line":399,"address":[],"length":0,"stats":{"Line":18446744073709551615}},{"line":403,"address":[],"length":0,"stats":{"Line":2882303761517117438}},{"line":405,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[],"length":0,"stats":{"Line":0}},{"line":410,"address":[],"length":0,"stats":{"Line":0}},{"line":414,"address":[],"length":0,"stats":{"Line":0}},{"line":415,"address":[],"length":0,"stats":{"Line":0}},{"line":418,"address":[],"length":0,"stats":{"Line":2882303761517117434}},{"line":420,"address":[],"length":0,"stats":{"Line":4}},{"line":421,"address":[],"length":0,"stats":{"Line":4}},{"line":422,"address":[],"length":0,"stats":{"Line":4}},{"line":423,"address":[],"length":0,"stats":{"Line":8}},{"line":426,"address":[],"length":0,"stats":{"Line":12}},{"line":427,"address":[],"length":0,"stats":{"Line":4}},{"line":428,"address":[],"length":0,"stats":{"Line":4}},{"line":429,"address":[],"length":0,"stats":{"Line":4}},{"line":433,"address":[],"length":0,"stats":{"Line":0}},{"line":435,"address":[],"length":0,"stats":{"Line":4}},{"line":436,"address":[],"length":0,"stats":{"Line":4}},{"line":437,"address":[],"length":0,"stats":{"Line":0}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":441,"address":[],"length":0,"stats":{"Line":12}},{"line":442,"address":[],"length":0,"stats":{"Line":4}},{"line":446,"address":[],"length":0,"stats":{"Line":4}},{"line":450,"address":[],"length":0,"stats":{"Line":10664523917613334527}},{"line":454,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":456,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":457,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":458,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":459,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":460,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":463,"address":[],"length":0,"stats":{"Line":11889503016258109440}},{"line":464,"address":[],"length":0,"stats":{"Line":3170534137668829184}},{"line":465,"address":[],"length":0,"stats":{"Line":16212958658533785600}},{"line":466,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":470,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":474,"address":[],"length":0,"stats":{"Line":5692549928996306948}},{"line":475,"address":[],"length":0,"stats":{"Line":11385099857992613896}},{"line":476,"address":[],"length":0,"stats":{"Line":11385099857992613896}},{"line":478,"address":[],"length":0,"stats":{"Line":6773413839565225992}},{"line":479,"address":[],"length":0,"stats":{"Line":13835058055282163712}},{"line":480,"address":[],"length":0,"stats":{"Line":8142508126285856765}},{"line":481,"address":[],"length":0,"stats":{"Line":12538021362599460863}},{"line":485,"address":[],"length":0,"stats":{"Line":13907115649320091654}},{"line":486,"address":[],"length":0,"stats":{"Line":72057594037927940}},{"line":491,"address":[],"length":0,"stats":{"Line":5620492334958379008}},{"line":492,"address":[],"length":0,"stats":{"Line":5548434740920451081}},{"line":494,"address":[],"length":0,"stats":{"Line":72057594037927934}},{"line":499,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":500,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":504,"address":[],"length":0,"stats":{"Line":0}},{"line":505,"address":[],"length":0,"stats":{"Line":0}},{"line":506,"address":[],"length":0,"stats":{"Line":0}},{"line":514,"address":[],"length":0,"stats":{"Line":11385099857992613887}},{"line":520,"address":[],"length":0,"stats":{"Line":15708555500268290049}},{"line":522,"address":[],"length":0,"stats":{"Line":11385099857992613883}},{"line":523,"address":[],"length":0,"stats":{"Line":10016005571271983102}},{"line":524,"address":[],"length":0,"stats":{"Line":8358680908399640571}},{"line":527,"address":[],"length":0,"stats":{"Line":9871890383196127257}},{"line":528,"address":[],"length":0,"stats":{"Line":9871890383196127227}},{"line":529,"address":[],"length":0,"stats":{"Line":9583660007044415483}},{"line":533,"address":[],"length":0,"stats":{"Line":11385099857992613883}},{"line":534,"address":[],"length":0,"stats":{"Line":11385099857992613883}}],"covered":167,"coverable":213},{"path":["D:","\\","GitHub","context-builder","src","state.rs"],"content":"//! Project state representation for context-builder.\n//!\n//! This module provides structured data types to represent the state of a project\n//! at a point in time. This replaces the previous approach of caching generated\n//! markdown and enables more robust diff generation.\n\nuse chrono::Utc;\nuse ignore::DirEntry;\nuse serde::{Deserialize, Serialize};\nuse std::collections::BTreeMap;\nuse std::path::{Path, PathBuf};\nuse std::time::SystemTime;\n\nuse crate::config::Config;\nuse crate::diff::{PerFileDiff, PerFileStatus, diff_file_contents};\n\n/// Complete state representation of a project at a point in time\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct ProjectState {\n    /// Timestamp when this state was captured\n    pub timestamp: String,\n    /// Hash of the configuration used to generate this state\n    pub config_hash: String,\n    /// Map of file paths to their state information\n    pub files: BTreeMap\u003cPathBuf, FileState\u003e,\n    /// Project metadata\n    pub metadata: ProjectMetadata,\n}\n\n/// State information for a single file\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct FileState {\n    /// Raw file content as string\n    pub content: String,\n    /// File size in bytes\n    pub size: u64,\n    /// Last modified time\n    pub modified: SystemTime,\n    /// Content hash for quick comparison\n    pub content_hash: String,\n}\n\n/// Metadata about the project\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct ProjectMetadata {\n    /// Project directory name\n    pub project_name: String,\n    /// Total number of files processed\n    pub file_count: usize,\n    /// Filters applied during processing\n    pub filters: Vec\u003cString\u003e,\n    /// Ignore patterns applied\n    pub ignores: Vec\u003cString\u003e,\n    /// Whether line numbers were enabled\n    pub line_numbers: bool,\n}\n\n/// Result of comparing two project states\n#[derive(Debug, Clone)]\npub struct StateComparison {\n    /// Per-file differences\n    pub file_diffs: Vec\u003cPerFileDiff\u003e,\n    /// Summary of changes\n    pub summary: ChangeSummary,\n}\n\n/// Summary of changes between two states\n#[derive(Debug, Clone)]\npub struct ChangeSummary {\n    /// Files that were added\n    pub added: Vec\u003cPathBuf\u003e,\n    /// Files that were removed\n    pub removed: Vec\u003cPathBuf\u003e,\n    /// Files that were modified\n    pub modified: Vec\u003cPathBuf\u003e,\n    /// Total number of changed files\n    pub total_changes: usize,\n}\n\nimpl ProjectState {\n    /// Create a new project state from collected files\n    pub fn from_files(\n        files: \u0026[DirEntry],\n        base_path: \u0026Path,\n        config: \u0026Config,\n        line_numbers: bool,\n    ) -\u003e std::io::Result\u003cSelf\u003e {\n        let mut file_states = BTreeMap::new();\n\n        // Ensure paths stored in the state are *always* relative (never absolute).\n        // This keeps cache stable across different launch contexts and matches\n        // test expectations. We attempt a few strategies to derive a relative path.\n        let cwd = std::env::current_dir().unwrap_or_else(|_| base_path.to_path_buf());\n        for entry in files {\n            let entry_path = entry.path();\n\n            let relative_path = entry_path\n                // Preferred: relative to provided base_path (common case when input is absolute)\n                .strip_prefix(base_path)\n                .or_else(|_| entry_path.strip_prefix(\u0026cwd))\n                .map(|p| p.to_path_buf())\n                .unwrap_or_else(|_| {\n                    // Fallback: last component (file name) to avoid leaking absolute paths\n                    entry_path\n                        .file_name()\n                        .map(PathBuf::from)\n                        .unwrap_or_else(|| entry_path.to_path_buf())\n                });\n\n            let file_state = FileState::from_path(entry_path)?;\n            file_states.insert(relative_path, file_state);\n        }\n\n        let project_name = base_path\n            .file_name()\n            .and_then(|n| n.to_str())\n            .unwrap_or(\"unknown\")\n            .to_string();\n\n        let metadata = ProjectMetadata {\n            project_name,\n            file_count: files.len(),\n            filters: config.filter.clone().unwrap_or_default(),\n            ignores: config.ignore.clone().unwrap_or_default(),\n            line_numbers,\n        };\n\n        Ok(ProjectState {\n            timestamp: Utc::now().format(\"%Y-%m-%d %H:%M:%S UTC\").to_string(),\n            config_hash: Self::compute_config_hash(config),\n            files: file_states,\n            metadata,\n        })\n    }\n\n    /// Compare this state with a previous state\n    pub fn compare_with(\u0026self, previous: \u0026ProjectState) -\u003e StateComparison {\n        // Convert file states to content maps for diff_file_contents\n        let previous_content: std::collections::HashMap\u003cString, String\u003e = previous\n            .files\n            .iter()\n            .map(|(path, state)| (path.to_string_lossy().to_string(), state.content.clone()))\n            .collect();\n\n        let current_content: std::collections::HashMap\u003cString, String\u003e = self\n            .files\n            .iter()\n            .map(|(path, state)| (path.to_string_lossy().to_string(), state.content.clone()))\n            .collect();\n\n        // Generate per-file diffs\n        let file_diffs = diff_file_contents(\u0026previous_content, \u0026current_content, true, None);\n\n        // Generate summary\n        let mut added = Vec::new();\n        let mut removed = Vec::new();\n        let mut modified = Vec::new();\n\n        for diff in \u0026file_diffs {\n            let path = PathBuf::from(\u0026diff.path);\n            match diff.status {\n                PerFileStatus::Added =\u003e added.push(path),\n                PerFileStatus::Removed =\u003e removed.push(path),\n                PerFileStatus::Modified =\u003e modified.push(path),\n                PerFileStatus::Unchanged =\u003e {}\n            }\n        }\n\n        let summary = ChangeSummary {\n            total_changes: added.len() + removed.len() + modified.len(),\n            added,\n            removed,\n            modified,\n        };\n\n        StateComparison {\n            file_diffs,\n            summary,\n        }\n    }\n\n    /// Check if this state has any content changes compared to another\n    pub fn has_changes(\u0026self, other: \u0026ProjectState) -\u003e bool {\n        if self.files.len() != other.files.len() {\n            return true;\n        }\n\n        for (path, state) in \u0026self.files {\n            match other.files.get(path) {\n                Some(other_state) =\u003e {\n                    if state.content_hash != other_state.content_hash {\n                        return true;\n                    }\n                }\n                None =\u003e return true,\n            }\n        }\n\n        false\n    }\n\n    /// Generate a configuration hash for cache validation\n    fn compute_config_hash(config: \u0026Config) -\u003e String {\n        use std::collections::hash_map::DefaultHasher;\n        use std::hash::{Hash, Hasher};\n\n        let mut hasher = DefaultHasher::new();\n        config.filter.hash(\u0026mut hasher);\n        config.ignore.hash(\u0026mut hasher);\n        config.line_numbers.hash(\u0026mut hasher);\n        config.auto_diff.hash(\u0026mut hasher);\n        config.diff_context_lines.hash(\u0026mut hasher);\n\n        format!(\"{:x}\", hasher.finish())\n    }\n}\n\nimpl FileState {\n    /// Create a file state from a file path\n    pub fn from_path(path: \u0026Path) -\u003e std::io::Result\u003cSelf\u003e {\n        use std::collections::hash_map::DefaultHasher;\n        use std::fs;\n        use std::hash::{Hash, Hasher};\n        use std::io::ErrorKind;\n\n        let metadata = fs::metadata(path)?;\n\n        let content = match fs::read_to_string(path) {\n            Ok(content) =\u003e content,\n            Err(e) if e.kind() == ErrorKind::InvalidData =\u003e {\n                // Handle binary files gracefully\n                log::warn!(\"Skipping binary file in auto-diff mode: {}\", path.display());\n                format!(\"\u003cBinary file - {} bytes\u003e\", metadata.len())\n            }\n            Err(e) =\u003e return Err(e),\n        };\n\n        // Compute content hash\n        let mut hasher = DefaultHasher::new();\n        content.hash(\u0026mut hasher);\n        let content_hash = format!(\"{:x}\", hasher.finish());\n\n        Ok(FileState {\n            content,\n            size: metadata.len(),\n            modified: metadata.modified().unwrap_or(SystemTime::UNIX_EPOCH),\n            content_hash,\n        })\n    }\n}\n\nimpl ChangeSummary {\n    /// Check if there are any changes\n    pub fn has_changes(\u0026self) -\u003e bool {\n        self.total_changes \u003e 0\n    }\n\n    /// Generate markdown representation of the change summary\n    pub fn to_markdown(\u0026self) -\u003e String {\n        if !self.has_changes() {\n            return String::new();\n        }\n\n        let mut output = String::new();\n        output.push_str(\"## Change Summary\\n\\n\");\n\n        for path in \u0026self.added {\n            output.push_str(\u0026format!(\"- Added: `{}`\\n\", path.display()));\n        }\n\n        for path in \u0026self.removed {\n            output.push_str(\u0026format!(\"- Removed: `{}`\\n\", path.display()));\n        }\n\n        for path in \u0026self.modified {\n            output.push_str(\u0026format!(\"- Modified: `{}`\\n\", path.display()));\n        }\n\n        output.push('\\n');\n        output\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::fs;\n    use tempfile::tempdir;\n\n    #[test]\n    fn test_file_state_creation() {\n        let temp_dir = tempdir().unwrap();\n        let file_path = temp_dir.path().join(\"test.txt\");\n        fs::write(\u0026file_path, \"Hello, world!\").unwrap();\n\n        let file_state = FileState::from_path(\u0026file_path).unwrap();\n\n        assert_eq!(file_state.content, \"Hello, world!\");\n        assert_eq!(file_state.size, 13);\n        assert!(!file_state.content_hash.is_empty());\n    }\n\n    #[test]\n    fn test_project_state_comparison() {\n        let temp_dir = tempdir().unwrap();\n        let base_path = temp_dir.path();\n\n        // Create initial files\n        fs::write(base_path.join(\"file1.txt\"), \"content1\").unwrap();\n        fs::write(base_path.join(\"file2.txt\"), \"content2\").unwrap();\n\n        let mut state1_files = BTreeMap::new();\n        state1_files.insert(\n            PathBuf::from(\"file1.txt\"),\n            FileState::from_path(\u0026base_path.join(\"file1.txt\")).unwrap(),\n        );\n        state1_files.insert(\n            PathBuf::from(\"file2.txt\"),\n            FileState::from_path(\u0026base_path.join(\"file2.txt\")).unwrap(),\n        );\n\n        let state1 = ProjectState {\n            timestamp: \"2023-01-01T00:00:00Z\".to_string(),\n            config_hash: \"test_hash\".to_string(),\n            files: state1_files,\n            metadata: ProjectMetadata {\n                project_name: \"test\".to_string(),\n                file_count: 2,\n                filters: vec![],\n                ignores: vec![],\n                line_numbers: false,\n            },\n        };\n\n        // Modify and create new state\n        fs::write(base_path.join(\"file1.txt\"), \"modified_content1\").unwrap();\n        fs::write(base_path.join(\"file3.txt\"), \"content3\").unwrap();\n\n        let mut state2_files = BTreeMap::new();\n        state2_files.insert(\n            PathBuf::from(\"file1.txt\"),\n            FileState::from_path(\u0026base_path.join(\"file1.txt\")).unwrap(),\n        );\n        state2_files.insert(\n            PathBuf::from(\"file2.txt\"),\n            FileState::from_path(\u0026base_path.join(\"file2.txt\")).unwrap(),\n        );\n        state2_files.insert(\n            PathBuf::from(\"file3.txt\"),\n            FileState::from_path(\u0026base_path.join(\"file3.txt\")).unwrap(),\n        );\n\n        let state2 = ProjectState {\n            timestamp: \"2023-01-01T01:00:00Z\".to_string(),\n            config_hash: \"test_hash\".to_string(),\n            files: state2_files,\n            metadata: ProjectMetadata {\n                project_name: \"test\".to_string(),\n                file_count: 3,\n                filters: vec![],\n                ignores: vec![],\n                line_numbers: false,\n            },\n        };\n\n        let comparison = state2.compare_with(\u0026state1);\n\n        assert_eq!(comparison.summary.added.len(), 1);\n        assert_eq!(comparison.summary.modified.len(), 1);\n        assert_eq!(comparison.summary.removed.len(), 0);\n        assert!(\n            comparison\n                .summary\n                .added\n                .contains(\u0026PathBuf::from(\"file3.txt\"))\n        );\n        assert!(\n            comparison\n                .summary\n                .modified\n                .contains(\u0026PathBuf::from(\"file1.txt\"))\n        );\n    }\n\n    #[test]\n    fn test_change_summary_markdown() {\n        let summary = ChangeSummary {\n            added: vec![PathBuf::from(\"new.txt\")],\n            removed: vec![PathBuf::from(\"old.txt\")],\n            modified: vec![PathBuf::from(\"changed.txt\")],\n            total_changes: 3,\n        };\n\n        let markdown = summary.to_markdown();\n\n        assert!(markdown.contains(\"## Change Summary\"));\n        assert!(markdown.contains(\"- Added: `new.txt`\"));\n        assert!(markdown.contains(\"- Removed: `old.txt`\"));\n        assert!(markdown.contains(\"- Modified: `changed.txt`\"));\n    }\n\n    #[test]\n    fn test_binary_file_handling() {\n        let temp_dir = tempdir().unwrap();\n        let binary_file = temp_dir.path().join(\"test.bin\");\n\n        // Write binary data (non-UTF8)\n        let binary_data = vec![0u8, 255, 128, 42, 0, 1, 2, 3];\n        fs::write(\u0026binary_file, \u0026binary_data).unwrap();\n\n        // Should not crash and should handle gracefully\n        let file_state = FileState::from_path(\u0026binary_file).unwrap();\n\n        // Content should be a placeholder for binary files\n        assert!(file_state.content.contains(\"Binary file\"));\n        assert!(file_state.content.contains(\"8 bytes\"));\n        assert_eq!(file_state.size, 8);\n        assert!(!file_state.content_hash.is_empty());\n    }\n\n    #[test]\n    fn test_has_changes_identical_states() {\n        let temp_dir = tempdir().unwrap();\n        let base_path = temp_dir.path();\n        fs::write(base_path.join(\"test.txt\"), \"content\").unwrap();\n\n        let mut files = BTreeMap::new();\n        files.insert(\n            PathBuf::from(\"test.txt\"),\n            FileState::from_path(\u0026base_path.join(\"test.txt\")).unwrap(),\n        );\n\n        let state1 = ProjectState {\n            timestamp: \"2023-01-01T00:00:00Z\".to_string(),\n            config_hash: \"hash1\".to_string(),\n            files: files.clone(),\n            metadata: ProjectMetadata {\n                project_name: \"test\".to_string(),\n                file_count: 1,\n                filters: vec![],\n                ignores: vec![],\n                line_numbers: false,\n            },\n        };\n\n        let state2 = ProjectState {\n            timestamp: \"2023-01-01T01:00:00Z\".to_string(),\n            config_hash: \"hash1\".to_string(),\n            files,\n            metadata: ProjectMetadata {\n                project_name: \"test\".to_string(),\n                file_count: 1,\n                filters: vec![],\n                ignores: vec![],\n                line_numbers: false,\n            },\n        };\n\n        assert!(!state1.has_changes(\u0026state2));\n    }\n\n    #[test]\n    fn test_has_changes_different_file_count() {\n        let temp_dir = tempdir().unwrap();\n        let base_path = temp_dir.path();\n        fs::write(base_path.join(\"test1.txt\"), \"content1\").unwrap();\n        fs::write(base_path.join(\"test2.txt\"), \"content2\").unwrap();\n\n        let mut files1 = BTreeMap::new();\n        files1.insert(\n            PathBuf::from(\"test1.txt\"),\n            FileState::from_path(\u0026base_path.join(\"test1.txt\")).unwrap(),\n        );\n\n        let mut files2 = BTreeMap::new();\n        files2.insert(\n            PathBuf::from(\"test1.txt\"),\n            FileState::from_path(\u0026base_path.join(\"test1.txt\")).unwrap(),\n        );\n        files2.insert(\n            PathBuf::from(\"test2.txt\"),\n            FileState::from_path(\u0026base_path.join(\"test2.txt\")).unwrap(),\n        );\n\n        let state1 = ProjectState {\n            timestamp: \"2023-01-01T00:00:00Z\".to_string(),\n            config_hash: \"hash1\".to_string(),\n            files: files1,\n            metadata: ProjectMetadata {\n                project_name: \"test\".to_string(),\n                file_count: 1,\n                filters: vec![],\n                ignores: vec![],\n                line_numbers: false,\n            },\n        };\n\n        let state2 = ProjectState {\n            timestamp: \"2023-01-01T01:00:00Z\".to_string(),\n            config_hash: \"hash1\".to_string(),\n            files: files2,\n            metadata: ProjectMetadata {\n                project_name: \"test\".to_string(),\n                file_count: 2,\n                filters: vec![],\n                ignores: vec![],\n                line_numbers: false,\n            },\n        };\n\n        assert!(state1.has_changes(\u0026state2));\n    }\n\n    #[test]\n    fn test_has_changes_content_different() {\n        let temp_dir = tempdir().unwrap();\n        let base_path = temp_dir.path();\n        fs::write(base_path.join(\"test.txt\"), \"content1\").unwrap();\n\n        let file_state1 = FileState::from_path(\u0026base_path.join(\"test.txt\")).unwrap();\n\n        fs::write(base_path.join(\"test.txt\"), \"content2\").unwrap();\n        let file_state2 = FileState::from_path(\u0026base_path.join(\"test.txt\")).unwrap();\n\n        let mut files1 = BTreeMap::new();\n        files1.insert(PathBuf::from(\"test.txt\"), file_state1);\n\n        let mut files2 = BTreeMap::new();\n        files2.insert(PathBuf::from(\"test.txt\"), file_state2);\n\n        let state1 = ProjectState {\n            timestamp: \"2023-01-01T00:00:00Z\".to_string(),\n            config_hash: \"hash1\".to_string(),\n            files: files1,\n            metadata: ProjectMetadata {\n                project_name: \"test\".to_string(),\n                file_count: 1,\n                filters: vec![],\n                ignores: vec![],\n                line_numbers: false,\n            },\n        };\n\n        let state2 = ProjectState {\n            timestamp: \"2023-01-01T01:00:00Z\".to_string(),\n            config_hash: \"hash1\".to_string(),\n            files: files2,\n            metadata: ProjectMetadata {\n                project_name: \"test\".to_string(),\n                file_count: 1,\n                filters: vec![],\n                ignores: vec![],\n                line_numbers: false,\n            },\n        };\n\n        assert!(state1.has_changes(\u0026state2));\n    }\n\n    #[test]\n    fn test_config_hash_generation() {\n        let config1 = Config {\n            filter: Some(vec![\"rs\".to_string()]),\n            ignore: Some(vec![\"target\".to_string()]),\n            line_numbers: Some(true),\n            auto_diff: Some(false),\n            diff_context_lines: Some(3),\n            ..Default::default()\n        };\n\n        let config2 = Config {\n            filter: Some(vec![\"rs\".to_string()]),\n            ignore: Some(vec![\"target\".to_string()]),\n            line_numbers: Some(true),\n            auto_diff: Some(false),\n            diff_context_lines: Some(3),\n            ..Default::default()\n        };\n\n        let config3 = Config {\n            filter: Some(vec![\"py\".to_string()]), // Different filter\n            ignore: Some(vec![\"target\".to_string()]),\n            line_numbers: Some(true),\n            auto_diff: Some(false),\n            diff_context_lines: Some(3),\n            ..Default::default()\n        };\n\n        let hash1 = ProjectState::compute_config_hash(\u0026config1);\n        let hash2 = ProjectState::compute_config_hash(\u0026config2);\n        let hash3 = ProjectState::compute_config_hash(\u0026config3);\n\n        assert_eq!(hash1, hash2);\n        assert_ne!(hash1, hash3);\n    }\n\n    #[test]\n    fn test_change_summary_no_changes() {\n        let summary = ChangeSummary {\n            added: vec![],\n            removed: vec![],\n            modified: vec![],\n            total_changes: 0,\n        };\n\n        assert!(!summary.has_changes());\n        assert_eq!(summary.to_markdown(), \"\");\n    }\n\n    #[test]\n    fn test_from_files_with_config() {\n        let temp_dir = tempdir().unwrap();\n        let base_path = temp_dir.path();\n\n        fs::write(base_path.join(\"test.rs\"), \"fn main() {}\").unwrap();\n        fs::write(base_path.join(\"README.md\"), \"# Test\").unwrap();\n\n        let entries = vec![\n            create_mock_dir_entry(\u0026base_path.join(\"test.rs\")),\n            create_mock_dir_entry(\u0026base_path.join(\"README.md\")),\n        ];\n\n        let config = Config {\n            filter: Some(vec![\"rs\".to_string()]),\n            ignore: Some(vec![\"target\".to_string()]),\n            line_numbers: Some(true),\n            ..Default::default()\n        };\n\n        let state = ProjectState::from_files(\u0026entries, base_path, \u0026config, true).unwrap();\n\n        assert_eq!(state.files.len(), 2);\n        assert_eq!(state.metadata.file_count, 2);\n        assert_eq!(state.metadata.filters, vec![\"rs\"]);\n        assert_eq!(state.metadata.ignores, vec![\"target\"]);\n        assert!(state.metadata.line_numbers);\n        assert!(!state.timestamp.is_empty());\n        assert!(!state.config_hash.is_empty());\n    }\n\n    #[test]\n    fn test_from_files_absolute_path_fallback() {\n        let temp_dir = tempdir().unwrap();\n        let base_path = temp_dir.path();\n\n        // Create a file in the temp dir\n        fs::write(base_path.join(\"test.txt\"), \"test content\").unwrap();\n        let file_path = base_path.join(\"test.txt\");\n\n        // Create entry with the file\n        let entry = create_mock_dir_entry(\u0026file_path);\n\n        // Use a completely different base_path to force the fallback\n        let different_base = PathBuf::from(\"/completely/different/path\");\n\n        let config = Config::default();\n\n        let state = ProjectState::from_files(\u0026[entry], \u0026different_base, \u0026config, false).unwrap();\n\n        // Should fall back to just the filename\n        assert_eq!(state.files.len(), 1);\n        assert!(state.files.contains_key(\u0026PathBuf::from(\"test.txt\")));\n    }\n\n    #[test]\n    fn test_change_summary_with_unchanged_files() {\n        let changes = vec![\n            PerFileDiff {\n                path: \"added.txt\".to_string(),\n                status: PerFileStatus::Added,\n                diff: \"diff content\".to_string(),\n            },\n            PerFileDiff {\n                path: \"unchanged.txt\".to_string(),\n                status: PerFileStatus::Unchanged,\n                diff: \"\".to_string(),\n            },\n        ];\n\n        // Manually create the summary like the actual code does\n        let mut added = Vec::new();\n        let mut removed = Vec::new();\n        let mut modified = Vec::new();\n\n        for diff in \u0026changes {\n            let path = PathBuf::from(\u0026diff.path);\n            match diff.status {\n                PerFileStatus::Added =\u003e added.push(path),\n                PerFileStatus::Removed =\u003e removed.push(path),\n                PerFileStatus::Modified =\u003e modified.push(path),\n                PerFileStatus::Unchanged =\u003e {} // This line should be covered now\n            }\n        }\n\n        let summary = ChangeSummary {\n            total_changes: added.len() + removed.len() + modified.len(),\n            added,\n            removed,\n            modified,\n        };\n\n        assert_eq!(summary.total_changes, 1); // Only the added file counts\n        assert_eq!(summary.added.len(), 1);\n        assert_eq!(summary.removed.len(), 0);\n        assert_eq!(summary.modified.len(), 0);\n    }\n\n    #[test]\n    fn test_has_changes_with_missing_file() {\n        let temp_dir = tempdir().unwrap();\n        let base_path = temp_dir.path();\n\n        // Create files for the first state\n        fs::write(base_path.join(\"file1.txt\"), \"content1\").unwrap();\n        let entry1 = create_mock_dir_entry(\u0026base_path.join(\"file1.txt\"));\n\n        let config = Config::default();\n        let state1 = ProjectState::from_files(\u0026[entry1], base_path, \u0026config, false).unwrap();\n\n        // Create a different state with different files\n        fs::write(base_path.join(\"file2.txt\"), \"content2\").unwrap();\n        let entry2 = create_mock_dir_entry(\u0026base_path.join(\"file2.txt\"));\n        let state2 = ProjectState::from_files(\u0026[entry2], base_path, \u0026config, false).unwrap();\n\n        // Should detect changes because files are completely different\n        assert!(state1.has_changes(\u0026state2));\n    }\n\n    #[test]\n    fn test_file_state_with_invalid_data_error() {\n        // Create a temporary file with binary content that might trigger InvalidData\n        let temp_dir = tempdir().unwrap();\n        let binary_file = temp_dir.path().join(\"binary.dat\");\n\n        // Write invalid UTF-8 bytes\n        let binary_data = vec![0xFF, 0xFE, 0xFD, 0xFC, 0xFB, 0xFA];\n        fs::write(\u0026binary_file, \u0026binary_data).unwrap();\n\n        // This might trigger the InvalidData error path, but since we can't guarantee it,\n        // we at least verify the function can handle binary files\n        let result = FileState::from_path(\u0026binary_file);\n        assert!(result.is_ok());\n    }\n\n    // Helper function to create a mock DirEntry for testing\n    fn create_mock_dir_entry(path: \u0026std::path::Path) -\u003e ignore::DirEntry {\n        // This is a bit of a hack since DirEntry doesn't have a public constructor\n        // We use the ignore crate's WalkBuilder to create a real DirEntry\n        let walker = ignore::WalkBuilder::new(path.parent().unwrap());\n        walker\n            .build()\n            .filter_map(Result::ok)\n            .find(|entry| entry.path() == path)\n            .expect(\"Failed to create DirEntry for test\")\n    }\n}\n","traces":[{"line":82,"address":[],"length":0,"stats":{"Line":4611686018427387904}},{"line":88,"address":[],"length":0,"stats":{"Line":9223372036854775808}},{"line":93,"address":[],"length":0,"stats":{"Line":13835058055282163712}},{"line":94,"address":[],"length":0,"stats":{"Line":8791026472627208192}},{"line":95,"address":[],"length":0,"stats":{"Line":15492382718154506240}},{"line":97,"address":[],"length":0,"stats":{"Line":4179340454199820288}},{"line":99,"address":[],"length":0,"stats":{"Line":4179340454199820288}},{"line":100,"address":[],"length":0,"stats":{"Line":11529215046068469760}},{"line":101,"address":[],"length":0,"stats":{"Line":15348267530078650368}},{"line":102,"address":[],"length":0,"stats":{"Line":11385099857992613888}},{"line":104,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":105,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":106,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":107,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":110,"address":[],"length":0,"stats":{"Line":15492382718154506240}},{"line":114,"address":[],"length":0,"stats":{"Line":4611686018427387904}},{"line":116,"address":[],"length":0,"stats":{"Line":4611686018427387904}},{"line":137,"address":[],"length":0,"stats":{"Line":1657324662872342528}},{"line":139,"address":[],"length":0,"stats":{"Line":4971973988617027584}},{"line":140,"address":[],"length":0,"stats":{"Line":1657324662872342528}},{"line":142,"address":[],"length":0,"stats":{"Line":17798225727368200192}},{"line":145,"address":[],"length":0,"stats":{"Line":4971973988617027584}},{"line":146,"address":[],"length":0,"stats":{"Line":1657324662872342528}},{"line":148,"address":[],"length":0,"stats":{"Line":2522015791327477760}},{"line":152,"address":[],"length":0,"stats":{"Line":8286623314361712640}},{"line":155,"address":[],"length":0,"stats":{"Line":3314649325744685056}},{"line":156,"address":[],"length":0,"stats":{"Line":3314649325744685056}},{"line":157,"address":[],"length":0,"stats":{"Line":3314649325744685056}},{"line":159,"address":[],"length":0,"stats":{"Line":5692549928996306944}},{"line":162,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":163,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":164,"address":[],"length":0,"stats":{"Line":2810246167479189504}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":8286623314361712640}},{"line":183,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":184,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":185,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":188,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":189,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":190,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":191,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":192,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":195,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":199,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":203,"address":[],"length":0,"stats":{"Line":4827858800541171712}},{"line":207,"address":[],"length":0,"stats":{"Line":9655717601082343424}},{"line":208,"address":[],"length":0,"stats":{"Line":14483576401623515136}},{"line":209,"address":[],"length":0,"stats":{"Line":14483576401623515136}},{"line":210,"address":[],"length":0,"stats":{"Line":14483576401623515136}},{"line":211,"address":[],"length":0,"stats":{"Line":14483576401623515136}},{"line":212,"address":[],"length":0,"stats":{"Line":14483576401623515136}},{"line":214,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":220,"address":[],"length":0,"stats":{"Line":12321848580485677056}},{"line":226,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":228,"address":[],"length":0,"stats":{"Line":12321848580485677056}},{"line":229,"address":[],"length":0,"stats":{"Line":10160120759347838976}},{"line":230,"address":[],"length":0,"stats":{"Line":6485183463413514240}},{"line":232,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":233,"address":[],"length":0,"stats":{"Line":8646911284551352320}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":4539628424389459968}},{"line":255,"address":[],"length":0,"stats":{"Line":4539628424389459968}},{"line":259,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":260,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":261,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":264,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":265,"address":[],"length":0,"stats":{"Line":3674937295934324736}},{"line":267,"address":[],"length":0,"stats":{"Line":3098476543630901248}},{"line":271,"address":[],"length":0,"stats":{"Line":1657324662872342528}},{"line":275,"address":[],"length":0,"stats":{"Line":3098476543630901248}},{"line":279,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":280,"address":[],"length":0,"stats":{"Line":1224979098644774912}}],"covered":70,"coverable":72},{"path":["D:","\\","GitHub","context-builder","src","token_count.rs"],"content":"use ignore::DirEntry;\nuse once_cell::sync::Lazy;\nuse std::collections::BTreeMap;\nuse std::fs;\nuse std::path::Path;\n/// Token counting utilities for estimating LLM token usage\nuse tiktoken_rs::{CoreBPE, cl100k_base};\n\n// Initialize the tokenizer once and reuse it\nstatic TOKENIZER: Lazy\u003cCoreBPE\u003e = Lazy::new(|| cl100k_base().unwrap());\n\n/// Estimates the number of tokens in a text string using a real tokenizer\npub fn estimate_tokens(text: \u0026str) -\u003e usize {\n    TOKENIZER.encode_with_special_tokens(text).len()\n}\n\n/// Counts the tokens that would be generated for a file\npub fn count_file_tokens(base_path: \u0026Path, entry: \u0026DirEntry, line_numbers: bool) -\u003e usize {\n    let file_path = entry.path();\n    let relative_path = file_path.strip_prefix(base_path).unwrap_or(file_path);\n\n    // Start with tokens for the file header (path, size, modified time)\n    let mut token_count = estimate_tokens(\u0026format!(\n        \"\\n### File: `{}`\\n\\n- Size: {} bytes\\n- Modified: {}\\n\\n\",\n        relative_path.display(),\n        entry.metadata().map(|m| m.len()).unwrap_or(0),\n        \"Unknown\"\n    )); // Using \"Unknown\" as placeholder for modified time in estimation\n\n    // Add tokens for the code fences\n    token_count += estimate_tokens(\"```\\n```\");\n\n    // Try to read file content\n    if let Ok(content) = fs::read_to_string(file_path) {\n        if line_numbers {\n            // When line numbers are enabled, we add the line number prefix to each line\n            let lines_with_numbers: String = content\n                .lines()\n                .enumerate()\n                .map(|(i, line)| format!(\"{:\u003e4} | {}\\n\", i + 1, line))\n                .collect();\n            token_count += estimate_tokens(\u0026lines_with_numbers);\n        } else {\n            token_count += estimate_tokens(\u0026content);\n        }\n    }\n\n    token_count\n}\n\n/// Counts the tokens that would be generated for the entire file tree section\npub fn count_tree_tokens(tree: \u0026BTreeMap\u003cString, crate::tree::FileNode\u003e, depth: usize) -\u003e usize {\n    let mut token_count = 0;\n\n    // Add tokens for indentation\n    let indent = \"  \".repeat(depth);\n\n    for (name, node) in tree {\n        match node {\n            crate::tree::FileNode::File =\u003e {\n                token_count += estimate_tokens(\u0026format!(\"{}- 📄 {}\\n\", indent, name));\n            }\n            crate::tree::FileNode::Directory(children) =\u003e {\n                token_count += estimate_tokens(\u0026format!(\"{}- 📁 {}\\n\", indent, name));\n                token_count += count_tree_tokens(children, depth + 1);\n            }\n        }\n    }\n\n    token_count\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::BTreeMap;\n\n    #[test]\n    fn test_estimate_tokens() {\n        // Test with a simple string\n        let text = \"Hello, world!\";\n        let tokens = estimate_tokens(text);\n        // \"Hello, world!\" is 4 tokens with cl100k_base\n        assert_eq!(tokens, 4);\n\n        // Test with code-like content\n        let code_text = \"fn main() {\\n    println!(\\\"Hello, world!\\\");\\n}\";\n        let tokens = estimate_tokens(code_text);\n        // This specific code snippet is 12 tokens with cl100k_base\n        assert_eq!(tokens, 12);\n    }\n\n    #[test]\n    fn test_count_tree_tokens() {\n        // Create a simple tree structure\n        let mut tree = BTreeMap::new();\n        tree.insert(\"file1.rs\".to_string(), crate::tree::FileNode::File);\n\n        let mut subdir = BTreeMap::new();\n        subdir.insert(\"file2.md\".to_string(), crate::tree::FileNode::File);\n        tree.insert(\"src\".to_string(), crate::tree::FileNode::Directory(subdir));\n\n        let tokens = count_tree_tokens(\u0026tree, 0);\n        // \"- 📄 file1.rs\\n\" -\u003e 8 tokens\n        // \"- 📁 src\\n\" -\u003e 6 tokens\n        // \"  - 📄 file2.md\\n\" -\u003e 9 tokens\n        // Total should be 23 tokens\n        assert_eq!(tokens, 23);\n    }\n\n    #[test]\n    fn test_token_estimation_format_consistency() {\n        use tempfile::tempdir;\n\n        let dir = tempdir().unwrap();\n        let test_file = dir.path().join(\"test.rs\");\n        std::fs::write(\u0026test_file, \"fn main() {}\\n\").unwrap();\n\n        let entry = ignore::WalkBuilder::new(\u0026test_file)\n            .build()\n            .next()\n            .unwrap()\n            .unwrap();\n\n        // Estimate tokens for the file\n        let estimated_tokens = count_file_tokens(dir.path(), \u0026entry, false);\n\n        // Generate actual markdown content\n        let mut actual_content = Vec::new();\n        crate::markdown::process_file(dir.path(), \u0026test_file, \u0026mut actual_content, false, None)\n            .unwrap();\n        let actual_content_str = String::from_utf8(actual_content).unwrap();\n\n        // Count actual tokens\n        let actual_tokens = estimate_tokens(\u0026actual_content_str);\n\n        // The estimation should be close to actual (within a reasonable margin)\n        // Allow for some variance due to timestamp differences and minor formatting\n        let difference = actual_tokens.abs_diff(estimated_tokens);\n\n        // Should be within 10% or 20 tokens difference (whichever is larger)\n        let max_allowed_difference = std::cmp::max(actual_tokens / 10, 20);\n\n        assert!(\n            difference \u003c= max_allowed_difference,\n            \"Token estimation {} differs too much from actual {} (difference: {})\",\n            estimated_tokens,\n            actual_tokens,\n            difference\n        );\n    }\n\n    #[test]\n    fn test_estimate_tokens_empty_string() {\n        let tokens = estimate_tokens(\"\");\n        assert_eq!(tokens, 0);\n    }\n\n    #[test]\n    fn test_estimate_tokens_whitespace_only() {\n        let tokens = estimate_tokens(\"   \\n\\t  \");\n        assert!(tokens \u003e 0); // Whitespace still counts as tokens\n    }\n\n    #[test]\n    fn test_estimate_tokens_unicode() {\n        let tokens = estimate_tokens(\"Hello 世界! 🌍\");\n        assert!(tokens \u003e 0);\n        // Unicode characters may be encoded as multiple tokens\n        assert!(tokens \u003e= 4);\n    }\n\n    #[test]\n    fn test_count_file_tokens_with_line_numbers() {\n        use tempfile::tempdir;\n\n        let dir = tempdir().unwrap();\n        let test_file = dir.path().join(\"test.rs\");\n        std::fs::write(\u0026test_file, \"line 1\\nline 2\\nline 3\").unwrap();\n\n        let entry = ignore::WalkBuilder::new(\u0026test_file)\n            .build()\n            .next()\n            .unwrap()\n            .unwrap();\n\n        let tokens_without_line_numbers = count_file_tokens(dir.path(), \u0026entry, false);\n        let tokens_with_line_numbers = count_file_tokens(dir.path(), \u0026entry, true);\n\n        // With line numbers should have more tokens due to line number prefixes\n        assert!(tokens_with_line_numbers \u003e tokens_without_line_numbers);\n    }\n\n    #[test]\n    fn test_count_file_tokens_unreadable_file() {\n        use tempfile::tempdir;\n\n        let dir = tempdir().unwrap();\n        let test_file = dir.path().join(\"nonexistent.txt\");\n\n        // Create a mock DirEntry for a file that doesn't exist\n        // This simulates what happens when a file is deleted between discovery and processing\n        let walker = ignore::WalkBuilder::new(dir.path());\n        let mut found_entry = None;\n\n        // Create the file temporarily to get a DirEntry\n        std::fs::write(\u0026test_file, \"temp\").unwrap();\n        for entry in walker.build() {\n            if let Ok(entry) = entry\n                \u0026\u0026 entry.path() == test_file\n            {\n                found_entry = Some(entry);\n                break;\n            }\n        }\n\n        // Now delete the file\n        std::fs::remove_file(\u0026test_file).unwrap();\n\n        if let Some(entry) = found_entry {\n            let tokens = count_file_tokens(dir.path(), \u0026entry, false);\n            // Should still return some tokens for the file header even if content can't be read\n            assert!(tokens \u003e 0);\n        }\n    }\n\n    #[test]\n    fn test_count_tree_tokens_empty_tree() {\n        let tree = BTreeMap::new();\n        let tokens = count_tree_tokens(\u0026tree, 0);\n        assert_eq!(tokens, 0);\n    }\n\n    #[test]\n    fn test_count_tree_tokens_nested_directories() {\n        let mut tree = BTreeMap::new();\n\n        // Create deeply nested structure\n        let mut level3 = BTreeMap::new();\n        level3.insert(\"deep_file.txt\".to_string(), crate::tree::FileNode::File);\n\n        let mut level2 = BTreeMap::new();\n        level2.insert(\n            \"level3\".to_string(),\n            crate::tree::FileNode::Directory(level3),\n        );\n\n        let mut level1 = BTreeMap::new();\n        level1.insert(\n            \"level2\".to_string(),\n            crate::tree::FileNode::Directory(level2),\n        );\n\n        tree.insert(\n            \"level1\".to_string(),\n            crate::tree::FileNode::Directory(level1),\n        );\n\n        let tokens = count_tree_tokens(\u0026tree, 0);\n        assert!(tokens \u003e 0);\n\n        // Should account for indentation at different levels\n        let tokens_with_depth = count_tree_tokens(\u0026tree, 2);\n        assert!(tokens_with_depth \u003e tokens); // More indentation = more tokens\n    }\n\n    #[test]\n    fn test_count_tree_tokens_mixed_content() {\n        let mut tree = BTreeMap::new();\n\n        // Add files with various name lengths and characters\n        tree.insert(\"a.txt\".to_string(), crate::tree::FileNode::File);\n        tree.insert(\n            \"very_long_filename_with_underscores.rs\".to_string(),\n            crate::tree::FileNode::File,\n        );\n        tree.insert(\"файл.txt\".to_string(), crate::tree::FileNode::File); // Unicode filename\n\n        let mut subdir = BTreeMap::new();\n        subdir.insert(\"nested.md\".to_string(), crate::tree::FileNode::File);\n        tree.insert(\n            \"directory\".to_string(),\n            crate::tree::FileNode::Directory(subdir),\n        );\n\n        let tokens = count_tree_tokens(\u0026tree, 0);\n        assert!(tokens \u003e 0);\n\n        // Verify it handles unicode filenames without crashing\n        assert!(tokens \u003e 20); // Should be substantial given the content\n    }\n}\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":13,"address":[],"length":0,"stats":{"Line":8574853690513424384}},{"line":14,"address":[],"length":0,"stats":{"Line":7277816997830721536}},{"line":18,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":19,"address":[],"length":0,"stats":{"Line":3891110078048108544}},{"line":20,"address":[],"length":0,"stats":{"Line":7782220156096217088}},{"line":23,"address":[],"length":0,"stats":{"Line":3891110078048108544}},{"line":24,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":25,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":26,"address":[],"length":0,"stats":{"Line":7782220156096217088}},{"line":31,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":34,"address":[],"length":0,"stats":{"Line":2522015791327477760}},{"line":37,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":40,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":42,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":44,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":48,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":52,"address":[],"length":0,"stats":{"Line":1801439850948198400}},{"line":53,"address":[],"length":0,"stats":{"Line":3602879701896396800}},{"line":56,"address":[],"length":0,"stats":{"Line":7205759403792793600}},{"line":58,"address":[],"length":0,"stats":{"Line":6989586621679009792}},{"line":60,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":61,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":63,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":64,"address":[],"length":0,"stats":{"Line":3026418949592973312}},{"line":65,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":70,"address":[],"length":0,"stats":{"Line":1801439850948198400}}],"covered":27,"coverable":27},{"path":["D:","\\","GitHub","context-builder","src","tree.rs"],"content":"use ignore::DirEntry;\r\nuse std::collections::BTreeMap;\r\nuse std::io::{self, Write};\r\nuse std::path::Path;\r\n\r\n/// A nested map to represent the file tree structure.\r\n#[derive(Debug, Clone, PartialEq)]\r\npub enum FileNode {\r\n    File,\r\n    Directory(BTreeMap\u003cString, FileNode\u003e),\r\n}\r\n\r\n/// Type alias for the file tree structure.\r\npub type FileTree = BTreeMap\u003cString, FileNode\u003e;\r\n\r\n/// Builds a nested BTreeMap representing the file structure.\r\npub fn build_file_tree(files: \u0026[DirEntry], base_path: \u0026Path) -\u003e FileTree {\r\n    let mut tree = BTreeMap::new();\r\n    for entry in files {\r\n        let path = entry\r\n            .path()\r\n            .strip_prefix(base_path)\r\n            .unwrap_or_else(|_| entry.path());\r\n        let components: Vec\u003c_\u003e = path.components().collect();\r\n\r\n        // Insert this path into the tree\r\n        insert_path(\u0026mut tree, \u0026components);\r\n    }\r\n    tree\r\n}\r\n\r\n/// Helper function to insert a path into the tree structure\r\nfn insert_path(tree: \u0026mut FileTree, components: \u0026[std::path::Component]) {\r\n    if components.is_empty() {\r\n        return;\r\n    }\r\n\r\n    let name = components[0].as_os_str().to_string_lossy().to_string();\r\n\r\n    if components.len() == 1 {\r\n        // This is the last component, so it's a file\r\n        tree.insert(name, FileNode::File);\r\n    } else {\r\n        // This is a directory component\r\n        // Make sure the directory exists\r\n        tree.entry(name.clone())\r\n            .or_insert_with(|| FileNode::Directory(BTreeMap::new()));\r\n\r\n        // Recursively insert the rest of the path\r\n        if let Some(FileNode::Directory(next_dir)) = tree.get_mut(\u0026name) {\r\n            insert_path(next_dir, \u0026components[1..]);\r\n        }\r\n    }\r\n}\r\n\r\n/// Recursively prints the file tree to the console.\r\npub fn print_tree(tree: \u0026FileTree, depth: usize) {\r\n    for (name, node) in tree {\r\n        let indent = \"  \".repeat(depth);\r\n        match node {\r\n            FileNode::File =\u003e {\r\n                println!(\"{}- 📄 {}\", indent, name);\r\n            }\r\n            FileNode::Directory(children) =\u003e {\r\n                println!(\"{}- 📁 {}\", indent, name);\r\n                print_tree(children, depth + 1);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/// Recursively writes the file tree to a file.\r\npub fn write_tree_to_file(\r\n    output: \u0026mut impl Write,\r\n    tree: \u0026FileTree,\r\n    depth: usize,\r\n) -\u003e io::Result\u003c()\u003e {\r\n    for (name, node) in tree {\r\n        let indent = \"  \".repeat(depth);\r\n        match node {\r\n            FileNode::File =\u003e {\r\n                writeln!(output, \"{}- 📄 {}\", indent, name)?;\r\n            }\r\n            FileNode::Directory(children) =\u003e {\r\n                writeln!(output, \"{}- 📁 {}\", indent, name)?;\r\n                write_tree_to_file(output, children, depth + 1)?;\r\n            }\r\n        }\r\n    }\r\n    Ok(())\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n    use crate::file_utils::collect_files;\r\n    use std::fs;\r\n    use tempfile::tempdir;\r\n\r\n    #[test]\r\n    fn test_build_file_tree_with_collected_files() {\r\n        // 1. Set up a temporary directory with a file structure\r\n        let dir = tempdir().unwrap();\r\n        let base_path = dir.path();\r\n\r\n        fs::create_dir(base_path.join(\"src\")).unwrap();\r\n        fs::File::create(base_path.join(\"src/main.rs\")).unwrap();\r\n        fs::File::create(base_path.join(\"README.md\")).unwrap();\r\n        // Add a hidden file that should be ignored by default\r\n        fs::File::create(base_path.join(\".env\")).unwrap();\r\n\r\n        // 2. Collect files using the actual function\r\n        let files = collect_files(base_path, \u0026[], \u0026[]).unwrap();\r\n\r\n        // 3. Assert that the correct files were collected (a hidden file is ignored)\r\n        assert_eq!(files.len(), 2);\r\n\r\n        // 4. Build the tree with the collected files\r\n        let tree = build_file_tree(\u0026files, base_path);\r\n\r\n        // 5. Assert the tree structure is correct\r\n        let mut expected: FileTree = BTreeMap::new();\r\n        let mut src_tree = BTreeMap::new();\r\n        src_tree.insert(\"main.rs\".to_string(), FileNode::File);\r\n        expected.insert(\"src\".to_string(), FileNode::Directory(src_tree));\r\n        expected.insert(\"README.md\".to_string(), FileNode::File);\r\n\r\n        assert_eq!(tree, expected);\r\n    }\r\n\r\n    #[test]\r\n    fn test_build_file_tree_empty() {\r\n        let dir = tempdir().unwrap();\r\n        let base_path = dir.path();\r\n\r\n        let files = collect_files(base_path, \u0026[], \u0026[]).unwrap();\r\n        let tree = build_file_tree(\u0026files, base_path);\r\n\r\n        assert!(tree.is_empty());\r\n    }\r\n\r\n    #[test]\r\n    fn test_build_file_tree_single_file() {\r\n        let dir = tempdir().unwrap();\r\n        let base_path = dir.path();\r\n\r\n        fs::File::create(base_path.join(\"single.txt\")).unwrap();\r\n\r\n        let files = collect_files(base_path, \u0026[], \u0026[]).unwrap();\r\n        let tree = build_file_tree(\u0026files, base_path);\r\n\r\n        let mut expected: FileTree = BTreeMap::new();\r\n        expected.insert(\"single.txt\".to_string(), FileNode::File);\r\n\r\n        assert_eq!(tree, expected);\r\n    }\r\n\r\n    #[test]\r\n    fn test_build_file_tree_nested_directories() {\r\n        let dir = tempdir().unwrap();\r\n        let base_path = dir.path();\r\n\r\n        fs::create_dir_all(base_path.join(\"a/b/c\")).unwrap();\r\n        fs::File::create(base_path.join(\"a/b/c/deep.txt\")).unwrap();\r\n        fs::File::create(base_path.join(\"a/shallow.txt\")).unwrap();\r\n\r\n        let files = collect_files(base_path, \u0026[], \u0026[]).unwrap();\r\n        let tree = build_file_tree(\u0026files, base_path);\r\n\r\n        // Build expected structure\r\n        let mut c_tree = BTreeMap::new();\r\n        c_tree.insert(\"deep.txt\".to_string(), FileNode::File);\r\n\r\n        let mut b_tree = BTreeMap::new();\r\n        b_tree.insert(\"c\".to_string(), FileNode::Directory(c_tree));\r\n\r\n        let mut a_tree = BTreeMap::new();\r\n        a_tree.insert(\"b\".to_string(), FileNode::Directory(b_tree));\r\n        a_tree.insert(\"shallow.txt\".to_string(), FileNode::File);\r\n\r\n        let mut expected: FileTree = BTreeMap::new();\r\n        expected.insert(\"a\".to_string(), FileNode::Directory(a_tree));\r\n\r\n        assert_eq!(tree, expected);\r\n    }\r\n\r\n    #[test]\r\n    fn test_build_file_tree_unicode_filenames() {\r\n        let dir = tempdir().unwrap();\r\n        let base_path = dir.path();\r\n\r\n        fs::create_dir(base_path.join(\"测试目录\")).unwrap();\r\n        fs::File::create(base_path.join(\"测试目录/文件.txt\")).unwrap();\r\n        fs::File::create(base_path.join(\"🦀.rs\")).unwrap();\r\n\r\n        let files = collect_files(base_path, \u0026[], \u0026[]).unwrap();\r\n        let tree = build_file_tree(\u0026files, base_path);\r\n\r\n        let mut test_dir = BTreeMap::new();\r\n        test_dir.insert(\"文件.txt\".to_string(), FileNode::File);\r\n\r\n        let mut expected: FileTree = BTreeMap::new();\r\n        expected.insert(\"测试目录\".to_string(), FileNode::Directory(test_dir));\r\n        expected.insert(\"🦀.rs\".to_string(), FileNode::File);\r\n\r\n        assert_eq!(tree, expected);\r\n    }\r\n\r\n    #[test]\r\n    fn test_insert_path_empty_components() {\r\n        let mut tree = BTreeMap::new();\r\n        insert_path(\u0026mut tree, \u0026[]);\r\n        assert!(tree.is_empty());\r\n    }\r\n\r\n    #[test]\r\n    fn test_write_tree_to_file() {\r\n        let mut tree = BTreeMap::new();\r\n        tree.insert(\"file1.txt\".to_string(), FileNode::File);\r\n\r\n        let mut subdir = BTreeMap::new();\r\n        subdir.insert(\"file2.md\".to_string(), FileNode::File);\r\n        tree.insert(\"src\".to_string(), FileNode::Directory(subdir));\r\n\r\n        let mut output = Vec::new();\r\n        write_tree_to_file(\u0026mut output, \u0026tree, 0).unwrap();\r\n\r\n        let result = String::from_utf8(output).unwrap();\r\n        assert!(result.contains(\"- 📄 file1.txt\"));\r\n        assert!(result.contains(\"- 📁 src\"));\r\n        assert!(result.contains(\"  - 📄 file2.md\"));\r\n    }\r\n\r\n    #[test]\r\n    fn test_write_tree_to_file_with_depth() {\r\n        let mut tree = BTreeMap::new();\r\n        tree.insert(\"nested.txt\".to_string(), FileNode::File);\r\n\r\n        let mut output = Vec::new();\r\n        write_tree_to_file(\u0026mut output, \u0026tree, 2).unwrap();\r\n\r\n        let result = String::from_utf8(output).unwrap();\r\n        assert!(result.contains(\"    - 📄 nested.txt\")); // 2 levels of indentation\r\n    }\r\n\r\n    #[test]\r\n    fn test_write_tree_to_file_empty_tree() {\r\n        let tree = BTreeMap::new();\r\n        let mut output = Vec::new();\r\n        write_tree_to_file(\u0026mut output, \u0026tree, 0).unwrap();\r\n\r\n        let result = String::from_utf8(output).unwrap();\r\n        assert!(result.is_empty());\r\n    }\r\n\r\n    #[test]\r\n    fn test_file_node_equality() {\r\n        let file1 = FileNode::File;\r\n        let file2 = FileNode::File;\r\n        assert_eq!(file1, file2);\r\n\r\n        let mut dir1 = BTreeMap::new();\r\n        dir1.insert(\"test.txt\".to_string(), FileNode::File);\r\n        let node1 = FileNode::Directory(dir1.clone());\r\n        let node2 = FileNode::Directory(dir1);\r\n        assert_eq!(node1, node2);\r\n\r\n        // Different directories should not be equal\r\n        let mut dir2 = BTreeMap::new();\r\n        dir2.insert(\"other.txt\".to_string(), FileNode::File);\r\n        let node3 = FileNode::Directory(dir2);\r\n        assert_ne!(node1, node3);\r\n\r\n        // File and directory should not be equal\r\n        assert_ne!(file1, node1);\r\n    }\r\n\r\n    #[test]\r\n    fn test_build_file_tree_absolute_path_fallback() {\r\n        // Test the fallback case when strip_prefix fails by using different base paths\r\n        let dir = tempdir().unwrap();\r\n        let base_path = dir.path();\r\n        let other_dir = tempdir().unwrap();\r\n        let other_base = other_dir.path();\r\n\r\n        // Create a file in the first directory\r\n        fs::File::create(base_path.join(\"test.txt\")).unwrap();\r\n\r\n        // Create a DirEntry from the first directory but use a different base_path\r\n        let files = collect_files(base_path, \u0026[], \u0026[]).unwrap();\r\n\r\n        // This should trigger the unwrap_or_else case since other_base is unrelated to the file path\r\n        let tree = build_file_tree(\u0026files, other_base);\r\n\r\n        // The tree should still contain the file, but with its full path\r\n        assert!(!tree.is_empty());\r\n    }\r\n\r\n    #[test]\r\n    fn test_build_file_tree_multiple_files_same_directory() {\r\n        let dir = tempdir().unwrap();\r\n        let base_path = dir.path();\r\n\r\n        fs::create_dir(base_path.join(\"docs\")).unwrap();\r\n        fs::File::create(base_path.join(\"docs/readme.md\")).unwrap();\r\n        fs::File::create(base_path.join(\"docs/guide.md\")).unwrap();\r\n        fs::File::create(base_path.join(\"docs/api.md\")).unwrap();\r\n\r\n        let files = collect_files(base_path, \u0026[], \u0026[]).unwrap();\r\n        let tree = build_file_tree(\u0026files, base_path);\r\n\r\n        let mut docs_tree = BTreeMap::new();\r\n        docs_tree.insert(\"api.md\".to_string(), FileNode::File);\r\n        docs_tree.insert(\"guide.md\".to_string(), FileNode::File);\r\n        docs_tree.insert(\"readme.md\".to_string(), FileNode::File);\r\n\r\n        let mut expected: FileTree = BTreeMap::new();\r\n        expected.insert(\"docs\".to_string(), FileNode::Directory(docs_tree));\r\n\r\n        assert_eq!(tree, expected);\r\n    }\r\n}\r\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":11240984669916758016}},{"line":18,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":19,"address":[],"length":0,"stats":{"Line":144115188075855870}},{"line":23,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":29,"address":[],"length":0,"stats":{"Line":11240984669916758016}},{"line":33,"address":[],"length":0,"stats":{"Line":3963167672086036479}},{"line":34,"address":[],"length":0,"stats":{"Line":7926335344172072958}},{"line":35,"address":[],"length":0,"stats":{"Line":72057594037927946}},{"line":40,"address":[],"length":0,"stats":{"Line":13402712491054596095}},{"line":42,"address":[],"length":0,"stats":{"Line":3314649325744685053}},{"line":46,"address":[],"length":0,"stats":{"Line":17149707381026848757}},{"line":47,"address":[],"length":0,"stats":{"Line":13330654897016668160}},{"line":50,"address":[],"length":0,"stats":{"Line":17149707381026848753}},{"line":57,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":58,"address":[],"length":0,"stats":{"Line":3746994889972252672}},{"line":61,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":62,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":64,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":65,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":66,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":73,"address":[],"length":0,"stats":{"Line":2954361355555045376}},{"line":78,"address":[],"length":0,"stats":{"Line":9871890383196127234}},{"line":79,"address":[],"length":0,"stats":{"Line":6341068275337658376}},{"line":80,"address":[],"length":0,"stats":{"Line":15420325124116578306}},{"line":82,"address":[],"length":0,"stats":{"Line":5548434740920451074}},{"line":84,"address":[],"length":0,"stats":{"Line":11601272640106397700}},{"line":85,"address":[],"length":0,"stats":{"Line":16357073846609641484}},{"line":86,"address":[],"length":0,"stats":{"Line":11601272640106397700}},{"line":90,"address":[],"length":0,"stats":{"Line":2954361355555045372}}],"covered":29,"coverable":29}]};
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      }
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;
  const coverageDelta = file.prevRun &&
    (file.covered / file.coverable * 100 - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  const coverage = file.covered / file.coverable * 100;
  const coverageDelta = file.prevRun && (coverage - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function FileContent({file}) {
  return e('pre', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('code', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData && previousData.files.forEach((file) => {
    const path = file.path.slice(commonPath.length).join('/');
    prevFilesMap.set(path, file);
  });

  const files = data.files.map((file) => {
    const path = file.path.slice(commonPath.length);
    const { covered = 0, coverable = 0 } = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: { covered, coverable },
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    }
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));
}());
</script>
</body>
</html>