# Deep Think v5 Evaluation Prompt

> **Usage**: Upload `docs/deep_think_review_v0.8.0.md` as an attachment, then paste the prompt below.
> Generated with: `context-builder -f rs -o deep_think_review_v0.8.0.md -y` (from clean dir, no config overrides)

---

## The Prompt

```
The attached file contains the complete source code (Rust files only) of "context-builder" v0.8.0, a CLI tool that packages codebases into a single markdown file optimized for LLM consumption. This file was generated by the tool itself.

IMPORTANT CONTEXT: You are reviewing a FOURTH ITERATION. Three prior rounds of multi-model review identified and fixed 12 significant bugs. All have been shipped:

ROUND 1 — P0 BUG FIXES (10-model consensus review):
1. DefaultHasher non-determinism → replaced with xxhash-rust (xxh3)
2. mtime-based content hash → now hashes actual file content bytes
3. BTreeMap destroys relevance ordering → preserved via sorted_paths
4. max_tokens not enforced in parallel path → writer thread tracks budget

ROUND 2 — DEEP THINK v3 FIXES:
P0 (determinism):
5. Content hash used absolute OS paths → normalized to relative unix-style
6. No delimiter between path+content in hash → null byte separator added

P1 (user-visible):
7. strip_prefix('+') left extra space → fixed to strip_prefix("+ ")
8. auto_diff ignored max_tokens → now enforces budget with truncation
9. src/tests/ misclassified as source → sub-component check added
10. sorted_paths missing cwd fallback → aligned with state.rs resolution

ROUND 3 — GLM-5 FIXES:
11. Config hash mismatch causing stale cache hits → fixed
12. Various edge cases in diff handling → fixed

NEW IN v0.8.0 (the major release you're reviewing):
- **Tree-sitter integration**: Optional compile-time feature (--features tree-sitter-all)
- **--signatures**: Extract function/class/struct signatures only (AST-based, not regex)
- **--structure**: Per-file structural summary (function count, struct count, lines of code)
- **--truncate smart**: AST-aware truncation that preserves signatures while removing bodies
- **--visibility public/private/all**: Filter by symbol visibility
- **Language support**: Rust, Python, JavaScript, TypeScript, Go, Java, C, C++
- **Graceful degradation**: When compiled without tree-sitter, features warn and fall back

The file uses relevance ordering:
- Category 0: Cargo.toml (project context)
- Category 1: src/lib.rs, src/main.rs (entry points first), then source
- Category 2: tests/*, benches/*
- Category 3: docs, scripts

---

Please perform the following analysis. Take your time — depth matters more than speed.

## Part 1: Tree-Sitter Implementation Review

This is the headline feature of v0.8.0. Review it thoroughly:

1. **Architecture** (src/tree_sitter/): Review the module structure — mod.rs, signatures.rs, structure.rs, truncation.rs, language_support.rs, and the languages/ subdirectory. Is this organization clean? Is the abstraction level right?

2. **Language Definitions** (src/tree_sitter/languages/*.rs): Each language defines node types, signature patterns, and structural queries. Review at least Rust and one other language:
   - Are the tree-sitter query patterns correct?
   - Are important constructs missing? (e.g., traits in Rust, protocols in Python, interfaces in TS)
   - Could any pattern produce misleading or incomplete signatures?

3. **Signature Extraction** (src/tree_sitter/signatures.rs): Review the core extraction logic:
   - Is the signature formatting clean and consistent across languages?
   - Are edge cases handled? (empty files, syntax errors, nested classes, async functions, generics)
   - Is the output deterministic for the same input?

4. **Smart Truncation** (src/tree_sitter/truncation.rs): Review the AST-aware truncation:
   - Does it correctly preserve signatures while removing function bodies?
   - Are there cases where it could produce syntactically broken output?
   - Is the token budget respected accurately?

5. **Graceful Degradation** (lib.rs, conditionally compiled): When tree-sitter features are not compiled:
   - Is the warning message appropriate?
   - Could the fallback path produce subtly different output that breaks downstream tooling?

## Part 2: Remaining Bug Hunt

Look for bugs that all 4 review rounds missed:

1. **Tree-sitter specific**: Memory leaks from tree-sitter parsers? Panics on malformed input? Unicode handling in AST positions?
2. **Integration bugs**: When --signatures is combined with --max-tokens, does truncation work correctly? What about --signatures + --diff?
3. **Edge cases**: What happens with:
   - Files that fail to parse (syntax errors)
   - Mixed-language repos (some files parse, some don't)
   - Very large single files (>100K lines)
   - Files with only comments, no code
   - Macro-heavy code (Rust proc macros, C preprocessor)
4. **Concurrency**: The parallel processing path + tree-sitter parsing — any thread safety issues?

## Part 3: Architecture Health Assessment

After 4 rounds and a major feature addition:

1. **lib.rs size**: At ~1500 lines, is lib.rs doing too much? Should tree-sitter integration be further decoupled?
2. **Feature flag hygiene**: Is #[cfg(feature = "tree-sitter-base")] used consistently? Any dead code paths?
3. **Error handling**: Are tree-sitter parse failures handled gracefully everywhere, or could they propagate as panics?
4. **Testing**: How well are the tree-sitter features tested? What's missing?

## Part 4: Next Priorities

Given that v0.8.0 ships signatures/structure, what are the TOP 5 highest-impact improvements? Rank by value × feasibility:

- **Problem** (concrete user pain)
- **Design** (files to change, approach)
- **Complexity** (S/M/L)

Focus exclusively on things that would make YOU (the LLM reading this output) significantly better at understanding and working with codebases.
```
