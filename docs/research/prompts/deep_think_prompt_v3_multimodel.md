# Deep Think v3 Multi-Model Review Prompt

> **Usage**: Upload the context file as an attachment, then paste the prompt below.
> Generated with: `context-builder -d . --filter rs,toml,md,sh,yml --signatures -o docs/research/context-files/deep_think_context_v3.md -y`

---

## The Prompt

```
The attached file contains the complete source code of "context-builder" v0.8.2, a CLI tool that packages codebases into a single markdown file optimized for LLM consumption. This file was generated by the tool itself, with --signatures enabled (Tree-Sitter AST extraction).

IMPORTANT CONTEXT: You are reviewing a SIXTH ITERATION. Five prior rounds of multi-model review identified and fixed ~15 significant bugs. All have been shipped. Here is the full fix history:

ROUND 1 — 10-MODEL CONSENSUS REVIEW (v0.7.0):
1. DefaultHasher non-determinism → replaced with xxhash-rust (xxh3)
2. mtime-based content hash → now hashes actual file content bytes
3. BTreeMap destroys relevance ordering → preserved via sorted_paths
4. max_tokens not enforced in parallel path → writer thread tracks budget

ROUND 2 — DEEP THINK v3 FIXES:
5. Content hash used absolute OS paths → normalized to relative unix-style
6. No delimiter between path+content in hash → null byte separator added
7. strip_prefix('+') left extra space → fixed to strip_prefix("+ ")
8. auto_diff ignored max_tokens → now enforces budget with truncation
9. src/tests/ misclassified as source → sub-component check added
10. sorted_paths missing cwd fallback → aligned with state.rs resolution

ROUND 3 — GLM-5 FIXES:
11. Config hash mismatch causing stale cache hits → fixed
12. Various edge cases in diff handling → fixed

ROUND 4-5 — TREE-SITTER POLISH (v0.8.0–v0.8.2):
13. Language definitions refactored from string slicing to byte-based for safety
14. Arrow function body leak in JavaScript signatures → fixed
15. Python decorator handling and TypeScript export signatures → fixed
16. Rust tuple struct and C header handling → improved

NEW SINCE v0.7.0 (everything you're reviewing):

**Tree-Sitter Integration (the major feature)**:
- Optional compile-time feature (--features tree-sitter-all)
- --signatures: Extract function/class/struct signatures only (AST-based)
- --structure: Per-file structural summary (function count, struct count, LOC)
- --truncate smart: AST-aware truncation preserving signatures, removing bodies
- --visibility public/private/all: Filter by symbol visibility
- Languages: Rust, Python, JavaScript, TypeScript, Go, Java, C, C++
- Graceful degradation when compiled without tree-sitter

**Distribution & Security (new)**:
- Cross-platform release workflow (.github/workflows/release.yml)
  - Builds for Linux x86_64, macOS x86_64+aarch64, Windows x86_64
  - Generates SHA256SUMS file for all release artifacts
- install.sh: Universal installer with SHA256 checksum verification
  - Auto-detects OS/arch, downloads correct binary
  - Verifies integrity before installing
- Winget package manifest for `winget install context-builder` (PR pending)
- SKILL.md updated as an agentic skill spec for AI agent consumption

**Quality & Testing**:
- CI: Tests on Linux, macOS, Windows + MSRV check + security audit + coverage
- 10+ integration test files covering edge cases, determinism, parallel memory
- Auto-ignore common heavy directories (node_modules, .git, target, etc.)
- Context window overflow warnings with actionable recommendations

The file uses relevance ordering:
- Category 0: Cargo.toml, README.md (project context)
- Category 1: src/lib.rs, src/main.rs (entry points first), then source
- Category 2: tests/*, benches/*
- Category 3: docs, scripts, CI config

---

Please perform the following analysis. Take your time — depth matters more than speed.

## Part 1: Tree-Sitter Implementation Review

This is the headline feature. Review it thoroughly:

1. **Architecture** (src/tree_sitter/): Review the module structure — mod.rs, signatures.rs, structure.rs, truncation.rs, language_support.rs, and languages/. Is this well-organized? Is the abstraction level right?

2. **Language Definitions** (src/tree_sitter/languages/*.rs): Each language defines node types, signature patterns via byte-offset slicing. Review at least 3 languages:
   - Are the tree-sitter query patterns correct?
   - Are important constructs missing? (traits, protocols, interfaces, generics, async)
   - Could any pattern produce misleading or incomplete signatures?
   - Is the byte-slicing approach safe against UTF-8 boundary issues?

3. **Signature Extraction** (src/tree_sitter/signatures.rs): Core extraction logic:
   - Is the output clean and consistent across languages?
   - Edge cases: empty files, syntax errors, nested classes, async, generics?
   - Is output deterministic for the same input?

4. **Smart Truncation** (src/tree_sitter/truncation.rs):
   - Does it correctly preserve signatures while removing function bodies?
   - Token budget accuracy?
   - Could it produce syntactically broken output?

5. **Graceful Degradation** (cfg-gated code in lib.rs, markdown.rs):
   - Is the warning appropriate?
   - Could the fallback path produce subtly different output?

## Part 2: Distribution & Security Review

New critical surface area — review the release pipeline:

1. **Release Workflow** (.github/workflows/release.yml):
   - Is the SHA256SUMS generation correct? Could the sed command produce wrong filenames?
   - Any supply chain risks? (dependency caching, build provenance)
   - Could a malformed tag trigger unexpected behavior?

2. **Install Script** (install.sh):
   - Is the checksum verification robust? Edge cases (missing SHA256SUMS, wrong format)?
   - Could TOCTOU (time-of-check-time-of-use) between download and verification be exploited?
   - Does it handle interrupted downloads gracefully?
   - Platform compatibility: sh portability, macOS shasum vs Linux sha256sum?

3. **Winget Manifest** (winget/manifests/):
   - Is the portable installer type correct for a standalone binary?
   - Any issues with the manifest structure?

## Part 3: Bug Hunt

Look for bugs that previous rounds missed:

1. **Tree-sitter + core integration**: --signatures combined with --max-tokens? --signatures + --diff? --structure + --truncate?
2. **Concurrency**: Parallel processing + tree-sitter parsing — thread safety?
3. **Edge cases**:
   - Files that fail to parse (syntax errors)
   - Very large files (>100K lines)
   - Files with only comments
   - Macro-heavy code (proc macros, preprocessor directives)
   - Binary files incorrectly included
4. **Config resolution**: CLI flags vs config file vs defaults — any precedence bugs?
5. **Cache invalidation**: Are there scenarios where the cache returns stale data after config or code changes?

## Part 4: Architecture Health

After 6 review rounds and a major feature addition:

1. **lib.rs complexity**: Is it doing too much? Should auto-diff be extracted?
2. **Feature flag hygiene**: #[cfg(feature = "tree-sitter-base")] — consistent and correct?
3. **Error handling**: Are parse failures handled gracefully everywhere, or could they panic?
4. **Test coverage**: What's the most impactful untested path?

## Part 5: Next Priorities

Given v0.8.2's capabilities, what are the TOP 5 highest-impact improvements? Rank by value × feasibility:

- **Problem** (concrete user pain or LLM quality issue)
- **Design** (files to change, approach)
- **Complexity** (S/M/L)

Focus on things that would make YOU (the LLM reading this output) significantly better at understanding and working with codebases. What information is missing? What's formatted suboptimally? What would you add if you could?
```
